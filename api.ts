/* tslint:disable */
/* eslint-disable */
/**
 * API Endpoints
 * Deliver monetary rewards and incentives to employees, customers, survey participants, and more through the Tremendous API. For organizational tasks, like managing your organization and it\'s members within Tremendous, please see the Tremendous Organizational API.
 *
 * The version of the OpenAPI document: 2
 * Contact: developers@tremendous.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Ignore flagging rules for rewards redeemed by an email or domain matching this list.
 * @export
 * @interface AllowEmail
 */
export interface AllowEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof AllowEmail
     */
    'emails': Array<string>;
}
/**
 * The list of emails and domains where a matching redemption will ignore other flagging rules and automatically go through.
 * @export
 * @interface AllowEmail1
 */
export interface AllowEmail1 {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof AllowEmail1
     */
    'emails': Array<string>;
}
/**
 * Ignore flagging rules for rewards redeemed by an IP matching this list.
 * @export
 * @interface AllowIp
 */
export interface AllowIp {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof AllowIp
     */
    'ips': Array<string>;
}
/**
 * The list of IP addresses and/or IP ranges where a matching redemption will ignore other flagging rules and automatically go through.
 * @export
 * @interface AllowIp1
 */
export interface AllowIp1 {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof AllowIp1
     */
    'ips': Array<string>;
}
/**
 * A balance transaction represents a specific movement or change in an account\'s balance. 
 * @export
 * @interface BalanceTransaction
 */
export interface BalanceTransaction {
    /**
     * Date that the transaction was created
     * @type {string}
     * @memberof BalanceTransaction
     */
    'created_at': string;
    /**
     * Amount of the transaction in USD
     * @type {number}
     * @memberof BalanceTransaction
     */
    'amount': number;
    /**
     * The updated total after the transaction. Note that this running balance may be delayed and contain `null`.
     * @type {number}
     * @memberof BalanceTransaction
     */
    'balance': number;
    /**
     * The action that was performed
     * @type {string}
     * @memberof BalanceTransaction
     */
    'action': string;
    /**
     * A brief description of the transaction
     * @type {string}
     * @memberof BalanceTransaction
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface BaseOrderForCreate
 */
export interface BaseOrderForCreate {
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof BaseOrderForCreate
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {SingleRewardOrder1Payment}
     * @memberof BaseOrderForCreate
     */
    'payment': SingleRewardOrder1Payment;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from. 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'description': string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign. 
     * @type {Array<string>}
     * @memberof Campaign
     */
    'products': Array<string>;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof Campaign
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof Campaign
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from. 
 * @export
 * @interface CampaignBase
 */
export interface CampaignBase {
    /**
     * 
     * @type {string}
     * @memberof CampaignBase
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CampaignBase
     */
    'name'?: string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof CampaignBase
     */
    'description'?: string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign. 
     * @type {Array<string>}
     * @memberof CampaignBase
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof CampaignBase
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof CampaignBase
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * Name of the channel in which the order was created
 * @export
 * @enum {string}
 */

export const Channel = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type Channel = typeof Channel[keyof typeof Channel];


/**
 * 
 * @export
 * @interface CreateApiKey200Response
 */
export interface CreateApiKey200Response {
    /**
     * The new API key
     * @type {string}
     * @memberof CreateApiKey200Response
     */
    'api_key'?: string;
}
/**
 * 
 * @export
 * @interface CreateCampaign201Response
 */
export interface CreateCampaign201Response {
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInner}
     * @memberof CreateCampaign201Response
     */
    'campaign': ListCampaigns200ResponseCampaignsInner;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from. 
 * @export
 * @interface CreateCampaignRequest
 */
export interface CreateCampaignRequest {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'name': string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'description': string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign. 
     * @type {Array<string>}
     * @memberof CreateCampaignRequest
     */
    'products': Array<string>;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof CreateCampaignRequest
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof CreateCampaignRequest
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * 
 * @export
 * @interface CreateInvoice
 */
export interface CreateInvoice {
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof CreateInvoice
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof CreateInvoice
     */
    'amount': number;
    /**
     * A note to be included in the invoice. This is for your internal use and will not be visible to the recipient. 
     * @type {string}
     * @memberof CreateInvoice
     */
    'memo'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateInvoice200Response
 */
export interface CreateInvoice200Response {
    /**
     * 
     * @type {ListInvoices200ResponseInvoicesInner}
     * @memberof CreateInvoice200Response
     */
    'invoice': ListInvoices200ResponseInvoicesInner;
}
/**
 * 
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'amount': number;
    /**
     * A note to be included in the invoice. This is for your internal use and will not be visible to the recipient. 
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'memo'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateMember
 */
export interface CreateMember {
    /**
     * Email address of the member
     * @type {string}
     * @memberof CreateMember
     */
    'email': string;
    /**
     * The role ID of the member within the organization. 
     * @type {string}
     * @memberof CreateMember
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface CreateMember200Response
 */
export interface CreateMember200Response {
    /**
     * 
     * @type {ListMembers200ResponseMembersInner}
     * @memberof CreateMember200Response
     */
    'member': ListMembers200ResponseMembersInner;
}
/**
 * 
 * @export
 * @interface CreateMemberRequest
 */
export interface CreateMemberRequest {
    /**
     * Email address of the member
     * @type {string}
     * @memberof CreateMemberRequest
     */
    'email': string;
    /**
     * The role ID of the member within the organization. 
     * @type {string}
     * @memberof CreateMemberRequest
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface CreateOrder200Response
 */
export interface CreateOrder200Response {
    /**
     * 
     * @type {ListOrders200ResponseOrdersInner}
     * @memberof CreateOrder200Response
     */
    'order': ListOrders200ResponseOrdersInner;
}
/**
 * @type CreateOrderRequest
 * @export
 */
export type CreateOrderRequest = SingleRewardOrder1;

/**
 * 
 * @export
 * @interface CreateOrganization
 */
export interface CreateOrganization {
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganization
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof CreateOrganization
     */
    'website': string;
    /**
     * Default value is `false`. Set to true to also generate an API key associated to the new organization.
     * @type {boolean}
     * @memberof CreateOrganization
     */
    'with_api_key'?: boolean;
    /**
     * 
     * @type {CreateOrganizationRequestCopySettings}
     * @memberof CreateOrganization
     */
    'copy_settings'?: CreateOrganizationRequestCopySettings;
    /**
     * Phone number of the organization. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof CreateOrganization
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrganization200Response
 */
export interface CreateOrganization200Response {
    /**
     * 
     * @type {CreateOrganization200ResponseOrganization}
     * @memberof CreateOrganization200Response
     */
    'organization'?: CreateOrganization200ResponseOrganization;
}
/**
 * Organizations are a way to separate different parts of your business within the same Tremendous account. Your root Tremendous account is an organization itself and can have multiple sub-organizations.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  Each organizations can have it\'s own API key. 
 * @export
 * @interface CreateOrganization200ResponseOrganization
 */
export interface CreateOrganization200ResponseOrganization {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'id'?: string;
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'website': string;
    /**
     * Status of the organization. Organizations need to be approved to be able to use them to send out rewards.
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'status'?: CreateOrganization200ResponseOrganizationStatusEnum;
    /**
     * Timestamp of when the organization has been created.  *This field is only returned when creating an organization.* It is not returned anymore when retrieving or listing organizations. 
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'created_at'?: string;
    /**
     * The API key for the created organization. This property is only returned when `with_api_key` is set to `true`. 
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'api_key'?: string;
}

export const CreateOrganization200ResponseOrganizationStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type CreateOrganization200ResponseOrganizationStatusEnum = typeof CreateOrganization200ResponseOrganizationStatusEnum[keyof typeof CreateOrganization200ResponseOrganizationStatusEnum];

/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'website': string;
    /**
     * Default value is `false`. Set to true to also generate an API key associated to the new organization.
     * @type {boolean}
     * @memberof CreateOrganizationRequest
     */
    'with_api_key'?: boolean;
    /**
     * 
     * @type {CreateOrganizationRequestCopySettings}
     * @memberof CreateOrganizationRequest
     */
    'copy_settings'?: CreateOrganizationRequestCopySettings;
    /**
     * Phone number of the organization. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'phone'?: string;
}
/**
 * A list of the settings that you wish to copy over to the new organization.
 * @export
 * @interface CreateOrganizationRequestCopySettings
 */
export interface CreateOrganizationRequestCopySettings {
    /**
     * Copy over the campaigns from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'campaigns'?: boolean;
    /**
     * Copy over the custom fields from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'custom_fields'?: boolean;
    /**
     * Copy over the order approvals settings from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'order_approvals'?: boolean;
    /**
     * Copy over the payment methods from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'payment_methods'?: boolean;
    /**
     * Copy over the security settings from the current organization to the new organization. Defaults to `true`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'security_settings'?: boolean;
    /**
     * Copy over the users and custom roles from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'users'?: boolean;
    /**
     * Copy over the custom roles from the current organization to the new organization. Custom roles are always copied if `users` is `true`. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'custom_roles'?: boolean;
    /**
     * Copy over the fraud prevention settings and rules from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'fraud_prevention'?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePublicKey
 */
export interface CreatePublicKey {
    /**
     * Base64 encoded (public) PEM file
     * @type {string}
     * @memberof CreatePublicKey
     */
    'public_key': string;
}
/**
 * 
 * @export
 * @interface CreateWebhook200Response
 */
export interface CreateWebhook200Response {
    /**
     * 
     * @type {ListWebhooks200ResponseWebhooksInner}
     * @memberof CreateWebhook200Response
     */
    'webhook'?: ListWebhooks200ResponseWebhooksInner;
}
/**
 * 
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CurrencyCodes = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
} as const;

export type CurrencyCodes = typeof CurrencyCodes[keyof typeof CurrencyCodes];


/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof CustomField
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof CustomField
     */
    'value'?: string | null;
    /**
     * Label of the custom field
     * @type {string}
     * @memberof CustomField
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface DeleteFraudRule200Response
 */
export interface DeleteFraudRule200Response {
    /**
     * A description of the result
     * @type {string}
     * @memberof DeleteFraudRule200Response
     */
    'message': string;
}
/**
 * Details on how the reward is delivered to the recipient. 
 * @export
 * @interface DeliveryDetails
 */
export interface DeliveryDetails {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof DeliveryDetails
     */
    'method': DeliveryDetailsMethodEnum;
    /**
     * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled. 
     * @type {string}
     * @memberof DeliveryDetails
     */
    'status': DeliveryDetailsStatusEnum;
}

export const DeliveryDetailsMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
} as const;

export type DeliveryDetailsMethodEnum = typeof DeliveryDetailsMethodEnum[keyof typeof DeliveryDetailsMethodEnum];
export const DeliveryDetailsStatusEnum = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
} as const;

export type DeliveryDetailsStatusEnum = typeof DeliveryDetailsStatusEnum[keyof typeof DeliveryDetailsStatusEnum];

/**
 * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> 
 * @export
 * @enum {string}
 */

export const DeliveryMethod = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
} as const;

export type DeliveryMethod = typeof DeliveryMethod[keyof typeof DeliveryMethod];


/**
 * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled. 
 * @export
 * @enum {string}
 */

export const DeliveryStatus = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
} as const;

export type DeliveryStatus = typeof DeliveryStatus[keyof typeof DeliveryStatus];


/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof ErrorModel
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'id'?: string;
    /**
     * Label of the field
     * @type {string}
     * @memberof Field
     */
    'label'?: string;
    /**
     * Type of the values of the field
     * @type {string}
     * @memberof Field
     */
    'data_type'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Field
     */
    'data'?: { [key: string]: any; };
    /**
     * Is this field required (true) or optional (false)
     * @type {boolean}
     * @memberof Field
     */
    'required'?: boolean;
    /**
     * Type of objects this field gets associated with
     * @type {string}
     * @memberof Field
     */
    'scope'?: string;
}
/**
 * 
 * @export
 * @interface FraudConfigAllowEmail
 */
export interface FraudConfigAllowEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof FraudConfigAllowEmail
     */
    'emails': Array<string>;
}
/**
 * 
 * @export
 * @interface FraudConfigCountry
 */
export interface FraudConfigCountry {
    /**
     * When type is `whitelist`, it flags any countries that *are not* present in the list. When type is `blacklist`, it flags any countries that *are* present in the list. 
     * @type {string}
     * @memberof FraudConfigCountry
     */
    'type': FraudConfigCountryTypeEnum;
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof FraudConfigCountry
     */
    'countries': Array<string>;
}

export const FraudConfigCountryTypeEnum = {
    Whitelist: 'whitelist',
    Blacklist: 'blacklist'
} as const;

export type FraudConfigCountryTypeEnum = typeof FraudConfigCountryTypeEnum[keyof typeof FraudConfigCountryTypeEnum];

/**
 * 
 * @export
 * @interface FraudConfigCountryUpdateList
 */
export interface FraudConfigCountryUpdateList {
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof FraudConfigCountryUpdateList
     */
    'countries': Array<string>;
}
/**
 * 
 * @export
 * @interface FraudConfigIP
 */
export interface FraudConfigIP {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof FraudConfigIP
     */
    'ips': Array<string>;
}
/**
 * 
 * @export
 * @interface FraudConfigRedeemedRewardsAmount
 */
export interface FraudConfigRedeemedRewardsAmount {
    /**
     * The total amount in USD of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof FraudConfigRedeemedRewardsAmount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof FraudConfigRedeemedRewardsAmount
     */
    'period': FraudConfigRedeemedRewardsAmountPeriodEnum;
}

export const FraudConfigRedeemedRewardsAmountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
} as const;

export type FraudConfigRedeemedRewardsAmountPeriodEnum = typeof FraudConfigRedeemedRewardsAmountPeriodEnum[keyof typeof FraudConfigRedeemedRewardsAmountPeriodEnum];

/**
 * 
 * @export
 * @interface FraudConfigRedeemedRewardsCount
 */
export interface FraudConfigRedeemedRewardsCount {
    /**
     * The number of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof FraudConfigRedeemedRewardsCount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof FraudConfigRedeemedRewardsCount
     */
    'period': FraudConfigRedeemedRewardsCountPeriodEnum;
}

export const FraudConfigRedeemedRewardsCountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
} as const;

export type FraudConfigRedeemedRewardsCountPeriodEnum = typeof FraudConfigRedeemedRewardsCountPeriodEnum[keyof typeof FraudConfigRedeemedRewardsCountPeriodEnum];

/**
 * 
 * @export
 * @interface FraudConfigReviewEmail
 */
export interface FraudConfigReviewEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof FraudConfigReviewEmail
     */
    'emails'?: Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof FraudConfigReviewEmail
     */
    'domains'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FraudGenericResponse
 */
export interface FraudGenericResponse {
    /**
     * A description of the result
     * @type {string}
     * @memberof FraudGenericResponse
     */
    'message': string;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface FraudReview
 */
export interface FraudReview {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released. 
     * @type {string}
     * @memberof FraudReview
     */
    'status'?: FraudReviewStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email` 
     * @type {Array<string>}
     * @memberof FraudReview
     */
    'reasons'?: Array<FraudReviewReasonsEnum>;
    /**
     * The name of the person who reviewed the reward, or `Automatic Review` if the reward was blocked automatically. Rewards can be automatically blocked if they remain in the flagged fraud queue for more than 30 days.  This field is only present if the status is not `flagged`. 
     * @type {string}
     * @memberof FraudReview
     */
    'reviewed_by'?: string;
    /**
     * When the reward was blocked or released following fraud review.  This field is only present if the status is not `flagged`. 
     * @type {string}
     * @memberof FraudReview
     */
    'reviewed_at'?: string;
    /**
     * 
     * @type {GetFraudReview200ResponseFraudReviewRelatedRewards}
     * @memberof FraudReview
     */
    'related_rewards'?: GetFraudReview200ResponseFraudReviewRelatedRewards;
    /**
     * The device fingerprint, if known.
     * @type {string}
     * @memberof FraudReview
     */
    'device_id'?: string;
    /**
     * The product selected to claim the reward
     * @type {string}
     * @memberof FraudReview
     */
    'redemption_method'?: FraudReviewRedemptionMethodEnum;
    /**
     * Date the reward was redeemed
     * @type {string}
     * @memberof FraudReview
     */
    'redeemed_at'?: string;
    /**
     * 
     * @type {GetFraudReview200ResponseFraudReviewGeo}
     * @memberof FraudReview
     */
    'geo'?: GetFraudReview200ResponseFraudReviewGeo;
    /**
     * 
     * @type {OrderWithoutLinkRewardsInner}
     * @memberof FraudReview
     */
    'reward'?: OrderWithoutLinkRewardsInner;
}

export const FraudReviewStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
} as const;

export type FraudReviewStatusEnum = typeof FraudReviewStatusEnum[keyof typeof FraudReviewStatusEnum];
export const FraudReviewReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
} as const;

export type FraudReviewReasonsEnum = typeof FraudReviewReasonsEnum[keyof typeof FraudReviewReasonsEnum];
export const FraudReviewRedemptionMethodEnum = {
    Paypal: 'paypal',
    Bank: 'bank',
    MerchantCard: 'merchant card',
    VisaCard: 'visa card',
    Charity: 'charity',
    Venmo: 'venmo'
} as const;

export type FraudReviewRedemptionMethodEnum = typeof FraudReviewRedemptionMethodEnum[keyof typeof FraudReviewRedemptionMethodEnum];

/**
 * 
 * @export
 * @interface FraudReviewGeo
 */
export interface FraudReviewGeo {
    /**
     * The recipient\'s IP.
     * @type {string}
     * @memberof FraudReviewGeo
     */
    'ip'?: string;
    /**
     * The country code (ISO-3166 alpha-2 character code) linked to the recipient\'s IP.
     * @type {string}
     * @memberof FraudReviewGeo
     */
    'country'?: string;
    /**
     * The city associated with the recipient\'s IP.
     * @type {string}
     * @memberof FraudReviewGeo
     */
    'city'?: string;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface FraudReviewListItem
 */
export interface FraudReviewListItem {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released. 
     * @type {string}
     * @memberof FraudReviewListItem
     */
    'status'?: FraudReviewListItemStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email` 
     * @type {Array<string>}
     * @memberof FraudReviewListItem
     */
    'reasons'?: Array<FraudReviewListItemReasonsEnum>;
    /**
     * 
     * @type {OrderWithoutLinkRewardsInner}
     * @memberof FraudReviewListItem
     */
    'reward'?: OrderWithoutLinkRewardsInner;
}

export const FraudReviewListItemStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
} as const;

export type FraudReviewListItemStatusEnum = typeof FraudReviewListItemStatusEnum[keyof typeof FraudReviewListItemStatusEnum];
export const FraudReviewListItemReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
} as const;

export type FraudReviewListItemReasonsEnum = typeof FraudReviewListItemReasonsEnum[keyof typeof FraudReviewListItemReasonsEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const FraudReviewReason = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
} as const;

export type FraudReviewReason = typeof FraudReviewReason[keyof typeof FraudReviewReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const FraudReviewRedemptionMethod = {
    Paypal: 'paypal',
    Bank: 'bank',
    MerchantCard: 'merchant card',
    VisaCard: 'visa card',
    Charity: 'charity',
    Venmo: 'venmo'
} as const;

export type FraudReviewRedemptionMethod = typeof FraudReviewRedemptionMethod[keyof typeof FraudReviewRedemptionMethod];


/**
 * 
 * @export
 * @interface FraudReviewRelatedRewards
 */
export interface FraudReviewRelatedRewards {
    /**
     * The IDs of rewards that have similar attributes to the fraud reward. A maximum of 100 IDs is returned. 
     * @type {Array<string>}
     * @memberof FraudReviewRelatedRewards
     */
    'ids'?: Array<string>;
    /**
     * How many related rewards were found in total.
     * @type {number}
     * @memberof FraudReviewRelatedRewards
     */
    'count'?: number;
    /**
     * How many related rewards have been blocked.
     * @type {number}
     * @memberof FraudReviewRelatedRewards
     */
    'blocked_count'?: number;
    /**
     * Total amount claimed by the related rewards (in USD).
     * @type {number}
     * @memberof FraudReviewRelatedRewards
     */
    'aggregated_value'?: number;
}
/**
 * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released. 
 * @export
 * @enum {string}
 */

export const FraudReviewStatus = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
} as const;

export type FraudReviewStatus = typeof FraudReviewStatus[keyof typeof FraudReviewStatus];


/**
 * 
 * @export
 * @interface FraudRule200Response
 */
export interface FraudRule200Response {
    /**
     * A description of the result
     * @type {string}
     * @memberof FraudRule200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface FraudRule400Response
 */
export interface FraudRule400Response {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof FraudRule400Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * 
 * @export
 * @interface FraudRule422Response
 */
export interface FraudRule422Response {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof FraudRule422Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * 
 * @export
 * @interface FraudRuleRequest
 */
export interface FraudRuleRequest {
    /**
     * 
     * @type {FraudRuleRequestConfig}
     * @memberof FraudRuleRequest
     */
    'config'?: FraudRuleRequestConfig;
}
/**
 * The configuration associated with the rule. The properties allowed depend on the type of rule.
 * @export
 * @interface FraudRuleRequestConfig
 */
export interface FraudRuleRequestConfig {
    /**
     * When type is `whitelist`, it flags any countries that *are not* present in the list. When type is `blacklist`, it flags any countries that *are* present in the list. 
     * @type {string}
     * @memberof FraudRuleRequestConfig
     */
    'type': FraudRuleRequestConfigTypeEnum;
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'countries': Array<string>;
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'ips': Array<string>;
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'emails': Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'domains'?: Array<string>;
    /**
     * The total amount in USD of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof FraudRuleRequestConfig
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof FraudRuleRequestConfig
     */
    'period': FraudRuleRequestConfigPeriodEnum;
}

export const FraudRuleRequestConfigTypeEnum = {
    Whitelist: 'whitelist',
    Blacklist: 'blacklist'
} as const;

export type FraudRuleRequestConfigTypeEnum = typeof FraudRuleRequestConfigTypeEnum[keyof typeof FraudRuleRequestConfigTypeEnum];
export const FraudRuleRequestConfigPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
} as const;

export type FraudRuleRequestConfigPeriodEnum = typeof FraudRuleRequestConfigPeriodEnum[keyof typeof FraudRuleRequestConfigPeriodEnum];

/**
 * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list 
 * @export
 * @enum {string}
 */

export const FraudRuleType = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
} as const;

export type FraudRuleType = typeof FraudRuleType[keyof typeof FraudRuleType];


/**
 * An active fraud rule
 * @export
 * @interface FraudRulesListItem
 */
export interface FraudRulesListItem {
    /**
     * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list 
     * @type {string}
     * @memberof FraudRulesListItem
     */
    'rule_type'?: FraudRulesListItemRuleTypeEnum;
    /**
     * The configuration associated with the rule. The properties allowed depend on the type of rule. This property is only present for rules that require configuration. 
     * @type {object}
     * @memberof FraudRulesListItem
     */
    'config'?: object | null;
}

export const FraudRulesListItemRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
} as const;

export type FraudRulesListItemRuleTypeEnum = typeof FraudRulesListItemRuleTypeEnum[keyof typeof FraudRulesListItemRuleTypeEnum];

/**
 * 
 * @export
 * @interface FundingSource
 */
export interface FundingSource {
    /**
     * 
     * @type {string}
     * @memberof FundingSource
     */
    'id': string;
    /**
     * You can pay for rewards using different payment methods on Tremendous:  <table>   <thead>     <tr>       <th>Payment Method</th>       <th>Description</th>       </tr>   </thead>   <tbody>     <tr>       <td><code>balance</code></td>       <td>Pre-funded balance in your Tremendous account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>bank_account</code></td>       <td>Bank account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>credit_card</code></td>       <td>Credit card to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>invoice</code></td>       <td>Send rewards to recipients and pay by invoice.</td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof FundingSource
     */
    'method': FundingSourceMethodEnum;
    /**
     * **Only available when `method` is set to `invoice`.** 
     * @type {string}
     * @memberof FundingSource
     */
    'type'?: FundingSourceTypeEnum;
    /**
     * 
     * @type {ListFundingSources200ResponseFundingSourcesInnerMeta}
     * @memberof FundingSource
     */
    'meta': ListFundingSources200ResponseFundingSourcesInnerMeta;
}

export const FundingSourceMethodEnum = {
    Balance: 'balance',
    BankAccount: 'bank_account',
    CreditCard: 'credit_card',
    Invoice: 'invoice'
} as const;

export type FundingSourceMethodEnum = typeof FundingSourceMethodEnum[keyof typeof FundingSourceMethodEnum];
export const FundingSourceTypeEnum = {
    Commercial: 'COMMERCIAL',
    ProForma: 'PRO_FORMA',
    PrefundingOnly: 'PREFUNDING_ONLY'
} as const;

export type FundingSourceTypeEnum = typeof FundingSourceTypeEnum[keyof typeof FundingSourceTypeEnum];

/**
 * 
 * @export
 * @interface GenerateRewardLink200Response
 */
export interface GenerateRewardLink200Response {
    /**
     * 
     * @type {GenerateRewardLink200ResponseReward}
     * @memberof GenerateRewardLink200Response
     */
    'reward': GenerateRewardLink200ResponseReward;
}
/**
 * The redemption link for a reward.
 * @export
 * @interface GenerateRewardLink200ResponseReward
 */
export interface GenerateRewardLink200ResponseReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof GenerateRewardLink200ResponseReward
     */
    'id'?: string;
    /**
     * Link to redeem the reward at. You need to deliver this link to the recipient. 
     * @type {string}
     * @memberof GenerateRewardLink200ResponseReward
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface GenerateRewardLink403Response
 */
export interface GenerateRewardLink403Response {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof GenerateRewardLink403Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * 
 * @export
 * @interface GenerateRewardToken200Response
 */
export interface GenerateRewardToken200Response {
    /**
     * 
     * @type {GenerateRewardToken200ResponseReward}
     * @memberof GenerateRewardToken200Response
     */
    'reward': GenerateRewardToken200ResponseReward;
}
/**
 * The redemption token for a reward.
 * @export
 * @interface GenerateRewardToken200ResponseReward
 */
export interface GenerateRewardToken200ResponseReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof GenerateRewardToken200ResponseReward
     */
    'id'?: string;
    /**
     * The token to redeem the reward. 
     * @type {string}
     * @memberof GenerateRewardToken200ResponseReward
     */
    'token'?: string;
    /**
     * Date the token expires
     * @type {string}
     * @memberof GenerateRewardToken200ResponseReward
     */
    'expires_at'?: string;
}
/**
 * 
 * @export
 * @interface GetFraudReview200Response
 */
export interface GetFraudReview200Response {
    /**
     * 
     * @type {GetFraudReview200ResponseFraudReview}
     * @memberof GetFraudReview200Response
     */
    'fraud_review': GetFraudReview200ResponseFraudReview;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface GetFraudReview200ResponseFraudReview
 */
export interface GetFraudReview200ResponseFraudReview {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released. 
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'status'?: GetFraudReview200ResponseFraudReviewStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email` 
     * @type {Array<string>}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reasons'?: Array<GetFraudReview200ResponseFraudReviewReasonsEnum>;
    /**
     * The name of the person who reviewed the reward, or `Automatic Review` if the reward was blocked automatically. Rewards can be automatically blocked if they remain in the flagged fraud queue for more than 30 days.  This field is only present if the status is not `flagged`. 
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reviewed_by'?: string;
    /**
     * When the reward was blocked or released following fraud review.  This field is only present if the status is not `flagged`. 
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reviewed_at'?: string;
    /**
     * 
     * @type {GetFraudReview200ResponseFraudReviewRelatedRewards}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'related_rewards'?: GetFraudReview200ResponseFraudReviewRelatedRewards;
    /**
     * The device fingerprint, if known.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'device_id'?: string;
    /**
     * The product selected to claim the reward
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'redemption_method'?: GetFraudReview200ResponseFraudReviewRedemptionMethodEnum;
    /**
     * Date the reward was redeemed
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'redeemed_at'?: string;
    /**
     * 
     * @type {GetFraudReview200ResponseFraudReviewGeo}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'geo'?: GetFraudReview200ResponseFraudReviewGeo;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reward'?: ListRewards200ResponseRewardsInner;
}

export const GetFraudReview200ResponseFraudReviewStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
} as const;

export type GetFraudReview200ResponseFraudReviewStatusEnum = typeof GetFraudReview200ResponseFraudReviewStatusEnum[keyof typeof GetFraudReview200ResponseFraudReviewStatusEnum];
export const GetFraudReview200ResponseFraudReviewReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
} as const;

export type GetFraudReview200ResponseFraudReviewReasonsEnum = typeof GetFraudReview200ResponseFraudReviewReasonsEnum[keyof typeof GetFraudReview200ResponseFraudReviewReasonsEnum];
export const GetFraudReview200ResponseFraudReviewRedemptionMethodEnum = {
    Paypal: 'paypal',
    Bank: 'bank',
    MerchantCard: 'merchant card',
    VisaCard: 'visa card',
    Charity: 'charity',
    Venmo: 'venmo'
} as const;

export type GetFraudReview200ResponseFraudReviewRedemptionMethodEnum = typeof GetFraudReview200ResponseFraudReviewRedemptionMethodEnum[keyof typeof GetFraudReview200ResponseFraudReviewRedemptionMethodEnum];

/**
 * The Geo location, based on the recipient\'s IP.
 * @export
 * @interface GetFraudReview200ResponseFraudReviewGeo
 */
export interface GetFraudReview200ResponseFraudReviewGeo {
    /**
     * The recipient\'s IP.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReviewGeo
     */
    'ip'?: string;
    /**
     * The country code (ISO-3166 alpha-2 character code) linked to the recipient\'s IP.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReviewGeo
     */
    'country'?: string;
    /**
     * The city associated with the recipient\'s IP.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReviewGeo
     */
    'city'?: string;
}
/**
 * The related rewards associated with the fraud review.
 * @export
 * @interface GetFraudReview200ResponseFraudReviewRelatedRewards
 */
export interface GetFraudReview200ResponseFraudReviewRelatedRewards {
    /**
     * The IDs of rewards that have similar attributes to the fraud reward. A maximum of 100 IDs is returned. 
     * @type {Array<string>}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'ids'?: Array<string>;
    /**
     * How many related rewards were found in total.
     * @type {number}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'count'?: number;
    /**
     * How many related rewards have been blocked.
     * @type {number}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'blocked_count'?: number;
    /**
     * Total amount claimed by the related rewards (in USD).
     * @type {number}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'aggregated_value'?: number;
}
/**
 * 
 * @export
 * @interface GetFundingSource200Response
 */
export interface GetFundingSource200Response {
    /**
     * 
     * @type {ListFundingSources200ResponseFundingSourcesInner}
     * @memberof GetFundingSource200Response
     */
    'funding_source': ListFundingSources200ResponseFundingSourcesInner;
}
/**
 * 
 * @export
 * @interface GetMember200Response
 */
export interface GetMember200Response {
    /**
     * 
     * @type {GetMember200ResponseMember}
     * @memberof GetMember200Response
     */
    'member': GetMember200ResponseMember;
}
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more. 
 * @export
 * @interface GetMember200ResponseMember
 */
export interface GetMember200ResponseMember {
    /**
     * 
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization. 
     * @type {boolean}
     * @memberof GetMember200ResponseMember
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization. 
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`. 
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'status': GetMember200ResponseMemberStatusEnum;
    /**
     * List of events related to the member.
     * @type {Array<GetMember200ResponseMemberEventsInner>}
     * @memberof GetMember200ResponseMember
     */
    'events'?: Array<GetMember200ResponseMemberEventsInner>;
}

export const GetMember200ResponseMemberStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
} as const;

export type GetMember200ResponseMemberStatusEnum = typeof GetMember200ResponseMemberStatusEnum[keyof typeof GetMember200ResponseMemberStatusEnum];

/**
 * 
 * @export
 * @interface GetMember200ResponseMemberEventsInner
 */
export interface GetMember200ResponseMemberEventsInner {
    /**
     * Event type
     * @type {string}
     * @memberof GetMember200ResponseMemberEventsInner
     */
    'type'?: GetMember200ResponseMemberEventsInnerTypeEnum;
    /**
     * Timestamp when the event happened
     * @type {string}
     * @memberof GetMember200ResponseMemberEventsInner
     */
    'date_utc'?: string | null;
}

export const GetMember200ResponseMemberEventsInnerTypeEnum = {
    Created: 'created',
    LastLogin: 'last_login'
} as const;

export type GetMember200ResponseMemberEventsInnerTypeEnum = typeof GetMember200ResponseMemberEventsInnerTypeEnum[keyof typeof GetMember200ResponseMemberEventsInnerTypeEnum];

/**
 * 
 * @export
 * @interface GetOrganization200Response
 */
export interface GetOrganization200Response {
    /**
     * 
     * @type {ListOrganizations200ResponseOrganizationsInner}
     * @memberof GetOrganization200Response
     */
    'organization'?: ListOrganizations200ResponseOrganizationsInner;
}
/**
 * 
 * @export
 * @interface GetProductResponse
 */
export interface GetProductResponse {
    /**
     * 
     * @type {ListProductsResponseProductsInner}
     * @memberof GetProductResponse
     */
    'product': ListProductsResponseProductsInner;
}
/**
 * 
 * @export
 * @interface GetReward200Response
 */
export interface GetReward200Response {
    /**
     * 
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof GetReward200Response
     */
    'reward': ListRewards200ResponseRewardsInner;
}
/**
 * Invoices are instruments to fund your Tremendous account\'s balance.  Invoices can be created by your organization programatically. Once we receive your payment, the invoice is marked as `PAID` and we add the respective funds to your account\'s balance. 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * The invoice number
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof Invoice
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof Invoice
     */
    'amount': number;
    /**
     * Status of this invoice  <table>   <thead>     <tr>       <th>Status</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>DELETED</code></td>       <td>Invoice has been deleted by your organization</td>     </tr>     <tr>       <td><code>PAID</code></td>       <td>Invoice has been paid by your organization</td>     </tr>     <tr>       <td><code>OPEN</code></td>       <td>Invoice has been created by your organization but has not been paid, yet</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
    /**
     * List of orders related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof Invoice
     */
    'orders'?: Array<string>;
    /**
     * List of rewards related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof Invoice
     */
    'rewards'?: Array<string>;
    /**
     * Timestamp of when the invoice has been created. 
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
    /**
     * Timestamp of when the invoice has been paid. 
     * @type {string}
     * @memberof Invoice
     */
    'paid_at': string | null;
}

export const InvoiceStatusEnum = {
    Deleted: 'DELETED',
    Paid: 'PAID',
    Open: 'OPEN',
    MarkedAsPaid: 'MARKED_AS_PAID'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];

/**
 * 
 * @export
 * @interface ListBalanceTransactions200Response
 */
export interface ListBalanceTransactions200Response {
    /**
     * 
     * @type {Array<ListBalanceTransactions200ResponseTransactionsInner>}
     * @memberof ListBalanceTransactions200Response
     */
    'transactions': Array<ListBalanceTransactions200ResponseTransactionsInner>;
}
/**
 * A balance transaction represents a specific movement or change in an account\'s balance. 
 * @export
 * @interface ListBalanceTransactions200ResponseTransactionsInner
 */
export interface ListBalanceTransactions200ResponseTransactionsInner {
    /**
     * Date that the transaction was created
     * @type {string}
     * @memberof ListBalanceTransactions200ResponseTransactionsInner
     */
    'created_at': string;
    /**
     * Amount of the transaction in USD
     * @type {number}
     * @memberof ListBalanceTransactions200ResponseTransactionsInner
     */
    'amount': number;
    /**
     * The updated total after the transaction. Note that this running balance may be delayed and contain `null`.
     * @type {number}
     * @memberof ListBalanceTransactions200ResponseTransactionsInner
     */
    'balance': number;
    /**
     * The action that was performed
     * @type {string}
     * @memberof ListBalanceTransactions200ResponseTransactionsInner
     */
    'action': string;
    /**
     * A brief description of the transaction
     * @type {string}
     * @memberof ListBalanceTransactions200ResponseTransactionsInner
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ListCampaigns200Response
 */
export interface ListCampaigns200Response {
    /**
     * 
     * @type {Array<ListCampaigns200ResponseCampaignsInner>}
     * @memberof ListCampaigns200Response
     */
    'campaigns': Array<ListCampaigns200ResponseCampaignsInner>;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from. 
 * @export
 * @interface ListCampaigns200ResponseCampaignsInner
 */
export interface ListCampaigns200ResponseCampaignsInner {
    /**
     * 
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'name': string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'description': string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign. 
     * @type {Array<string>}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'products': Array<string>;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * Definition of the email style
 * @export
 * @interface ListCampaigns200ResponseCampaignsInnerEmailStyle
 */
export interface ListCampaigns200ResponseCampaignsInnerEmailStyle {
    /**
     * If sending via email, this is how the email will appear to be sent from
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'sender_name'?: string | null;
    /**
     * Email subject line
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'subject_line'?: string | null;
    /**
     * URL of a publicly-accessible image (png, jpeg, jpg, gif, or svg). This image will be copied to our storage location.
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'logo_image_url'?: string | null;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'logo_image_height_px'?: number | null;
    /**
     * Logo backgrond color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'logo_background_color'?: string | null;
    /**
     * Button color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'button_color'?: string | null;
}
/**
 * Definition of the webpage style
 * @export
 * @interface ListCampaigns200ResponseCampaignsInnerWebpageStyle
 */
export interface ListCampaigns200ResponseCampaignsInnerWebpageStyle {
    /**
     * Headline for the reward page
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'headline'?: string | null;
    /**
     * Message for the reward page
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'message'?: string;
    /**
     * URL of a publicly-accessible image (png, jpeg, jpg, gif, or svg). This image will be copied to our storage location.
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'logo_image_url'?: string | null;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'logo_image_height_px'?: number | null;
    /**
     * Logo backgrond color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'logo_background_color'?: string | null;
    /**
     * Backgrond color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'background_color'?: string | null;
}
/**
 * 
 * @export
 * @interface ListFields200Response
 */
export interface ListFields200Response {
    /**
     * 
     * @type {Array<ListFields200ResponseFieldsInner>}
     * @memberof ListFields200Response
     */
    'fields'?: Array<ListFields200ResponseFieldsInner>;
}
/**
 * 
 * @export
 * @interface ListFields200ResponseFieldsInner
 */
export interface ListFields200ResponseFieldsInner {
    /**
     * 
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'id'?: string;
    /**
     * Label of the field
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'label'?: string;
    /**
     * Type of the values of the field
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'data_type'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ListFields200ResponseFieldsInner
     */
    'data'?: { [key: string]: any; };
    /**
     * Is this field required (true) or optional (false)
     * @type {boolean}
     * @memberof ListFields200ResponseFieldsInner
     */
    'required'?: boolean;
    /**
     * Type of objects this field gets associated with
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'scope'?: string;
}
/**
 * 
 * @export
 * @interface ListForexResponse
 */
export interface ListForexResponse {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ListForexResponse
     */
    'forex': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface ListFraudReviews200Response
 */
export interface ListFraudReviews200Response {
    /**
     * 
     * @type {Array<ListFraudReviews200ResponseFraudReviewsInner>}
     * @memberof ListFraudReviews200Response
     */
    'fraud_reviews': Array<ListFraudReviews200ResponseFraudReviewsInner>;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface ListFraudReviews200ResponseFraudReviewsInner
 */
export interface ListFraudReviews200ResponseFraudReviewsInner {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released. 
     * @type {string}
     * @memberof ListFraudReviews200ResponseFraudReviewsInner
     */
    'status'?: ListFraudReviews200ResponseFraudReviewsInnerStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email` 
     * @type {Array<string>}
     * @memberof ListFraudReviews200ResponseFraudReviewsInner
     */
    'reasons'?: Array<ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof ListFraudReviews200ResponseFraudReviewsInner
     */
    'reward'?: ListRewards200ResponseRewardsInner;
}

export const ListFraudReviews200ResponseFraudReviewsInnerStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
} as const;

export type ListFraudReviews200ResponseFraudReviewsInnerStatusEnum = typeof ListFraudReviews200ResponseFraudReviewsInnerStatusEnum[keyof typeof ListFraudReviews200ResponseFraudReviewsInnerStatusEnum];
export const ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
} as const;

export type ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum = typeof ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum[keyof typeof ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum];

/**
 * 
 * @export
 * @interface ListFraudRules200Response
 */
export interface ListFraudRules200Response {
    /**
     * 
     * @type {Array<ListFraudRules200ResponseFraudRulesInner>}
     * @memberof ListFraudRules200Response
     */
    'fraud_rules': Array<ListFraudRules200ResponseFraudRulesInner>;
}
/**
 * An active fraud rule
 * @export
 * @interface ListFraudRules200ResponseFraudRulesInner
 */
export interface ListFraudRules200ResponseFraudRulesInner {
    /**
     * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list 
     * @type {string}
     * @memberof ListFraudRules200ResponseFraudRulesInner
     */
    'rule_type'?: ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum;
    /**
     * The configuration associated with the rule. The properties allowed depend on the type of rule. This property is only present for rules that require configuration. 
     * @type {object}
     * @memberof ListFraudRules200ResponseFraudRulesInner
     */
    'config'?: object | null;
}

export const ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
} as const;

export type ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum = typeof ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum[keyof typeof ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum];

/**
 * 
 * @export
 * @interface ListFundingSources200Response
 */
export interface ListFundingSources200Response {
    /**
     * 
     * @type {Array<ListFundingSources200ResponseFundingSourcesInner>}
     * @memberof ListFundingSources200Response
     */
    'funding_sources': Array<ListFundingSources200ResponseFundingSourcesInner>;
}
/**
 * 
 * @export
 * @interface ListFundingSources200ResponseFundingSourcesInner
 */
export interface ListFundingSources200ResponseFundingSourcesInner {
    /**
     * 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'id': string;
    /**
     * You can pay for rewards using different payment methods on Tremendous:  <table>   <thead>     <tr>       <th>Payment Method</th>       <th>Description</th>       </tr>   </thead>   <tbody>     <tr>       <td><code>balance</code></td>       <td>Pre-funded balance in your Tremendous account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>bank_account</code></td>       <td>Bank account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>credit_card</code></td>       <td>Credit card to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>invoice</code></td>       <td>Send rewards to recipients and pay by invoice.</td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'method': ListFundingSources200ResponseFundingSourcesInnerMethodEnum;
    /**
     * **Only available when `method` is set to `invoice`.** 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'type'?: ListFundingSources200ResponseFundingSourcesInnerTypeEnum;
    /**
     * 
     * @type {ListFundingSources200ResponseFundingSourcesInnerMeta}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'meta': ListFundingSources200ResponseFundingSourcesInnerMeta;
}

export const ListFundingSources200ResponseFundingSourcesInnerMethodEnum = {
    Balance: 'balance',
    BankAccount: 'bank_account',
    CreditCard: 'credit_card',
    Invoice: 'invoice'
} as const;

export type ListFundingSources200ResponseFundingSourcesInnerMethodEnum = typeof ListFundingSources200ResponseFundingSourcesInnerMethodEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerMethodEnum];
export const ListFundingSources200ResponseFundingSourcesInnerTypeEnum = {
    Commercial: 'COMMERCIAL',
    ProForma: 'PRO_FORMA',
    PrefundingOnly: 'PREFUNDING_ONLY'
} as const;

export type ListFundingSources200ResponseFundingSourcesInnerTypeEnum = typeof ListFundingSources200ResponseFundingSourcesInnerTypeEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListFundingSources200ResponseFundingSourcesInnerMeta
 */
export interface ListFundingSources200ResponseFundingSourcesInnerMeta {
    /**
     * **Only available when `method` is set to `balance`.**  Available amount for this funding source (in Cents USD) 
     * @type {number}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'available_cents'?: number;
    /**
     * **Only available when `method` is set to `balance`.**  Funds that are already registered on your Tremendous account but which have not yet been deposited in your account (e.g. unpaid invoices) (in Cents USD). 
     * @type {number}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'pending_cents'?: number;
    /**
     * **Only available when `method` is set to `bank_account` or `credit_card`.**  Name of the holder of the bank account or credit_card 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'accountholder_name'?: string;
    /**
     * **Only available when `method` is set to `bank_account`.**  Is this a checking or savings account 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'account_type'?: ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum;
    /**
     * **Only available when `method` is set to `bank_account`.**  Name of the bank 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'bank_name'?: string | null;
    /**
     * **Only available when `method` is set to `bank_account`.**  Last 4 digits of the account number 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'account_number_mask'?: string;
    /**
     * **Only available when `method` is set to `bank_account`.**  Last 4 digits of the routing number 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'account_routing_mask'?: string;
    /**
     * **Only available when `method` is set to `bank_account`.**  Can refunds be deposited to this bank account 
     * @type {boolean}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'refundable'?: boolean;
    /**
     * **Only available when `method` is set to `credit_card`.**  Network of the credit card 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'network'?: ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum;
    /**
     * **Only available when `method` is set to `credit_card`.**  Last 4 digits of the credit card number 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'last4'?: string;
    /**
     * **Only available when `method` is set to `credit_card`.**  Is this credit card expired 
     * @type {boolean}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'expired'?: boolean;
    /**
     * **Only available when `method` is set to `bank_account` or `credit_card`.**  Point in time when the last order failed using this bank account or credit card as a funding source. 
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'last_payment_failed_at'?: string | null;
}

export const ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum = typeof ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum];
export const ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum = {
    MasterCard: 'MasterCard',
    Amex: 'Amex',
    Jcb: 'JCB',
    DinersClub: 'Diner\'s Club',
    Visa: 'visa',
    Discover: 'discover',
    Laser: 'laser',
    Elo: 'elo',
    Maestro: 'maestro',
    Solo: 'solo'
} as const;

export type ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum = typeof ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum];

/**
 * 
 * @export
 * @interface ListInvoices200Response
 */
export interface ListInvoices200Response {
    /**
     * 
     * @type {Array<ListInvoices200ResponseInvoicesInner>}
     * @memberof ListInvoices200Response
     */
    'invoices': Array<ListInvoices200ResponseInvoicesInner>;
    /**
     * The total number of invoices across all pages
     * @type {number}
     * @memberof ListInvoices200Response
     */
    'total_count': number;
}
/**
 * Invoices are instruments to fund your Tremendous account\'s balance.  Invoices can be created by your organization programatically. Once we receive your payment, the invoice is marked as `PAID` and we add the respective funds to your account\'s balance. 
 * @export
 * @interface ListInvoices200ResponseInvoicesInner
 */
export interface ListInvoices200ResponseInvoicesInner {
    /**
     * The invoice number
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'id': string;
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'amount': number;
    /**
     * Status of this invoice  <table>   <thead>     <tr>       <th>Status</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>DELETED</code></td>       <td>Invoice has been deleted by your organization</td>     </tr>     <tr>       <td><code>PAID</code></td>       <td>Invoice has been paid by your organization</td>     </tr>     <tr>       <td><code>OPEN</code></td>       <td>Invoice has been created by your organization but has not been paid, yet</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'status': ListInvoices200ResponseInvoicesInnerStatusEnum;
    /**
     * List of orders related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'orders'?: Array<string>;
    /**
     * List of rewards related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'rewards'?: Array<string>;
    /**
     * Timestamp of when the invoice has been created. 
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'created_at': string;
    /**
     * Timestamp of when the invoice has been paid. 
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'paid_at': string | null;
}

export const ListInvoices200ResponseInvoicesInnerStatusEnum = {
    Deleted: 'DELETED',
    Paid: 'PAID',
    Open: 'OPEN',
    MarkedAsPaid: 'MARKED_AS_PAID'
} as const;

export type ListInvoices200ResponseInvoicesInnerStatusEnum = typeof ListInvoices200ResponseInvoicesInnerStatusEnum[keyof typeof ListInvoices200ResponseInvoicesInnerStatusEnum];

/**
 * 
 * @export
 * @interface ListMembers200Response
 */
export interface ListMembers200Response {
    /**
     * 
     * @type {Array<ListMembers200ResponseMembersInner>}
     * @memberof ListMembers200Response
     */
    'members': Array<ListMembers200ResponseMembersInner>;
}
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more. 
 * @export
 * @interface ListMembers200ResponseMembersInner
 */
export interface ListMembers200ResponseMembersInner {
    /**
     * 
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization. 
     * @type {boolean}
     * @memberof ListMembers200ResponseMembersInner
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization. 
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`. 
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'status': ListMembers200ResponseMembersInnerStatusEnum;
    /**
     * Timestamp when this member was created.  The `created_at` timestamp is **NOT** returned when retrieving a member (but is part of the response when listing or creating members). 
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'created_at'?: string;
    /**
     * Timestamp when this member most recently logged into the dashboard of the organization associated with this API key. 
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'last_login_at'?: string | null;
}

export const ListMembers200ResponseMembersInnerStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
} as const;

export type ListMembers200ResponseMembersInnerStatusEnum = typeof ListMembers200ResponseMembersInnerStatusEnum[keyof typeof ListMembers200ResponseMembersInnerStatusEnum];

/**
 * 
 * @export
 * @interface ListOrders200Response
 */
export interface ListOrders200Response {
    /**
     * 
     * @type {Array<ListOrders200ResponseOrdersInner>}
     * @memberof ListOrders200Response
     */
    'orders': Array<ListOrders200ResponseOrdersInner>;
    /**
     * The total number of orders across all pages
     * @type {number}
     * @memberof ListOrders200Response
     */
    'total_count': number;
}
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface ListOrders200ResponseOrdersInner
 */
export interface ListOrders200ResponseOrdersInner {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'status': ListOrders200ResponseOrdersInnerStatusEnum;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'channel'?: ListOrders200ResponseOrdersInnerChannelEnum;
    /**
     * 
     * @type {ListOrders200ResponseOrdersInnerPayment}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'payment'?: ListOrders200ResponseOrdersInnerPayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'invoice_id'?: string;
    /**
     * 
     * @type {Array<ListRewards200ResponseRewardsInner>}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'rewards'?: Array<ListRewards200ResponseRewardsInner>;
}

export const ListOrders200ResponseOrdersInnerStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
} as const;

export type ListOrders200ResponseOrdersInnerStatusEnum = typeof ListOrders200ResponseOrdersInnerStatusEnum[keyof typeof ListOrders200ResponseOrdersInnerStatusEnum];
export const ListOrders200ResponseOrdersInnerChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type ListOrders200ResponseOrdersInnerChannelEnum = typeof ListOrders200ResponseOrdersInnerChannelEnum[keyof typeof ListOrders200ResponseOrdersInnerChannelEnum];

/**
 * Cost breakdown of the order (cost of rewards + fees). Cost and fees are always denominated in USD, independent from the currency of the ordered rewards. Note that this property will only appear for processed orders (`status` is `EXECUTED`).
 * @export
 * @interface ListOrders200ResponseOrdersInnerPayment
 */
export interface ListOrders200ResponseOrdersInnerPayment {
    /**
     * Total price of the order before fees (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'subtotal'?: number;
    /**
     * Total price of the order including fees (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'total'?: number;
    /**
     * Fees for the order (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'fees'?: number;
    /**
     * 
     * @type {ListOrders200ResponseOrdersInnerPaymentRefund}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'refund'?: ListOrders200ResponseOrdersInnerPaymentRefund;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'channel'?: ListOrders200ResponseOrdersInnerPaymentChannelEnum;
}

export const ListOrders200ResponseOrdersInnerPaymentChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type ListOrders200ResponseOrdersInnerPaymentChannelEnum = typeof ListOrders200ResponseOrdersInnerPaymentChannelEnum[keyof typeof ListOrders200ResponseOrdersInnerPaymentChannelEnum];

/**
 * Breakdown of the order refunds (total amount in USD, independent from the currency of the ordered rewards). Note that this property will only appear for canceled orders or orders with canceled rewards. 
 * @export
 * @interface ListOrders200ResponseOrdersInnerPaymentRefund
 */
export interface ListOrders200ResponseOrdersInnerPaymentRefund {
    /**
     * Total amount of the order refunds (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPaymentRefund
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ListOrganizations200Response
 */
export interface ListOrganizations200Response {
    /**
     * 
     * @type {Array<ListOrganizations200ResponseOrganizationsInner>}
     * @memberof ListOrganizations200Response
     */
    'organizations'?: Array<ListOrganizations200ResponseOrganizationsInner>;
}
/**
 * Organizations are a way to separate different parts of your business within the same Tremendous account. Your root Tremendous account is an organization itself and can have multiple sub-organizations.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  Each organizations can have it\'s own API key. 
 * @export
 * @interface ListOrganizations200ResponseOrganizationsInner
 */
export interface ListOrganizations200ResponseOrganizationsInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'id'?: string;
    /**
     * Name of the organization
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'website': string;
    /**
     * Status of the organization. Organizations need to be approved to be able to use them to send out rewards.
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'status'?: ListOrganizations200ResponseOrganizationsInnerStatusEnum;
    /**
     * Timestamp of when the organization has been created.  *This field is only returned when creating an organization.* It is not returned anymore when retrieving or listing organizations. 
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'created_at'?: string;
}

export const ListOrganizations200ResponseOrganizationsInnerStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type ListOrganizations200ResponseOrganizationsInnerStatusEnum = typeof ListOrganizations200ResponseOrganizationsInnerStatusEnum[keyof typeof ListOrganizations200ResponseOrganizationsInnerStatusEnum];

/**
 * 
 * @export
 * @interface ListProductsResponse
 */
export interface ListProductsResponse {
    /**
     * 
     * @type {Array<ListProductsResponseProductsInner>}
     * @memberof ListProductsResponse
     */
    'products': Array<ListProductsResponseProductsInner>;
}
/**
 * A product represents one way to payout a reward to it\'s recipient. Think:  * Amazon.com gift card (ID: `OKMHM2X2OHYV`) * Donations to Save the Children (ID: `ESRNAD533W5A`) * Virtual Visa debit card (ID: `Q24BD9EZ332JT`)  each of which is one specific product on Tremendous.  > 📘 All available products > > See this [list](https://www.tremendous.com/catalog)  Products can be limited in their availability to recipients by  * geography (field `countries`) * currency (field `currencies`) * amount of the reward (field `skus`)   * e.g. adidas gift cards accept any amount between 5 and 200 USD.  See the description of each respective parameter for further details. 
 * @export
 * @interface ListProductsResponseProductsInner
 */
export interface ListProductsResponseProductsInner {
    /**
     * 
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'id': string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'name': string;
    /**
     * Detailed description of the product. Mostly used for products with a `category` of `charities`.
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'description': string;
    /**
     * The category of this product  <table>   <thead>     <tr>       <th>Category</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>ach</code></td>       <td>Bank transfer to the recipient</td>     </tr>     <tr>       <td><code>charity</code></td>       <td>Donations to a charity</td>     </tr>     <tr>       <td><code>merchant_card</code></td>       <td>A gift card for a certain merchant (e.g. Amazon)</td>     </tr>     <tr>       <td><code>paypal</code></td>       <td>Payout via PayPal</td>     </tr>     <tr>       <td><code>venmo</code></td>       <td>Payout via Venmo</td>     </tr>     <tr>       <td><code>visa_card</code></td>       <td>Payout in form of a Visa debit card</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'category': ListProductsResponseProductsInnerCategoryEnum;
    /**
     * Legal disclosures for this product. Can be in HTML format.
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'disclosure': string;
    /**
     * Products may are restricted in their usage based on the amount of the reward. The `skus` array defines bands of denominations in which this product may be used for payouts. 
     * @type {Array<ListProductsResponseProductsInnerSkusInner>}
     * @memberof ListProductsResponseProductsInner
     */
    'skus'?: Array<ListProductsResponseProductsInnerSkusInner>;
    /**
     * Available currencies for this product
     * @type {Array<string>}
     * @memberof ListProductsResponseProductsInner
     */
    'currency_codes': Array<ListProductsResponseProductsInnerCurrencyCodesEnum>;
    /**
     * List of countries in which this product is available to recipients.
     * @type {Array<ListProductsResponseProductsInnerCountriesInner>}
     * @memberof ListProductsResponseProductsInner
     */
    'countries': Array<ListProductsResponseProductsInnerCountriesInner>;
    /**
     * List of product images associated with this product (e.g. logos or images of the gift cards)
     * @type {Array<ListProductsResponseProductsInnerImagesInner>}
     * @memberof ListProductsResponseProductsInner
     */
    'images': Array<ListProductsResponseProductsInnerImagesInner>;
}

export const ListProductsResponseProductsInnerCategoryEnum = {
    Ach: 'ach',
    Charity: 'charity',
    MerchantCard: 'merchant_card',
    Paypal: 'paypal',
    Venmo: 'venmo',
    VisaCard: 'visa_card'
} as const;

export type ListProductsResponseProductsInnerCategoryEnum = typeof ListProductsResponseProductsInnerCategoryEnum[keyof typeof ListProductsResponseProductsInnerCategoryEnum];
export const ListProductsResponseProductsInnerCurrencyCodesEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
} as const;

export type ListProductsResponseProductsInnerCurrencyCodesEnum = typeof ListProductsResponseProductsInnerCurrencyCodesEnum[keyof typeof ListProductsResponseProductsInnerCurrencyCodesEnum];

/**
 * 
 * @export
 * @interface ListProductsResponseProductsInnerCountriesInner
 */
export interface ListProductsResponseProductsInnerCountriesInner {
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof ListProductsResponseProductsInnerCountriesInner
     */
    'abbr': string;
}
/**
 * 
 * @export
 * @interface ListProductsResponseProductsInnerImagesInner
 */
export interface ListProductsResponseProductsInnerImagesInner {
    /**
     * URL to this image
     * @type {string}
     * @memberof ListProductsResponseProductsInnerImagesInner
     */
    'src': string;
    /**
     * Type of image
     * @type {string}
     * @memberof ListProductsResponseProductsInnerImagesInner
     */
    'type': ListProductsResponseProductsInnerImagesInnerTypeEnum;
}

export const ListProductsResponseProductsInnerImagesInnerTypeEnum = {
    Card: 'card',
    Logo: 'logo'
} as const;

export type ListProductsResponseProductsInnerImagesInnerTypeEnum = typeof ListProductsResponseProductsInnerImagesInnerTypeEnum[keyof typeof ListProductsResponseProductsInnerImagesInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListProductsResponseProductsInnerSkusInner
 */
export interface ListProductsResponseProductsInnerSkusInner {
    /**
     * Minimal denomination that this product supports (in the product\'s currency)
     * @type {number}
     * @memberof ListProductsResponseProductsInnerSkusInner
     */
    'min': number;
    /**
     * Maximum denomination that this product supports (in the product\'s currency)
     * @type {number}
     * @memberof ListProductsResponseProductsInnerSkusInner
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface ListRewards200Response
 */
export interface ListRewards200Response {
    /**
     * 
     * @type {Array<ListRewards200ResponseRewardsInner>}
     * @memberof ListRewards200Response
     */
    'rewards'?: Array<ListRewards200ResponseRewardsInner>;
    /**
     * The total number of rewards across all pages
     * @type {number}
     * @memberof ListRewards200Response
     */
    'total_count'?: number;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface ListRewards200ResponseRewardsInner
 */
export interface ListRewards200ResponseRewardsInner {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'created_at'?: string;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<ListRewards200ResponseRewardsInnerCustomFieldsInner>}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'custom_fields'?: Array<ListRewards200ResponseRewardsInnerCustomFieldsInner>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerDelivery}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'delivery'?: ListRewards200ResponseRewardsInnerDelivery;
}
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface ListRewards200ResponseRewardsInnerCustomFieldsInner
 */
export interface ListRewards200ResponseRewardsInnerCustomFieldsInner {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerCustomFieldsInner
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerCustomFieldsInner
     */
    'value'?: string | null;
    /**
     * Label of the custom field
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerCustomFieldsInner
     */
    'label'?: string;
}
/**
 * Details on how the reward is delivered to the recipient. 
 * @export
 * @interface ListRewards200ResponseRewardsInnerDelivery
 */
export interface ListRewards200ResponseRewardsInnerDelivery {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerDelivery
     */
    'method': ListRewards200ResponseRewardsInnerDeliveryMethodEnum;
    /**
     * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled. 
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerDelivery
     */
    'status': ListRewards200ResponseRewardsInnerDeliveryStatusEnum;
}

export const ListRewards200ResponseRewardsInnerDeliveryMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
} as const;

export type ListRewards200ResponseRewardsInnerDeliveryMethodEnum = typeof ListRewards200ResponseRewardsInnerDeliveryMethodEnum[keyof typeof ListRewards200ResponseRewardsInnerDeliveryMethodEnum];
export const ListRewards200ResponseRewardsInnerDeliveryStatusEnum = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
} as const;

export type ListRewards200ResponseRewardsInnerDeliveryStatusEnum = typeof ListRewards200ResponseRewardsInnerDeliveryStatusEnum[keyof typeof ListRewards200ResponseRewardsInnerDeliveryStatusEnum];

/**
 * Details of the recipient of the reward
 * @export
 * @interface ListRewards200ResponseRewardsInnerRecipient
 */
export interface ListRewards200ResponseRewardsInnerRecipient {
    /**
     * Name of the recipient
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerRecipient
     */
    'name'?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerRecipient
     */
    'email'?: string;
    /**
     * Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerRecipient
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface ListRewards200ResponseRewardsInnerValue
 */
export interface ListRewards200ResponseRewardsInnerValue {
    /**
     * Amount of the reward
     * @type {number}
     * @memberof ListRewards200ResponseRewardsInnerValue
     */
    'denomination': number;
    /**
     * Currency of the reward
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerValue
     */
    'currency_code'?: ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum;
}

export const ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
} as const;

export type ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum = typeof ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum[keyof typeof ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum];

/**
 * 
 * @export
 * @interface ListRewards401Response
 */
export interface ListRewards401Response {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof ListRewards401Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * 
 * @export
 * @interface ListRewards401ResponseErrors
 */
export interface ListRewards401ResponseErrors {
    /**
     * Error message
     * @type {string}
     * @memberof ListRewards401ResponseErrors
     */
    'message'?: string;
    /**
     * Mirrors the request parameters structure, filled only with the (nested) properties that caused an error.
     * @type {object}
     * @memberof ListRewards401ResponseErrors
     */
    'payload'?: object;
}
/**
 * 
 * @export
 * @interface ListRewards429Response
 */
export interface ListRewards429Response {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof ListRewards429Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * 
 * @export
 * @interface ListRoles200Response
 */
export interface ListRoles200Response {
    /**
     * 
     * @type {Array<ListRoles200ResponseRolesInner>}
     * @memberof ListRoles200Response
     */
    'roles': Array<ListRoles200ResponseRolesInner>;
}
/**
 * Each organization member is assigned a role that defines the permissions they have within the organization. 
 * @export
 * @interface ListRoles200ResponseRolesInner
 */
export interface ListRoles200ResponseRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseRolesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseRolesInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseRolesInner
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ListWebhookEvents200Response
 */
export interface ListWebhookEvents200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListWebhookEvents200Response
     */
    'events'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ListWebhooks200Response
 */
export interface ListWebhooks200Response {
    /**
     * 
     * @type {Array<ListWebhooks200ResponseWebhooksInner>}
     * @memberof ListWebhooks200Response
     */
    'webhooks'?: Array<ListWebhooks200ResponseWebhooksInner>;
}
/**
 * 
 * @export
 * @interface ListWebhooks200ResponseWebhooksInner
 */
export interface ListWebhooks200ResponseWebhooksInner {
    /**
     * 
     * @type {string}
     * @memberof ListWebhooks200ResponseWebhooksInner
     */
    'id'?: string;
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof ListWebhooks200ResponseWebhooksInner
     */
    'url': string | null;
    /**
     * Private key for the webhook
     * @type {string}
     * @memberof ListWebhooks200ResponseWebhooksInner
     */
    'private_key'?: string;
}
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more. 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof Member
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization. 
     * @type {boolean}
     * @memberof Member
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization. 
     * @type {string}
     * @memberof Member
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`. 
     * @type {string}
     * @memberof Member
     */
    'status': MemberStatusEnum;
    /**
     * Timestamp when this member was created.  The `created_at` timestamp is **NOT** returned when retrieving a member (but is part of the response when listing or creating members). 
     * @type {string}
     * @memberof Member
     */
    'created_at'?: string;
    /**
     * Timestamp when this member most recently logged into the dashboard of the organization associated with this API key. 
     * @type {string}
     * @memberof Member
     */
    'last_login_at'?: string | null;
}

export const MemberStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
} as const;

export type MemberStatusEnum = typeof MemberStatusEnum[keyof typeof MemberStatusEnum];

/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more. 
 * @export
 * @interface MemberBase
 */
export interface MemberBase {
    /**
     * 
     * @type {string}
     * @memberof MemberBase
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof MemberBase
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof MemberBase
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization. 
     * @type {boolean}
     * @memberof MemberBase
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization. 
     * @type {string}
     * @memberof MemberBase
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`. 
     * @type {string}
     * @memberof MemberBase
     */
    'status': MemberBaseStatusEnum;
}

export const MemberBaseStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
} as const;

export type MemberBaseStatusEnum = typeof MemberBaseStatusEnum[keyof typeof MemberBaseStatusEnum];

/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more. 
 * @export
 * @interface MemberWithEvents
 */
export interface MemberWithEvents {
    /**
     * 
     * @type {string}
     * @memberof MemberWithEvents
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof MemberWithEvents
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof MemberWithEvents
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization. 
     * @type {boolean}
     * @memberof MemberWithEvents
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization. 
     * @type {string}
     * @memberof MemberWithEvents
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`. 
     * @type {string}
     * @memberof MemberWithEvents
     */
    'status': MemberWithEventsStatusEnum;
    /**
     * List of events related to the member.
     * @type {Array<GetMember200ResponseMemberEventsInner>}
     * @memberof MemberWithEvents
     */
    'events'?: Array<GetMember200ResponseMemberEventsInner>;
}

export const MemberWithEventsStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
} as const;

export type MemberWithEventsStatusEnum = typeof MemberWithEventsStatusEnum[keyof typeof MemberWithEventsStatusEnum];

/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more. 
 * @export
 * @interface MemberWithoutEvents
 */
export interface MemberWithoutEvents {
    /**
     * 
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization. 
     * @type {boolean}
     * @memberof MemberWithoutEvents
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization. 
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`. 
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'status': MemberWithoutEventsStatusEnum;
    /**
     * Timestamp when this member was created.  The `created_at` timestamp is **NOT** returned when retrieving a member (but is part of the response when listing or creating members). 
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'created_at'?: string;
    /**
     * Timestamp when this member most recently logged into the dashboard of the organization associated with this API key. 
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'last_login_at'?: string | null;
}

export const MemberWithoutEventsStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
} as const;

export type MemberWithoutEventsStatusEnum = typeof MemberWithoutEventsStatusEnum[keyof typeof MemberWithoutEventsStatusEnum];

/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof Order
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof Order
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof Order
     */
    'status': OrderStatusEnum;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof Order
     */
    'channel'?: OrderChannelEnum;
    /**
     * 
     * @type {OrderBasePayment}
     * @memberof Order
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof Order
     */
    'invoice_id'?: string;
    /**
     * 
     * @type {Array<OrderWithoutLinkRewardsInner>}
     * @memberof Order
     */
    'rewards'?: Array<OrderWithoutLinkRewardsInner>;
}

export const OrderStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];
export const OrderChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type OrderChannelEnum = typeof OrderChannelEnum[keyof typeof OrderChannelEnum];

/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface OrderBase
 */
export interface OrderBase {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof OrderBase
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof OrderBase
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof OrderBase
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof OrderBase
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof OrderBase
     */
    'status': OrderBaseStatusEnum;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof OrderBase
     */
    'channel'?: OrderBaseChannelEnum;
    /**
     * 
     * @type {OrderBasePayment}
     * @memberof OrderBase
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof OrderBase
     */
    'invoice_id'?: string;
}

export const OrderBaseStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
} as const;

export type OrderBaseStatusEnum = typeof OrderBaseStatusEnum[keyof typeof OrderBaseStatusEnum];
export const OrderBaseChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type OrderBaseChannelEnum = typeof OrderBaseChannelEnum[keyof typeof OrderBaseChannelEnum];

/**
 * Cost breakdown of the order (cost of rewards + fees). Cost and fees are always denominated in USD, independent from the currency of the ordered rewards. Note that this property will only appear for processed orders (`status` is `EXECUTED`).
 * @export
 * @interface OrderBasePayment
 */
export interface OrderBasePayment {
    /**
     * Total price of the order before fees (in USD)
     * @type {number}
     * @memberof OrderBasePayment
     */
    'subtotal'?: number;
    /**
     * Total price of the order including fees (in USD)
     * @type {number}
     * @memberof OrderBasePayment
     */
    'total'?: number;
    /**
     * Fees for the order (in USD)
     * @type {number}
     * @memberof OrderBasePayment
     */
    'fees'?: number;
    /**
     * 
     * @type {PaymentDetailsRefund}
     * @memberof OrderBasePayment
     */
    'refund'?: PaymentDetailsRefund;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof OrderBasePayment
     */
    'channel'?: OrderBasePaymentChannelEnum;
}

export const OrderBasePaymentChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type OrderBasePaymentChannelEnum = typeof OrderBasePaymentChannelEnum[keyof typeof OrderBasePaymentChannelEnum];

/**
 * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table> 
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface OrderWithoutLink
 */
export interface OrderWithoutLink {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'status': OrderWithoutLinkStatusEnum;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'channel'?: OrderWithoutLinkChannelEnum;
    /**
     * 
     * @type {OrderBasePayment}
     * @memberof OrderWithoutLink
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'invoice_id'?: string;
    /**
     * 
     * @type {Array<OrderWithoutLinkRewardsInner>}
     * @memberof OrderWithoutLink
     */
    'rewards'?: Array<OrderWithoutLinkRewardsInner>;
}

export const OrderWithoutLinkStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
} as const;

export type OrderWithoutLinkStatusEnum = typeof OrderWithoutLinkStatusEnum[keyof typeof OrderWithoutLinkStatusEnum];
export const OrderWithoutLinkChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type OrderWithoutLinkChannelEnum = typeof OrderWithoutLinkChannelEnum[keyof typeof OrderWithoutLinkChannelEnum];

/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface OrderWithoutLinkRewardsInner
 */
export interface OrderWithoutLinkRewardsInner {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * 
     * @type {RewardWithoutLinkDelivery}
     * @memberof OrderWithoutLinkRewardsInner
     */
    'delivery'?: RewardWithoutLinkDelivery;
}
/**
 * Organizations are a way to separate different parts of your business within the same Tremendous account. Your root Tremendous account is an organization itself and can have multiple sub-organizations.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  Each organizations can have it\'s own API key. 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * Name of the organization
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof Organization
     */
    'website': string;
    /**
     * Status of the organization. Organizations need to be approved to be able to use them to send out rewards.
     * @type {string}
     * @memberof Organization
     */
    'status'?: OrganizationStatusEnum;
    /**
     * Timestamp of when the organization has been created.  *This field is only returned when creating an organization.* It is not returned anymore when retrieving or listing organizations. 
     * @type {string}
     * @memberof Organization
     */
    'created_at'?: string;
}

export const OrganizationStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type OrganizationStatusEnum = typeof OrganizationStatusEnum[keyof typeof OrganizationStatusEnum];

/**
 * 
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
    /**
     * Total price of the order before fees (in USD)
     * @type {number}
     * @memberof PaymentDetails
     */
    'subtotal'?: number;
    /**
     * Total price of the order including fees (in USD)
     * @type {number}
     * @memberof PaymentDetails
     */
    'total'?: number;
    /**
     * Fees for the order (in USD)
     * @type {number}
     * @memberof PaymentDetails
     */
    'fees'?: number;
    /**
     * 
     * @type {PaymentDetailsRefund}
     * @memberof PaymentDetails
     */
    'refund'?: PaymentDetailsRefund;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof PaymentDetails
     */
    'channel'?: PaymentDetailsChannelEnum;
}

export const PaymentDetailsChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type PaymentDetailsChannelEnum = typeof PaymentDetailsChannelEnum[keyof typeof PaymentDetailsChannelEnum];

/**
 * Breakdown of the order refunds (total amount in USD, independent from the currency of the ordered rewards). Note that this property will only appear for canceled orders or orders with canceled rewards. 
 * @export
 * @interface PaymentDetailsRefund
 */
export interface PaymentDetailsRefund {
    /**
     * Total amount of the order refunds (in USD)
     * @type {number}
     * @memberof PaymentDetailsRefund
     */
    'total': number;
}
/**
 * A product represents one way to payout a reward to it\'s recipient. Think:  * Amazon.com gift card (ID: `OKMHM2X2OHYV`) * Donations to Save the Children (ID: `ESRNAD533W5A`) * Virtual Visa debit card (ID: `Q24BD9EZ332JT`)  each of which is one specific product on Tremendous.  > 📘 All available products > > See this [list](https://www.tremendous.com/catalog)  Products can be limited in their availability to recipients by  * geography (field `countries`) * currency (field `currencies`) * amount of the reward (field `skus`)   * e.g. adidas gift cards accept any amount between 5 and 200 USD.  See the description of each respective parameter for further details. 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * Name of the product
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * Detailed description of the product. Mostly used for products with a `category` of `charities`.
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * The category of this product  <table>   <thead>     <tr>       <th>Category</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>ach</code></td>       <td>Bank transfer to the recipient</td>     </tr>     <tr>       <td><code>charity</code></td>       <td>Donations to a charity</td>     </tr>     <tr>       <td><code>merchant_card</code></td>       <td>A gift card for a certain merchant (e.g. Amazon)</td>     </tr>     <tr>       <td><code>paypal</code></td>       <td>Payout via PayPal</td>     </tr>     <tr>       <td><code>venmo</code></td>       <td>Payout via Venmo</td>     </tr>     <tr>       <td><code>visa_card</code></td>       <td>Payout in form of a Visa debit card</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof Product
     */
    'category': ProductCategoryEnum;
    /**
     * Legal disclosures for this product. Can be in HTML format.
     * @type {string}
     * @memberof Product
     */
    'disclosure': string;
    /**
     * Products may are restricted in their usage based on the amount of the reward. The `skus` array defines bands of denominations in which this product may be used for payouts. 
     * @type {Array<ListProductsResponseProductsInnerSkusInner>}
     * @memberof Product
     */
    'skus'?: Array<ListProductsResponseProductsInnerSkusInner>;
    /**
     * Available currencies for this product
     * @type {Array<string>}
     * @memberof Product
     */
    'currency_codes': Array<ProductCurrencyCodesEnum>;
    /**
     * List of countries in which this product is available to recipients.
     * @type {Array<ListProductsResponseProductsInnerCountriesInner>}
     * @memberof Product
     */
    'countries': Array<ListProductsResponseProductsInnerCountriesInner>;
    /**
     * List of product images associated with this product (e.g. logos or images of the gift cards)
     * @type {Array<ListProductsResponseProductsInnerImagesInner>}
     * @memberof Product
     */
    'images': Array<ListProductsResponseProductsInnerImagesInner>;
}

export const ProductCategoryEnum = {
    Ach: 'ach',
    Charity: 'charity',
    MerchantCard: 'merchant_card',
    Paypal: 'paypal',
    Venmo: 'venmo',
    VisaCard: 'visa_card'
} as const;

export type ProductCategoryEnum = typeof ProductCategoryEnum[keyof typeof ProductCategoryEnum];
export const ProductCurrencyCodesEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
} as const;

export type ProductCurrencyCodesEnum = typeof ProductCurrencyCodesEnum[keyof typeof ProductCurrencyCodesEnum];

/**
 * To authenticate your requests using asymmetric key pairs (e.g., for signing embed requests), you need to share your public key with us. The public key resource allows you to manage your active public keys and track their last usage. 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'id'?: string;
    /**
     * Your public key, PEM encoded
     * @type {string}
     * @memberof PublicKey
     */
    'pem'?: string;
    /**
     * The last time your public key was used to sign a request
     * @type {string}
     * @memberof PublicKey
     */
    'last_used_at'?: string | null;
}
/**
 * Details of the recipient of the reward
 * @export
 * @interface Recipient
 */
export interface Recipient {
    /**
     * Name of the recipient
     * @type {string}
     * @memberof Recipient
     */
    'name'?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof Recipient
     */
    'email'?: string;
    /**
     * Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof Recipient
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface RefundDetails
 */
export interface RefundDetails {
    /**
     * Total amount of the order refunds (in USD)
     * @type {number}
     * @memberof RefundDetails
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ResendReward422Response
 */
export interface ResendReward422Response {
    /**
     * 
     * @type {ListRewards401ResponseErrors}
     * @memberof ResendReward422Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * Flag rewards redeemed in these countries.
 * @export
 * @interface ReviewCountry
 */
export interface ReviewCountry {
    /**
     * When type is `whitelist`, it flags any countries that *are not* present in the list. When type is `blacklist`, it flags any countries that *are* present in the list. 
     * @type {string}
     * @memberof ReviewCountry
     */
    'type': ReviewCountryTypeEnum;
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof ReviewCountry
     */
    'countries': Array<string>;
}

export const ReviewCountryTypeEnum = {
    Whitelist: 'whitelist',
    Blacklist: 'blacklist'
} as const;

export type ReviewCountryTypeEnum = typeof ReviewCountryTypeEnum[keyof typeof ReviewCountryTypeEnum];

/**
 * List of countries where a matching redemption will trigger a review.
 * @export
 * @interface ReviewCountry1
 */
export interface ReviewCountry1 {
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof ReviewCountry1
     */
    'countries': Array<string>;
}
/**
 * Flag rewards with an email or domain matching this list.
 * @export
 * @interface ReviewEmail
 */
export interface ReviewEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof ReviewEmail
     */
    'emails'?: Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof ReviewEmail
     */
    'domains'?: Array<string>;
}
/**
 * The list of emails and/or domains where a matching redemption will trigger a review. At least one email or domain is required.
 * @export
 * @interface ReviewEmail1
 */
export interface ReviewEmail1 {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof ReviewEmail1
     */
    'emails'?: Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof ReviewEmail1
     */
    'domains'?: Array<string>;
}
/**
 * Flag rewards redeemed by an IP matching this list.
 * @export
 * @interface ReviewIp
 */
export interface ReviewIp {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof ReviewIp
     */
    'ips': Array<string>;
}
/**
 * List of IP addresses and/or IP ranges where a matching redemption will trigger a review.
 * @export
 * @interface ReviewIp1
 */
export interface ReviewIp1 {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof ReviewIp1
     */
    'ips': Array<string>;
}
/**
 * If a recipient, device, or IP redeems more than this dollar value of rewards, flag for review.
 * @export
 * @interface ReviewRedeemedRewardsAmount
 */
export interface ReviewRedeemedRewardsAmount {
    /**
     * The total amount in USD of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof ReviewRedeemedRewardsAmount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof ReviewRedeemedRewardsAmount
     */
    'period': ReviewRedeemedRewardsAmountPeriodEnum;
}

export const ReviewRedeemedRewardsAmountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
} as const;

export type ReviewRedeemedRewardsAmountPeriodEnum = typeof ReviewRedeemedRewardsAmountPeriodEnum[keyof typeof ReviewRedeemedRewardsAmountPeriodEnum];

/**
 * If a recipient, device, or IP redeems more than this number of rewards, flag for review.
 * @export
 * @interface ReviewRedeemedRewardsCount
 */
export interface ReviewRedeemedRewardsCount {
    /**
     * The number of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof ReviewRedeemedRewardsCount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof ReviewRedeemedRewardsCount
     */
    'period': ReviewRedeemedRewardsCountPeriodEnum;
}

export const ReviewRedeemedRewardsCountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
} as const;

export type ReviewRedeemedRewardsCountPeriodEnum = typeof ReviewRedeemedRewardsCountPeriodEnum[keyof typeof ReviewRedeemedRewardsCountPeriodEnum];

/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof Reward
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof Reward
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof Reward
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof Reward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof Reward
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof Reward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof Reward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof Reward
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof Reward
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * 
     * @type {RewardWithoutLinkDelivery}
     * @memberof Reward
     */
    'delivery'?: RewardWithoutLinkDelivery;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface RewardBase
 */
export interface RewardBase {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardBase
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof RewardBase
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof RewardBase
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof RewardBase
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof RewardBase
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof RewardBase
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof RewardBase
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof RewardBase
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof RewardBase
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
}
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface RewardBaseCustomFieldsInner
 */
export interface RewardBaseCustomFieldsInner {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof RewardBaseCustomFieldsInner
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof RewardBaseCustomFieldsInner
     */
    'value'?: string | null;
    /**
     * Label of the custom field
     * @type {string}
     * @memberof RewardBaseCustomFieldsInner
     */
    'label'?: string;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface RewardForOrderCreate
 */
export interface RewardForOrderCreate {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof RewardForOrderCreate
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof RewardForOrderCreate
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof RewardForOrderCreate
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof RewardForOrderCreate
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * Set this to translate the redemption experience for this reward. Pass a 2-letter [ISO-639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the desired language. Defaults to `en`. 
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'language'?: string;
    /**
     * 
     * @type {SingleRewardOrder1RewardDelivery}
     * @memberof RewardForOrderCreate
     */
    'delivery'?: SingleRewardOrder1RewardDelivery;
}
/**
 * The redemption link for a reward.
 * @export
 * @interface RewardLink
 */
export interface RewardLink {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardLink
     */
    'id'?: string;
    /**
     * Link to redeem the reward at. You need to deliver this link to the recipient. 
     * @type {string}
     * @memberof RewardLink
     */
    'link'?: string;
}
/**
 * The redemption token for a reward.
 * @export
 * @interface RewardToken
 */
export interface RewardToken {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardToken
     */
    'id'?: string;
    /**
     * The token to redeem the reward. 
     * @type {string}
     * @memberof RewardToken
     */
    'token'?: string;
    /**
     * Date the token expires
     * @type {string}
     * @memberof RewardToken
     */
    'expires_at'?: string;
}
/**
 * 
 * @export
 * @interface RewardValue
 */
export interface RewardValue {
    /**
     * Amount of the reward
     * @type {number}
     * @memberof RewardValue
     */
    'denomination': number;
    /**
     * Currency of the reward
     * @type {string}
     * @memberof RewardValue
     */
    'currency_code'?: RewardValueCurrencyCodeEnum;
}

export const RewardValueCurrencyCodeEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
} as const;

export type RewardValueCurrencyCodeEnum = typeof RewardValueCurrencyCodeEnum[keyof typeof RewardValueCurrencyCodeEnum];

/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface RewardWithoutLink
 */
export interface RewardWithoutLink {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof RewardWithoutLink
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof RewardWithoutLink
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof RewardWithoutLink
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof RewardWithoutLink
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * 
     * @type {RewardWithoutLinkDelivery}
     * @memberof RewardWithoutLink
     */
    'delivery'?: RewardWithoutLinkDelivery;
}
/**
 * Details on how the reward is delivered to the recipient. 
 * @export
 * @interface RewardWithoutLinkDelivery
 */
export interface RewardWithoutLinkDelivery {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof RewardWithoutLinkDelivery
     */
    'method': RewardWithoutLinkDeliveryMethodEnum;
    /**
     * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled. 
     * @type {string}
     * @memberof RewardWithoutLinkDelivery
     */
    'status': RewardWithoutLinkDeliveryStatusEnum;
}

export const RewardWithoutLinkDeliveryMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
} as const;

export type RewardWithoutLinkDeliveryMethodEnum = typeof RewardWithoutLinkDeliveryMethodEnum[keyof typeof RewardWithoutLinkDeliveryMethodEnum];
export const RewardWithoutLinkDeliveryStatusEnum = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
} as const;

export type RewardWithoutLinkDeliveryStatusEnum = typeof RewardWithoutLinkDeliveryStatusEnum[keyof typeof RewardWithoutLinkDeliveryStatusEnum];

/**
 * Each organization member is assigned a role that defines the permissions they have within the organization. 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SimulateWebhookRequest
 */
export interface SimulateWebhookRequest {
    /**
     * The event to test. See the [List events endpoint reference](/reference/get_webhooks-id-events) for all available events.
     * @type {string}
     * @memberof SimulateWebhookRequest
     */
    'event': string;
}
/**
 * An order that contains a single reward. The reward is sent to a single recipient. 
 * @export
 * @interface SingleRewardOrder
 */
export interface SingleRewardOrder {
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof SingleRewardOrder
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {SingleRewardOrder1Payment}
     * @memberof SingleRewardOrder
     */
    'payment'?: SingleRewardOrder1Payment;
    /**
     * 
     * @type {SingleRewardOrderReward}
     * @memberof SingleRewardOrder
     */
    'reward': SingleRewardOrderReward;
}
/**
 * An order that contains a single reward. The reward is sent to a single recipient. 
 * @export
 * @interface SingleRewardOrder1
 */
export interface SingleRewardOrder1 {
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof SingleRewardOrder1
     */
    'external_id'?: string | null;
    /**
     * 
     * @type {SingleRewardOrder1Payment}
     * @memberof SingleRewardOrder1
     */
    'payment'?: SingleRewardOrder1Payment;
    /**
     * 
     * @type {SingleRewardOrder1Reward}
     * @memberof SingleRewardOrder1
     */
    'reward': SingleRewardOrder1Reward;
}
/**
 * 
 * @export
 * @interface SingleRewardOrder1Payment
 */
export interface SingleRewardOrder1Payment {
    /**
     * Tremendous ID of the funding source that will be used to pay for the order. Use `balance` to use your Tremendous\'s balance.
     * @type {string}
     * @memberof SingleRewardOrder1Payment
     */
    'funding_source_id': string;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface SingleRewardOrder1Reward
 */
export interface SingleRewardOrder1Reward {
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof SingleRewardOrder1Reward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof SingleRewardOrder1Reward
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof SingleRewardOrder1Reward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof SingleRewardOrder1Reward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof SingleRewardOrder1Reward
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<SingleRewardOrder1RewardCustomFieldsInner>}
     * @memberof SingleRewardOrder1Reward
     */
    'custom_fields'?: Array<SingleRewardOrder1RewardCustomFieldsInner>;
    /**
     * Set this to translate the redemption experience for this reward. Pass a 2-letter [ISO-639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the desired language. Defaults to `en`. 
     * @type {string}
     * @memberof SingleRewardOrder1Reward
     */
    'language'?: string;
    /**
     * 
     * @type {SingleRewardOrder1RewardDelivery}
     * @memberof SingleRewardOrder1Reward
     */
    'delivery'?: SingleRewardOrder1RewardDelivery;
}
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface SingleRewardOrder1RewardCustomFieldsInner
 */
export interface SingleRewardOrder1RewardCustomFieldsInner {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof SingleRewardOrder1RewardCustomFieldsInner
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof SingleRewardOrder1RewardCustomFieldsInner
     */
    'value'?: string | null;
}
/**
 * Details on how the reward is delivered to the recipient. 
 * @export
 * @interface SingleRewardOrder1RewardDelivery
 */
export interface SingleRewardOrder1RewardDelivery {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> 
     * @type {string}
     * @memberof SingleRewardOrder1RewardDelivery
     */
    'method'?: SingleRewardOrder1RewardDeliveryMethodEnum;
}

export const SingleRewardOrder1RewardDeliveryMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
} as const;

export type SingleRewardOrder1RewardDeliveryMethodEnum = typeof SingleRewardOrder1RewardDeliveryMethodEnum[keyof typeof SingleRewardOrder1RewardDeliveryMethodEnum];

/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified. 
 * @export
 * @interface SingleRewardOrderReward
 */
export interface SingleRewardOrderReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel. 
     * @type {Array<string>}
     * @memberof SingleRewardOrderReward
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof SingleRewardOrderReward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     * 
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof SingleRewardOrderReward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'deliver_at'?: string;
    /**
     * 
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof SingleRewardOrderReward
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * Set this to translate the redemption experience for this reward. Pass a 2-letter [ISO-639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the desired language. Defaults to `en`. 
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'language'?: string;
    /**
     * 
     * @type {SingleRewardOrder1RewardDelivery}
     * @memberof SingleRewardOrderReward
     */
    'delivery'?: SingleRewardOrder1RewardDelivery;
}
/**
 * 
 * @export
 * @interface SingleRewardOrderWithoutLink
 */
export interface SingleRewardOrderWithoutLink {
    /**
     * 
     * @type {SingleRewardOrderWithoutLinkOrder}
     * @memberof SingleRewardOrderWithoutLink
     */
    'order': SingleRewardOrderWithoutLinkOrder;
}
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface SingleRewardOrderWithoutLinkOrder
 */
export interface SingleRewardOrderWithoutLinkOrder {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only. 
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from. 
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table> 
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'status': SingleRewardOrderWithoutLinkOrderStatusEnum;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'channel'?: SingleRewardOrderWithoutLinkOrderChannelEnum;
    /**
     * 
     * @type {OrderBasePayment}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'invoice_id'?: string;
    /**
     * 
     * @type {Array<OrderWithoutLinkRewardsInner>}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'rewards'?: Array<OrderWithoutLinkRewardsInner>;
}

export const SingleRewardOrderWithoutLinkOrderStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
} as const;

export type SingleRewardOrderWithoutLinkOrderStatusEnum = typeof SingleRewardOrderWithoutLinkOrderStatusEnum[keyof typeof SingleRewardOrderWithoutLinkOrderStatusEnum];
export const SingleRewardOrderWithoutLinkOrderChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
} as const;

export type SingleRewardOrderWithoutLinkOrderChannelEnum = typeof SingleRewardOrderWithoutLinkOrderChannelEnum[keyof typeof SingleRewardOrderWithoutLinkOrderChannelEnum];

/**
 * 
 * @export
 * @interface TestPublicKey
 */
export interface TestPublicKey {
    /**
     * A JWT token encoded with RS256, signed using the RSA private key corresponding to your public key.
     * @type {string}
     * @memberof TestPublicKey
     */
    'jwt': string;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from. 
 * @export
 * @interface UpdateCampaign
 */
export interface UpdateCampaign {
    /**
     * 
     * @type {string}
     * @memberof UpdateCampaign
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof UpdateCampaign
     */
    'name'?: string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof UpdateCampaign
     */
    'description'?: string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign. 
     * @type {Array<string>}
     * @memberof UpdateCampaign
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof UpdateCampaign
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof UpdateCampaign
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from. 
 * @export
 * @interface UpdateCampaignRequest
 */
export interface UpdateCampaignRequest {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof UpdateCampaignRequest
     */
    'name'?: string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof UpdateCampaignRequest
     */
    'description'?: string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign. 
     * @type {Array<string>}
     * @memberof UpdateCampaignRequest
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof UpdateCampaignRequest
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     * 
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof UpdateCampaignRequest
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * 
 * @export
 * @interface UpdateFraudRuleList200Response
 */
export interface UpdateFraudRuleList200Response {
    /**
     * A description of the result
     * @type {string}
     * @memberof UpdateFraudRuleList200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateFraudRuleListRequest
 */
export interface UpdateFraudRuleListRequest {
    /**
     * * `add` - append the list to the same key of the current configuration * `remove` - remove the entries in the list from the same key of the current configuration 
     * @type {string}
     * @memberof UpdateFraudRuleListRequest
     */
    'operation': UpdateFraudRuleListRequestOperationEnum;
    /**
     * 
     * @type {UpdateFraudRuleListRequestConfig}
     * @memberof UpdateFraudRuleListRequest
     */
    'config': UpdateFraudRuleListRequestConfig;
}

export const UpdateFraudRuleListRequestOperationEnum = {
    Add: 'add',
    Remove: 'remove'
} as const;

export type UpdateFraudRuleListRequestOperationEnum = typeof UpdateFraudRuleListRequestOperationEnum[keyof typeof UpdateFraudRuleListRequestOperationEnum];

/**
 * The configuration associated with the rule. The properties allowed depend on the type of rule.
 * @export
 * @interface UpdateFraudRuleListRequestConfig
 */
export interface UpdateFraudRuleListRequestConfig {
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'countries': Array<string>;
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation. 
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'ips': Array<string>;
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'emails': Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'domains'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof Webhook
     */
    'url': string | null;
    /**
     * Private key for the webhook
     * @type {string}
     * @memberof Webhook
     */
    'private_key'?: string;
}
/**
 * 
 * @export
 * @interface WebhookPost
 */
export interface WebhookPost {
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof WebhookPost
     */
    'url': string;
}

/**
 * BalanceTransactionsApi - axios parameter creator
 * @export
 */
export const BalanceTransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch a list of all balance transactions on your account. 
         * @summary List balance transactions
         * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions: async (offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/balance_transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at[gte]'] = createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at[lte]'] = createdAtLte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceTransactionsApi - functional programming interface
 * @export
 */
export const BalanceTransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceTransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch a list of all balance transactions on your account. 
         * @summary List balance transactions
         * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBalanceTransactions(offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBalanceTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalanceTransactionsApi.listBalanceTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalanceTransactionsApi - factory interface
 * @export
 */
export const BalanceTransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceTransactionsApiFp(configuration)
    return {
        /**
         * Fetch a list of all balance transactions on your account. 
         * @summary List balance transactions
         * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions(offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListBalanceTransactions200Response> {
            return localVarFp.listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceTransactionsApi - object-oriented interface
 * @export
 * @class BalanceTransactionsApi
 * @extends {BaseAPI}
 */
export class BalanceTransactionsApi extends BaseAPI {
    /**
     * Fetch a list of all balance transactions on your account. 
     * @summary List balance transactions
     * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionsApi
     */
    public listBalanceTransactions(offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: RawAxiosRequestConfig) {
        return BalanceTransactionsApiFp(this.configuration).listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (createCampaignRequest: CreateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCampaignRequest' is not null or undefined
            assertParamExists('createCampaign', 'createCampaignRequest', createCampaignRequest)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a campaign, identified by the given `id` in the URL 
         * @summary Retrieve campaign
         * @param {string} id ID of the campaign that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaign', 'id', id)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all campaigns created in your account 
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update campaign
         * @param {string} id ID of the campaign that should be updated
         * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: async (id: string, updateCampaignRequest: UpdateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCampaign', 'id', id)
            // verify required parameter 'updateCampaignRequest' is not null or undefined
            assertParamExists('updateCampaign', 'updateCampaignRequest', updateCampaignRequest)
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(createCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.createCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a campaign, identified by the given `id` in the URL 
         * @summary Retrieve campaign
         * @param {string} id ID of the campaign that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaign(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaign(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all campaigns created in your account 
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaigns(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCampaigns200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaigns(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.listCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update campaign
         * @param {string} id ID of the campaign that should be updated
         * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampaign(id: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampaign(id, updateCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.updateCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCampaign201Response> {
            return localVarFp.createCampaign(createCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a campaign, identified by the given `id` in the URL 
         * @summary Retrieve campaign
         * @param {string} id ID of the campaign that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateCampaign201Response> {
            return localVarFp.getCampaign(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all campaigns created in your account 
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns(options?: RawAxiosRequestConfig): AxiosPromise<ListCampaigns200Response> {
            return localVarFp.listCampaigns(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update campaign
         * @param {string} id ID of the campaign that should be updated
         * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign(id: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCampaign201Response> {
            return localVarFp.updateCampaign(id, updateCampaignRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * 
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).createCampaign(createCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a campaign, identified by the given `id` in the URL 
     * @summary Retrieve campaign
     * @param {string} id ID of the campaign that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getCampaign(id: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getCampaign(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all campaigns created in your account 
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public listCampaigns(options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).listCampaigns(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update campaign
     * @param {string} id ID of the campaign that should be updated
     * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public updateCampaign(id: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).updateCampaign(id, updateCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FieldsApi - axios parameter creator
 * @export
 */
export const FieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard. 
         * @summary List fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FieldsApi - functional programming interface
 * @export
 */
export const FieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard. 
         * @summary List fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFields(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFields(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FieldsApi.listFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FieldsApi - factory interface
 * @export
 */
export const FieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FieldsApiFp(configuration)
    return {
        /**
         * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard. 
         * @summary List fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(options?: RawAxiosRequestConfig): AxiosPromise<ListFields200Response> {
            return localVarFp.listFields(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export class FieldsApi extends BaseAPI {
    /**
     * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard. 
     * @summary List fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public listFields(options?: RawAxiosRequestConfig) {
        return FieldsApiFp(this.configuration).listFields(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ForexApi - axios parameter creator
 * @export
 */
export const ForexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of exchange rates 
         * @summary List exchange rates
         * @param {string} [base] Base currency code, default is USD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForex: async (base?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ForexApi - functional programming interface
 * @export
 */
export const ForexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ForexApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of exchange rates 
         * @summary List exchange rates
         * @param {string} [base] Base currency code, default is USD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForex(base?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListForexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForex(base, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ForexApi.listForex']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ForexApi - factory interface
 * @export
 */
export const ForexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ForexApiFp(configuration)
    return {
        /**
         * Retrieve a list of exchange rates 
         * @summary List exchange rates
         * @param {string} [base] Base currency code, default is USD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForex(base?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListForexResponse> {
            return localVarFp.listForex(base, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ForexApi - object-oriented interface
 * @export
 * @class ForexApi
 * @extends {BaseAPI}
 */
export class ForexApi extends BaseAPI {
    /**
     * Retrieve a list of exchange rates 
     * @summary List exchange rates
     * @param {string} [base] Base currency code, default is USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForexApi
     */
    public listForex(base?: string, options?: RawAxiosRequestConfig) {
        return ForexApiFp(this.configuration).listForex(base, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FraudReviewsApi - axios parameter creator
 * @export
 */
export const FraudReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded. 
         * @summary Block fraud review
         * @param {string} id The ID of the reward that should be blocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockFraudReview: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('blockFraudReview', 'id', id)
            const localVarPath = `/fraud_reviews/{id}/block`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc. 
         * @summary Retrieve single fraud review
         * @param {string} id The ID of the reward that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudReview: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFraudReview', 'id', id)
            const localVarPath = `/fraud_reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates. 
         * @summary List fraud reviews
         * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
         * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
         * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
         * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudReviews: async (offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fraud_reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at[gte]'] = createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at[lte]'] = createdAtLte;
            }

            if (redeemedAtGte !== undefined) {
                localVarQueryParameter['redeemed_at[gte]'] = redeemedAtGte;
            }

            if (redeemedAtLte !== undefined) {
                localVarQueryParameter['redeemed_at[lte]'] = redeemedAtLte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient. 
         * @summary Release fraud review
         * @param {string} id The ID of the reward that should be released.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFraudReview: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('releaseFraudReview', 'id', id)
            const localVarPath = `/fraud_reviews/{id}/release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FraudReviewsApi - functional programming interface
 * @export
 */
export const FraudReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FraudReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded. 
         * @summary Block fraud review
         * @param {string} id The ID of the reward that should be blocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFraudReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockFraudReview(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudReviewsApi.blockFraudReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc. 
         * @summary Retrieve single fraud review
         * @param {string} id The ID of the reward that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFraudReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFraudReview(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudReviewsApi.getFraudReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates. 
         * @summary List fraud reviews
         * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
         * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
         * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
         * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFraudReviews(offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFraudReviews200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudReviewsApi.listFraudReviews']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient. 
         * @summary Release fraud review
         * @param {string} id The ID of the reward that should be released.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releaseFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFraudReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.releaseFraudReview(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudReviewsApi.releaseFraudReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FraudReviewsApi - factory interface
 * @export
 */
export const FraudReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FraudReviewsApiFp(configuration)
    return {
        /**
         * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded. 
         * @summary Block fraud review
         * @param {string} id The ID of the reward that should be blocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockFraudReview(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFraudReview200Response> {
            return localVarFp.blockFraudReview(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc. 
         * @summary Retrieve single fraud review
         * @param {string} id The ID of the reward that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudReview(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFraudReview200Response> {
            return localVarFp.getFraudReview(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates. 
         * @summary List fraud reviews
         * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
         * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
         * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
         * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudReviews(offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListFraudReviews200Response> {
            return localVarFp.listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient. 
         * @summary Release fraud review
         * @param {string} id The ID of the reward that should be released.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFraudReview(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFraudReview200Response> {
            return localVarFp.releaseFraudReview(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FraudReviewsApi - object-oriented interface
 * @export
 * @class FraudReviewsApi
 * @extends {BaseAPI}
 */
export class FraudReviewsApi extends BaseAPI {
    /**
     * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded. 
     * @summary Block fraud review
     * @param {string} id The ID of the reward that should be blocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    public blockFraudReview(id: string, options?: RawAxiosRequestConfig) {
        return FraudReviewsApiFp(this.configuration).blockFraudReview(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc. 
     * @summary Retrieve single fraud review
     * @param {string} id The ID of the reward that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    public getFraudReview(id: string, options?: RawAxiosRequestConfig) {
        return FraudReviewsApiFp(this.configuration).getFraudReview(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates. 
     * @summary List fraud reviews
     * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
     * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
     * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
     * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    public listFraudReviews(offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: RawAxiosRequestConfig) {
        return FraudReviewsApiFp(this.configuration).listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient. 
     * @summary Release fraud review
     * @param {string} id The ID of the reward that should be released.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    public releaseFraudReview(id: string, options?: RawAxiosRequestConfig) {
        return FraudReviewsApiFp(this.configuration).releaseFraudReview(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListFraudReviewsStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
} as const;
export type ListFraudReviewsStatusEnum = typeof ListFraudReviewsStatusEnum[keyof typeof ListFraudReviewsStatusEnum];


/**
 * FraudRulesApi - axios parameter creator
 * @export
 */
export const FraudRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the rule of the type passed in the URL. 
         * @summary Delete fraud rule
         * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFraudRule: async (ruleType: DeleteFraudRuleRuleTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('deleteFraudRule', 'ruleType', ruleType)
            const localVarPath = `/fraud_rules/{rule_type}`
                .replace(`{${"rule_type"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten. 
         * @summary Configure fraud rule
         * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudRule: async (ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('fraudRule', 'ruleType', ruleType)
            const localVarPath = `/fraud_rules/{rule_type}`
                .replace(`{${"rule_type"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fraudRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List active fraud rules associated with the organization tied to your API key. 
         * @summary List fraud rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fraud_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ``` 
         * @summary Update fraud rule list
         * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
         * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFraudRuleList: async (ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('updateFraudRuleList', 'ruleType', ruleType)
            // verify required parameter 'updateFraudRuleListRequest' is not null or undefined
            assertParamExists('updateFraudRuleList', 'updateFraudRuleListRequest', updateFraudRuleListRequest)
            const localVarPath = `/fraud_rules/{rule_type}/update_list`
                .replace(`{${"rule_type"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFraudRuleListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FraudRulesApi - functional programming interface
 * @export
 */
export const FraudRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FraudRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the rule of the type passed in the URL. 
         * @summary Delete fraud rule
         * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFraudRule(ruleType: DeleteFraudRuleRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFraudRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFraudRule(ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudRulesApi.deleteFraudRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten. 
         * @summary Configure fraud rule
         * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fraudRule(ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudRule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fraudRule(ruleType, fraudRuleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudRulesApi.fraudRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List active fraud rules associated with the organization tied to your API key. 
         * @summary List fraud rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFraudRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFraudRules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFraudRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudRulesApi.listFraudRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ``` 
         * @summary Update fraud rule list
         * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
         * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFraudRuleList(ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateFraudRuleList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFraudRuleList(ruleType, updateFraudRuleListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FraudRulesApi.updateFraudRuleList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FraudRulesApi - factory interface
 * @export
 */
export const FraudRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FraudRulesApiFp(configuration)
    return {
        /**
         * Deletes the rule of the type passed in the URL. 
         * @summary Delete fraud rule
         * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFraudRule(ruleType: DeleteFraudRuleRuleTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeleteFraudRule200Response> {
            return localVarFp.deleteFraudRule(ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten. 
         * @summary Configure fraud rule
         * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudRule(ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<FraudRule200Response> {
            return localVarFp.fraudRule(ruleType, fraudRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List active fraud rules associated with the organization tied to your API key. 
         * @summary List fraud rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudRules(options?: RawAxiosRequestConfig): AxiosPromise<ListFraudRules200Response> {
            return localVarFp.listFraudRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ``` 
         * @summary Update fraud rule list
         * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
         * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFraudRuleList(ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateFraudRuleList200Response> {
            return localVarFp.updateFraudRuleList(ruleType, updateFraudRuleListRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FraudRulesApi - object-oriented interface
 * @export
 * @class FraudRulesApi
 * @extends {BaseAPI}
 */
export class FraudRulesApi extends BaseAPI {
    /**
     * Deletes the rule of the type passed in the URL. 
     * @summary Delete fraud rule
     * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    public deleteFraudRule(ruleType: DeleteFraudRuleRuleTypeEnum, options?: RawAxiosRequestConfig) {
        return FraudRulesApiFp(this.configuration).deleteFraudRule(ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten. 
     * @summary Configure fraud rule
     * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    public fraudRule(ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: RawAxiosRequestConfig) {
        return FraudRulesApiFp(this.configuration).fraudRule(ruleType, fraudRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List active fraud rules associated with the organization tied to your API key. 
     * @summary List fraud rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    public listFraudRules(options?: RawAxiosRequestConfig) {
        return FraudRulesApiFp(this.configuration).listFraudRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ``` 
     * @summary Update fraud rule list
     * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
     * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    public updateFraudRuleList(ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: RawAxiosRequestConfig) {
        return FraudRulesApiFp(this.configuration).updateFraudRuleList(ruleType, updateFraudRuleListRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteFraudRuleRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
} as const;
export type DeleteFraudRuleRuleTypeEnum = typeof DeleteFraudRuleRuleTypeEnum[keyof typeof DeleteFraudRuleRuleTypeEnum];
/**
 * @export
 */
export const FraudRuleRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
} as const;
export type FraudRuleRuleTypeEnum = typeof FraudRuleRuleTypeEnum[keyof typeof FraudRuleRuleTypeEnum];
/**
 * @export
 */
export const UpdateFraudRuleListRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
} as const;
export type UpdateFraudRuleListRuleTypeEnum = typeof UpdateFraudRuleListRuleTypeEnum[keyof typeof UpdateFraudRuleListRuleTypeEnum];


/**
 * FundingSourcesApi - axios parameter creator
 * @export
 */
export const FundingSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a funding source, identified by the given `id` in the URL 
         * @summary Retrieve funding source
         * @param {string} id ID of the funding source that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingSource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFundingSource', 'id', id)
            const localVarPath = `/funding_sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account. 
         * @summary List funding sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundingSources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/funding_sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundingSourcesApi - functional programming interface
 * @export
 */
export const FundingSourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FundingSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a funding source, identified by the given `id` in the URL 
         * @summary Retrieve funding source
         * @param {string} id ID of the funding source that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingSource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFundingSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingSource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account. 
         * @summary List funding sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFundingSources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFundingSources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFundingSources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.listFundingSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FundingSourcesApi - factory interface
 * @export
 */
export const FundingSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundingSourcesApiFp(configuration)
    return {
        /**
         * Retrieve a funding source, identified by the given `id` in the URL 
         * @summary Retrieve funding source
         * @param {string} id ID of the funding source that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingSource(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetFundingSource200Response> {
            return localVarFp.getFundingSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account. 
         * @summary List funding sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundingSources(options?: RawAxiosRequestConfig): AxiosPromise<ListFundingSources200Response> {
            return localVarFp.listFundingSources(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundingSourcesApi - object-oriented interface
 * @export
 * @class FundingSourcesApi
 * @extends {BaseAPI}
 */
export class FundingSourcesApi extends BaseAPI {
    /**
     * Retrieve a funding source, identified by the given `id` in the URL 
     * @summary Retrieve funding source
     * @param {string} id ID of the funding source that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingSource(id: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account. 
     * @summary List funding sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public listFundingSources(options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).listFundingSources(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>  
         * @summary Create invoice
         * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: async (createInvoiceRequest: CreateInvoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInvoiceRequest' is not null or undefined
            assertParamExists('createInvoice', 'createInvoiceRequest', createInvoiceRequest)
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvoiceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an invoice. This has no further consequences but is a rather cosmetic operation. 
         * @summary Delete invoice
         * @param {string} id ID of the invoice that should be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoices: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoices', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a CSV version for an invoice listing the associated rewards and orders 
         * @summary Retrieve invoice as CSV
         * @param {string} id ID of the Invoice for that the CSV should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoiceCsv: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadInvoiceCsv', 'id', id)
            const localVarPath = `/invoices/{id}/csv`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a PDF version for an invoice 
         * @summary Retrieve invoice as PDF
         * @param {string} id ID of the Invoice for that the PDF should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoicePdf: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadInvoicePdf', 'id', id)
            const localVarPath = `/invoices/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits. 
         * @summary Retrieve invoice
         * @param {string} id ID of the invoice that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices. 
         * @summary List invoices
         * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>  
         * @summary Create invoice
         * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoice(createInvoiceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.createInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes an invoice. This has no further consequences but is a rather cosmetic operation. 
         * @summary Delete invoice
         * @param {string} id ID of the invoice that should be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoices(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoices(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.deleteInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a CSV version for an invoice listing the associated rewards and orders 
         * @summary Retrieve invoice as CSV
         * @param {string} id ID of the Invoice for that the CSV should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadInvoiceCsv(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadInvoiceCsv(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.downloadInvoiceCsv']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a PDF version for an invoice 
         * @summary Retrieve invoice as PDF
         * @param {string} id ID of the Invoice for that the PDF should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadInvoicePdf(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadInvoicePdf(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.downloadInvoicePdf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits. 
         * @summary Retrieve invoice
         * @param {string} id ID of the invoice that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.getInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices. 
         * @summary List invoices
         * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvoices(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvoices(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.listInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>  
         * @summary Create invoice
         * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateInvoice200Response> {
            return localVarFp.createInvoice(createInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an invoice. This has no further consequences but is a rather cosmetic operation. 
         * @summary Delete invoice
         * @param {string} id ID of the invoice that should be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoices(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateInvoice200Response> {
            return localVarFp.deleteInvoices(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a CSV version for an invoice listing the associated rewards and orders 
         * @summary Retrieve invoice as CSV
         * @param {string} id ID of the Invoice for that the CSV should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoiceCsv(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadInvoiceCsv(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a PDF version for an invoice 
         * @summary Retrieve invoice as PDF
         * @param {string} id ID of the Invoice for that the PDF should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoicePdf(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadInvoicePdf(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits. 
         * @summary Retrieve invoice
         * @param {string} id ID of the invoice that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateInvoice200Response> {
            return localVarFp.getInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices. 
         * @summary List invoices
         * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListInvoices200Response> {
            return localVarFp.listInvoices(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>  
     * @summary Create invoice
     * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).createInvoice(createInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an invoice. This has no further consequences but is a rather cosmetic operation. 
     * @summary Delete invoice
     * @param {string} id ID of the invoice that should be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public deleteInvoices(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).deleteInvoices(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a CSV version for an invoice listing the associated rewards and orders 
     * @summary Retrieve invoice as CSV
     * @param {string} id ID of the Invoice for that the CSV should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public downloadInvoiceCsv(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).downloadInvoiceCsv(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a PDF version for an invoice 
     * @summary Retrieve invoice as PDF
     * @param {string} id ID of the Invoice for that the PDF should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public downloadInvoicePdf(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).downloadInvoicePdf(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits. 
     * @summary Retrieve invoice
     * @param {string} id ID of the invoice that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices. 
     * @summary List invoices
     * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public listInvoices(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).listInvoices(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead. 
         * @summary Create member
         * @param {CreateMemberRequest} createMemberRequest Member details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember: async (createMemberRequest: CreateMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMemberRequest' is not null or undefined
            assertParamExists('createMember', 'createMemberRequest', createMemberRequest)
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMemberRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve member
         * @param {string} id ID of the member to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMember', 'id', id)
            const localVarPath = `/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request. 
         * @summary List members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead. 
         * @summary Create member
         * @param {CreateMemberRequest} createMemberRequest Member details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMember(createMemberRequest: CreateMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMember200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMember(createMemberRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.createMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve member
         * @param {string} id ID of the member to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMember(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMember200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMember(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.getMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request. 
         * @summary List members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMembers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMembers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MembersApi.listMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead. 
         * @summary Create member
         * @param {CreateMemberRequest} createMemberRequest Member details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(createMemberRequest: CreateMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateMember200Response> {
            return localVarFp.createMember(createMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve member
         * @param {string} id ID of the member to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMember200Response> {
            return localVarFp.getMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request. 
         * @summary List members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(options?: RawAxiosRequestConfig): AxiosPromise<ListMembers200Response> {
            return localVarFp.listMembers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead. 
     * @summary Create member
     * @param {CreateMemberRequest} createMemberRequest Member details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public createMember(createMemberRequest: CreateMemberRequest, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).createMember(createMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve member
     * @param {string} id ID of the member to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public getMember(id: string, options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).getMember(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request. 
     * @summary List members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public listMembers(options?: RawAxiosRequestConfig) {
        return MembersApiFp(this.configuration).listMembers(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
         * @summary Approve order
         * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOrder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveOrder', 'id', id)
            const localVarPath = `/order_approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body. 
         * @summary Create order
         * @param {CreateOrderRequest} createOrderRequest Order to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (createOrderRequest: CreateOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('createOrder', 'createOrderRequest', createOrderRequest)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the order, identified by the given `id` in the URL 
         * @summary Retrieve order
         * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrder', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of orders 
         * @summary List orders
         * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
         * @param {string} [campaignId] Only return results with a matching campaign_id.
         * @param {string} [externalId] Only return results with a matching external_id.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (campaignId !== undefined) {
                localVarQueryParameter['campaign_id'] = campaignId;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at[gte]'] = createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at[lte]'] = createdAtLte;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
         * @summary Reject order
         * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectOrder', 'id', id)
            const localVarPath = `/order_approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
         * @summary Approve order
         * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.approveOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body. 
         * @summary Create order
         * @param {CreateOrderRequest} createOrderRequest Order to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(createOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the order, identified by the given `id` in the URL 
         * @summary Retrieve order
         * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of orders 
         * @summary List orders
         * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
         * @param {string} [campaignId] Only return results with a matching campaign_id.
         * @param {string} [externalId] Only return results with a matching external_id.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.listOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
         * @summary Reject order
         * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.rejectOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
         * @summary Approve order
         * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOrder(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrder200Response> {
            return localVarFp.approveOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body. 
         * @summary Create order
         * @param {CreateOrderRequest} createOrderRequest Order to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrder200Response> {
            return localVarFp.createOrder(createOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the order, identified by the given `id` in the URL 
         * @summary Retrieve order
         * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrder200Response> {
            return localVarFp.getOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of orders 
         * @summary List orders
         * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
         * @param {string} [campaignId] Only return results with a matching campaign_id.
         * @param {string} [externalId] Only return results with a matching external_id.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListOrders200Response> {
            return localVarFp.listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
         * @summary Reject order
         * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrder200Response> {
            return localVarFp.rejectOrder(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
     * @summary Approve order
     * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public approveOrder(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).approveOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body. 
     * @summary Create order
     * @param {CreateOrderRequest} createOrderRequest Order to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrder(createOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the order, identified by the given `id` in the URL 
     * @summary Retrieve order
     * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrder(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of orders 
     * @summary List orders
     * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
     * @param {string} [campaignId] Only return results with a matching campaign_id.
     * @param {string} [externalId] Only return results with a matching external_id.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public listOrders(offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard. 
     * @summary Reject order
     * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public rejectOrder(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).rejectOrder(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.** 
         * @summary Create API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/create_api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard. 
         * @summary Create organization
         * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationRequest: CreateOrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationRequest' is not null or undefined
            assertParamExists('createOrganization', 'createOrganizationRequest', createOrganizationRequest)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve organization
         * @param {string} id ID of the organization to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganization', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned list only includes the organization to which the API key belongs to, that is used for the request. 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.** 
         * @summary Create API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard. 
         * @summary Create organization
         * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrganization200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(createOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve organization
         * @param {string} id ID of the organization to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganization200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The returned list only includes the organization to which the API key belongs to, that is used for the request. 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.** 
         * @summary Create API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(options?: RawAxiosRequestConfig): AxiosPromise<CreateApiKey200Response> {
            return localVarFp.createApiKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard. 
         * @summary Create organization
         * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrganization200Response> {
            return localVarFp.createOrganization(createOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve organization
         * @param {string} id ID of the organization to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetOrganization200Response> {
            return localVarFp.getOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned list only includes the organization to which the API key belongs to, that is used for the request. 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: RawAxiosRequestConfig): AxiosPromise<ListOrganizations200Response> {
            return localVarFp.listOrganizations(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.** 
     * @summary Create API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createApiKey(options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createApiKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard. 
     * @summary Create organization
     * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrganization(createOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve organization
     * @param {string} id ID of the organization to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).getOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned list only includes the organization to which the API key belongs to, that is used for the request. 
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizations(options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a product, identified by the given `id` in the URL 
         * @summary Retrieve product
         * @param {string} id ID of the product that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of available products 
         * @summary List products
         * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
         * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (country?: string, currency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a product, identified by the given `id` in the URL 
         * @summary Retrieve product
         * @param {string} id ID of the product that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of available products 
         * @summary List products
         * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
         * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(country?: string, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(country, currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.listProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Retrieve a product, identified by the given `id` in the URL 
         * @summary Retrieve product
         * @param {string} id ID of the product that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetProductResponse> {
            return localVarFp.getProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of available products 
         * @summary List products
         * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
         * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(country?: string, currency?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListProductsResponse> {
            return localVarFp.listProducts(country, currency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Retrieve a product, identified by the given `id` in the URL 
     * @summary Retrieve product
     * @param {string} id ID of the product that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(id: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of available products 
     * @summary List products
     * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
     * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public listProducts(country?: string, currency?: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).listProducts(country, currency, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewardsApi - axios parameter creator
 * @export
 */
export const RewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a redemption link for the reward identified by the `id` in the URL 
         * @summary Generate a reward URL
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardLink: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generateRewardLink', 'id', id)
            const localVarPath = `/rewards/{id}/generate_link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours. 
         * @summary Generate a reward token
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardToken: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('generateRewardToken', 'id', id)
            const localVarPath = `/rewards/{id}/generate_embed_token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the reward, identified by the given `id` in the URL 
         * @summary Retrieve single reward
         * @param {string} id ID of the reward that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getReward', 'id', id)
            const localVarPath = `/rewards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all created rewards 
         * @summary List rewards
         * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards: async (offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a reward, identified by the given `id` in the URL, to its recipient. 
         * @summary Resend reward
         * @param {string} id ID of the reward that should be resent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReward: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendReward', 'id', id)
            const localVarPath = `/rewards/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardsApi - functional programming interface
 * @export
 */
export const RewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a redemption link for the reward identified by the `id` in the URL 
         * @summary Generate a reward URL
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRewardLink(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateRewardLink200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateRewardLink(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.generateRewardLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours. 
         * @summary Generate a reward token
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRewardToken(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateRewardToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateRewardToken(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.generateRewardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the reward, identified by the given `id` in the URL 
         * @summary Retrieve single reward
         * @param {string} id ID of the reward that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReward200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReward(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all created rewards 
         * @summary List rewards
         * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRewards(offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRewards(offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.listRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a reward, identified by the given `id` in the URL, to its recipient. 
         * @summary Resend reward
         * @param {string} id ID of the reward that should be resent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendReward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendReward(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.resendReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewardsApi - factory interface
 * @export
 */
export const RewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewardsApiFp(configuration)
    return {
        /**
         * Generate a redemption link for the reward identified by the `id` in the URL 
         * @summary Generate a reward URL
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardLink(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GenerateRewardLink200Response> {
            return localVarFp.generateRewardLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours. 
         * @summary Generate a reward token
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardToken(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GenerateRewardToken200Response> {
            return localVarFp.generateRewardToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the reward, identified by the given `id` in the URL 
         * @summary Retrieve single reward
         * @param {string} id ID of the reward that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetReward200Response> {
            return localVarFp.getReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all created rewards 
         * @summary List rewards
         * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards(offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListRewards200Response> {
            return localVarFp.listRewards(offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a reward, identified by the given `id` in the URL, to its recipient. 
         * @summary Resend reward
         * @param {string} id ID of the reward that should be resent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReward(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.resendReward(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardsApi - object-oriented interface
 * @export
 * @class RewardsApi
 * @extends {BaseAPI}
 */
export class RewardsApi extends BaseAPI {
    /**
     * Generate a redemption link for the reward identified by the `id` in the URL 
     * @summary Generate a reward URL
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public generateRewardLink(id: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).generateRewardLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours. 
     * @summary Generate a reward token
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public generateRewardToken(id: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).generateRewardToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the reward, identified by the given `id` in the URL 
     * @summary Retrieve single reward
     * @param {string} id ID of the reward that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getReward(id: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getReward(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all created rewards 
     * @summary List rewards
     * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public listRewards(offset?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).listRewards(offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a reward, identified by the given `id` in the URL, to its recipient. 
     * @summary Resend reward
     * @param {string} id ID of the reward that should be resent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public resendReward(id: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).resendReward(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all available roles in the organization.
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all available roles in the organization.
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRoles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * List all available roles in the organization.
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: RawAxiosRequestConfig): AxiosPromise<ListRoles200Response> {
            return localVarFp.listRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * List all available roles in the organization.
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>  
         * @summary Create webhook
         * @param {CreateWebhookRequest} createWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookRequest: CreateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookRequest' is not null or undefined
            assertParamExists('createWebhook', 'createWebhookRequest', createWebhookRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Delete webhook
         * @param {string} id ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Retrieve webhook
         * @param {string} id ID of the webhook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary List events
         * @param {string} id ID of the webhook to list the events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvents: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listWebhookEvents', 'id', id)
            const localVarPath = `/webhooks/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Test webhook
         * @param {string} id ID of the webhook to test
         * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateWebhook: async (id: string, simulateWebhookRequest: SimulateWebhookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simulateWebhook', 'id', id)
            // verify required parameter 'simulateWebhookRequest' is not null or undefined
            assertParamExists('simulateWebhook', 'simulateWebhookRequest', simulateWebhookRequest)
            const localVarPath = `/webhooks/{id}/simulate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerApiKey required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simulateWebhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>  
         * @summary Create webhook
         * @param {CreateWebhookRequest} createWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Delete webhook
         * @param {string} id ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Retrieve webhook
         * @param {string} id ID of the webhook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary List events
         * @param {string} id ID of the webhook to list the events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhookEvents(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhookEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhookEvents(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.listWebhookEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Test webhook
         * @param {string} id ID of the webhook to test
         * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateWebhook(id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateWebhook(id, simulateWebhookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.simulateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>  
         * @summary Create webhook
         * @param {CreateWebhookRequest} createWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhook200Response> {
            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Delete webhook
         * @param {string} id ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Retrieve webhook
         * @param {string} id ID of the webhook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateWebhook200Response> {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary List events
         * @param {string} id ID of the webhook to list the events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvents(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ListWebhookEvents200Response> {
            return localVarFp.listWebhookEvents(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<ListWebhooks200Response> {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
         * @summary Test webhook
         * @param {string} id ID of the webhook to test
         * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateWebhook(id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.simulateWebhook(id, simulateWebhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>  
     * @summary Create webhook
     * @param {CreateWebhookRequest} createWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
     * @summary Delete webhook
     * @param {string} id ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
     * @summary Retrieve webhook
     * @param {string} id ID of the webhook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
     * @summary List events
     * @param {string} id ID of the webhook to list the events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhookEvents(id: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhookEvents(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhooks(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1) 
     * @summary Test webhook
     * @param {string} id ID of the webhook to test
     * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public simulateWebhook(id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).simulateWebhook(id, simulateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



