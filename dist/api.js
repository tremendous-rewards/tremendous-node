"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * API Endpoints
 * Deliver monetary rewards and incentives to employees, customers, survey participants, and more through the Tremendous API. For organizational tasks, like managing your organization and it\'s members within Tremendous, please see the Tremendous Organizational API.
 *
 * The version of the OpenAPI document: 2
 * Contact: developers@tremendous.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemberWithEventsStatusEnum = exports.MemberBaseStatusEnum = exports.MemberStatusEnum = exports.ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum = exports.ListRewards200ResponseRewardsInnerDeliveryStatusEnum = exports.ListRewards200ResponseRewardsInnerDeliveryMethodEnum = exports.ListProductsResponseProductsInnerImagesInnerTypeEnum = exports.ListProductsResponseProductsInnerCurrencyCodesEnum = exports.ListProductsResponseProductsInnerCategoryEnum = exports.ListOrganizations200ResponseOrganizationsInnerStatusEnum = exports.ListOrders200ResponseOrdersInnerPaymentChannelEnum = exports.ListOrders200ResponseOrdersInnerStatusEnum = exports.ListMembers200ResponseMembersInnerStatusEnum = exports.ListInvoices200ResponseInvoicesInnerStatusEnum = exports.ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum = exports.ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum = exports.ListFundingSources200ResponseFundingSourcesInnerTypeEnum = exports.ListFundingSources200ResponseFundingSourcesInnerMethodEnum = exports.ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum = exports.ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum = exports.ListFraudReviews200ResponseFraudReviewsInnerStatusEnum = exports.InvoiceStatusEnum = exports.GetMember200ResponseMemberEventsInnerTypeEnum = exports.GetMember200ResponseMemberStatusEnum = exports.GetFraudReview200ResponseFraudReviewRedemptionMethodEnum = exports.GetFraudReview200ResponseFraudReviewReasonsEnum = exports.GetFraudReview200ResponseFraudReviewStatusEnum = exports.FundingSourceTypeEnum = exports.FundingSourceMethodEnum = exports.FraudRulesListItemRuleTypeEnum = exports.FraudRuleType = exports.FraudRuleRequestConfigPeriodEnum = exports.FraudRuleRequestConfigTypeEnum = exports.FraudReviewStatus = exports.FraudReviewRedemptionMethod = exports.FraudReviewReason = exports.FraudReviewListItemReasonsEnum = exports.FraudReviewListItemStatusEnum = exports.FraudReviewRedemptionMethodEnum = exports.FraudReviewReasonsEnum = exports.FraudReviewStatusEnum = exports.FraudConfigRedeemedRewardsCountPeriodEnum = exports.FraudConfigRedeemedRewardsAmountPeriodEnum = exports.FraudConfigCountryTypeEnum = exports.DeliveryStatus = exports.DeliveryMethod = exports.DeliveryDetailsStatusEnum = exports.DeliveryDetailsMethodEnum = exports.CurrencyCodes = exports.CreateOrganization200ResponseOrganizationStatusEnum = void 0;
exports.FundingSourcesApiFactory = exports.FundingSourcesApiFp = exports.FundingSourcesApiAxiosParamCreator = exports.UpdateFraudRuleListRuleTypeEnum = exports.FraudRuleRuleTypeEnum = exports.DeleteFraudRuleRuleTypeEnum = exports.FraudRulesApi = exports.FraudRulesApiFactory = exports.FraudRulesApiFp = exports.FraudRulesApiAxiosParamCreator = exports.ListFraudReviewsStatusEnum = exports.FraudReviewsApi = exports.FraudReviewsApiFactory = exports.FraudReviewsApiFp = exports.FraudReviewsApiAxiosParamCreator = exports.ForexApi = exports.ForexApiFactory = exports.ForexApiFp = exports.ForexApiAxiosParamCreator = exports.FieldsApi = exports.FieldsApiFactory = exports.FieldsApiFp = exports.FieldsApiAxiosParamCreator = exports.CampaignsApi = exports.CampaignsApiFactory = exports.CampaignsApiFp = exports.CampaignsApiAxiosParamCreator = exports.BalanceTransactionsApi = exports.BalanceTransactionsApiFactory = exports.BalanceTransactionsApiFp = exports.BalanceTransactionsApiAxiosParamCreator = exports.UpdateFraudRuleListRequestOperationEnum = exports.SingleRewardOrderWithoutLinkOrderStatusEnum = exports.SingleRewardOrder1RewardDeliveryMethodEnum = exports.RewardWithoutLinkDeliveryStatusEnum = exports.RewardWithoutLinkDeliveryMethodEnum = exports.RewardValueCurrencyCodeEnum = exports.ReviewRedeemedRewardsCountPeriodEnum = exports.ReviewRedeemedRewardsAmountPeriodEnum = exports.ReviewCountryTypeEnum = exports.ProductCurrencyCodesEnum = exports.ProductCategoryEnum = exports.PaymentDetailsChannelEnum = exports.OrganizationStatusEnum = exports.OrderWithoutLinkStatusEnum = exports.OrderStatus = exports.OrderBasePaymentChannelEnum = exports.OrderBaseStatusEnum = exports.OrderStatusEnum = exports.MemberWithoutEventsStatusEnum = void 0;
exports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiAxiosParamCreator = exports.RolesApi = exports.RolesApiFactory = exports.RolesApiFp = exports.RolesApiAxiosParamCreator = exports.RewardsApi = exports.RewardsApiFactory = exports.RewardsApiFp = exports.RewardsApiAxiosParamCreator = exports.PublicKeysApi = exports.PublicKeysApiFactory = exports.PublicKeysApiFp = exports.PublicKeysApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.OrganizationsApi = exports.OrganizationsApiFactory = exports.OrganizationsApiFp = exports.OrganizationsApiAxiosParamCreator = exports.OrdersApi = exports.OrdersApiFactory = exports.OrdersApiFp = exports.OrdersApiAxiosParamCreator = exports.MembersApi = exports.MembersApiFactory = exports.MembersApiFp = exports.MembersApiAxiosParamCreator = exports.InvoicesApi = exports.InvoicesApiFactory = exports.InvoicesApiFp = exports.InvoicesApiAxiosParamCreator = exports.FundingSourcesApi = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.CreateOrganization200ResponseOrganizationStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CurrencyCodes = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
};
exports.DeliveryDetailsMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
};
exports.DeliveryDetailsStatusEnum = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
};
/**
 * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table>
 * @export
 * @enum {string}
 */
exports.DeliveryMethod = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
};
/**
 * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled.
 * @export
 * @enum {string}
 */
exports.DeliveryStatus = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
};
exports.FraudConfigCountryTypeEnum = {
    Whitelist: 'whitelist',
    Blacklist: 'blacklist'
};
exports.FraudConfigRedeemedRewardsAmountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
};
exports.FraudConfigRedeemedRewardsCountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
};
exports.FraudReviewStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
};
exports.FraudReviewReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
};
exports.FraudReviewRedemptionMethodEnum = {
    Paypal: 'paypal',
    Bank: 'bank',
    MerchantCard: 'merchant card',
    VisaCard: 'visa card',
    Charity: 'charity',
    Venmo: 'venmo'
};
exports.FraudReviewListItemStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
};
exports.FraudReviewListItemReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FraudReviewReason = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.FraudReviewRedemptionMethod = {
    Paypal: 'paypal',
    Bank: 'bank',
    MerchantCard: 'merchant card',
    VisaCard: 'visa card',
    Charity: 'charity',
    Venmo: 'venmo'
};
/**
 * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released.
 * @export
 * @enum {string}
 */
exports.FraudReviewStatus = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
};
exports.FraudRuleRequestConfigTypeEnum = {
    Whitelist: 'whitelist',
    Blacklist: 'blacklist'
};
exports.FraudRuleRequestConfigPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
};
/**
 * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list
 * @export
 * @enum {string}
 */
exports.FraudRuleType = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
};
exports.FraudRulesListItemRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
};
exports.FundingSourceMethodEnum = {
    Balance: 'balance',
    BankAccount: 'bank_account',
    CreditCard: 'credit_card',
    Invoice: 'invoice'
};
exports.FundingSourceTypeEnum = {
    Commercial: 'COMMERCIAL',
    ProForma: 'PRO_FORMA',
    PrefundingOnly: 'PREFUNDING_ONLY'
};
exports.GetFraudReview200ResponseFraudReviewStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
};
exports.GetFraudReview200ResponseFraudReviewReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
};
exports.GetFraudReview200ResponseFraudReviewRedemptionMethodEnum = {
    Paypal: 'paypal',
    Bank: 'bank',
    MerchantCard: 'merchant card',
    VisaCard: 'visa card',
    Charity: 'charity',
    Venmo: 'venmo'
};
exports.GetMember200ResponseMemberStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
};
exports.GetMember200ResponseMemberEventsInnerTypeEnum = {
    Created: 'created',
    LastLogin: 'last_login'
};
exports.InvoiceStatusEnum = {
    Deleted: 'DELETED',
    Paid: 'PAID',
    Open: 'OPEN',
    MarkedAsPaid: 'MARKED_AS_PAID'
};
exports.ListFraudReviews200ResponseFraudReviewsInnerStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
};
exports.ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum = {
    DisallowedIp: 'Disallowed IP',
    DisallowedEmail: 'Disallowed email',
    DisallowedCountry: 'Disallowed country',
    OverRewardDollarLimit: 'Over reward dollar limit',
    OverRewardCountLimit: 'Over reward count limit',
    VpnDetected: 'VPN detected',
    DeviceRelatedToMultipleEmails: 'Device related to multiple emails',
    DeviceOrAccountRelatedToMultipleEmails: 'Device or account related to multiple emails',
    IpOnATremendousFraudList: 'IP on a Tremendous fraud list',
    BankAccountOnATremendousFraudList: 'Bank account on a Tremendous fraud list',
    FingerprintOnATremendousFraudList: 'Fingerprint on a Tremendous fraud list',
    EmailOnATremendousFraudList: 'Email on a Tremendous fraud list',
    PhoneOnATremendousFraudList: 'Phone on a Tremendous fraud list',
    IpRelatedToABlockedReward: 'IP related to a blocked reward',
    BankAccountRelatedToABlockedReward: 'Bank account related to a blocked reward',
    FingerprintRelatedToABlockedReward: 'Fingerprint related to a blocked reward',
    EmailRelatedToABlockedReward: 'Email related to a blocked reward',
    PhoneRelatedToABlockedReward: 'Phone related to a blocked reward',
    AllowedIp: 'Allowed IP',
    AllowedEmail: 'Allowed email'
};
exports.ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
};
exports.ListFundingSources200ResponseFundingSourcesInnerMethodEnum = {
    Balance: 'balance',
    BankAccount: 'bank_account',
    CreditCard: 'credit_card',
    Invoice: 'invoice'
};
exports.ListFundingSources200ResponseFundingSourcesInnerTypeEnum = {
    Commercial: 'COMMERCIAL',
    ProForma: 'PRO_FORMA',
    PrefundingOnly: 'PREFUNDING_ONLY'
};
exports.ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
};
exports.ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum = {
    MasterCard: 'MasterCard',
    Amex: 'Amex',
    Jcb: 'JCB',
    DinersClub: 'Diner\'s Club',
    Visa: 'visa',
    Discover: 'discover',
    Laser: 'laser',
    Elo: 'elo',
    Maestro: 'maestro',
    Solo: 'solo'
};
exports.ListInvoices200ResponseInvoicesInnerStatusEnum = {
    Deleted: 'DELETED',
    Paid: 'PAID',
    Open: 'OPEN',
    MarkedAsPaid: 'MARKED_AS_PAID'
};
exports.ListMembers200ResponseMembersInnerStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
};
exports.ListOrders200ResponseOrdersInnerStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
};
exports.ListOrders200ResponseOrdersInnerPaymentChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
};
exports.ListOrganizations200ResponseOrganizationsInnerStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
};
exports.ListProductsResponseProductsInnerCategoryEnum = {
    Ach: 'ach',
    Charity: 'charity',
    MerchantCard: 'merchant_card',
    Paypal: 'paypal',
    Venmo: 'venmo',
    VisaCard: 'visa_card'
};
exports.ListProductsResponseProductsInnerCurrencyCodesEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
};
exports.ListProductsResponseProductsInnerImagesInnerTypeEnum = {
    Card: 'card',
    Logo: 'logo'
};
exports.ListRewards200ResponseRewardsInnerDeliveryMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
};
exports.ListRewards200ResponseRewardsInnerDeliveryStatusEnum = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
};
exports.ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
};
exports.MemberStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
};
exports.MemberBaseStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
};
exports.MemberWithEventsStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
};
exports.MemberWithoutEventsStatusEnum = {
    Registered: 'REGISTERED',
    Invited: 'INVITED'
};
exports.OrderStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
};
exports.OrderBaseStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
};
exports.OrderBasePaymentChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
};
/**
 * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
 * @export
 * @enum {string}
 */
exports.OrderStatus = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
};
exports.OrderWithoutLinkStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
};
exports.OrganizationStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
};
exports.PaymentDetailsChannelEnum = {
    Ui: 'UI',
    Api: 'API',
    Embed: 'EMBED',
    Decipher: 'DECIPHER',
    Qualtrics: 'QUALTRICS',
    Typeform: 'TYPEFORM',
    SurveyMonkey: 'SURVEY MONKEY'
};
exports.ProductCategoryEnum = {
    Ach: 'ach',
    Charity: 'charity',
    MerchantCard: 'merchant_card',
    Paypal: 'paypal',
    Venmo: 'venmo',
    VisaCard: 'visa_card'
};
exports.ProductCurrencyCodesEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
};
exports.ReviewCountryTypeEnum = {
    Whitelist: 'whitelist',
    Blacklist: 'blacklist'
};
exports.ReviewRedeemedRewardsAmountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
};
exports.ReviewRedeemedRewardsCountPeriodEnum = {
    _7: '7',
    _30: '30',
    _90: '90',
    _120: '120',
    _365: '365',
    AllTime: 'all_time'
};
exports.RewardValueCurrencyCodeEnum = {
    Usd: 'USD',
    Cad: 'CAD',
    Eur: 'EUR',
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ars: 'ARS',
    Aud: 'AUD',
    Azn: 'AZN',
    Bam: 'BAM',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Eek: 'EEK',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ghs: 'GHS',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Khr: 'KHR',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kzt: 'KZT',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mop: 'MOP',
    Mur: 'MUR',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Sos: 'SOS',
    Syp: 'SYP',
    Thb: 'THB',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Xaf: 'XAF',
    Xof: 'XOF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmk: 'ZMK'
};
exports.RewardWithoutLinkDeliveryMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
};
exports.RewardWithoutLinkDeliveryStatusEnum = {
    Scheduled: 'SCHEDULED',
    Failed: 'FAILED',
    Succeeded: 'SUCCEEDED',
    Pending: 'PENDING'
};
exports.SingleRewardOrder1RewardDeliveryMethodEnum = {
    Email: 'EMAIL',
    Link: 'LINK',
    Phone: 'PHONE'
};
exports.SingleRewardOrderWithoutLinkOrderStatusEnum = {
    Canceled: 'CANCELED',
    Cart: 'CART',
    Executed: 'EXECUTED',
    Failed: 'FAILED',
    PendingApproval: 'PENDING APPROVAL',
    PendingInternalPaymentApproval: 'PENDING INTERNAL PAYMENT APPROVAL'
};
exports.UpdateFraudRuleListRequestOperationEnum = {
    Add: 'add',
    Remove: 'remove'
};
/**
 * BalanceTransactionsApi - axios parameter creator
 * @export
 */
const BalanceTransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch a list of all balance transactions on your account.
         * @summary List balance transactions
         * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions: (offset_1, limit_1, createdAtGte_1, createdAtLte_1, ...args_1) => __awaiter(this, [offset_1, limit_1, createdAtGte_1, createdAtLte_1, ...args_1], void 0, function* (offset, limit, createdAtGte, createdAtLte, options = {}) {
            const localVarPath = `/balance_transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at[gte]'] = createdAtGte;
            }
            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at[lte]'] = createdAtLte;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BalanceTransactionsApiAxiosParamCreator = BalanceTransactionsApiAxiosParamCreator;
/**
 * BalanceTransactionsApi - functional programming interface
 * @export
 */
const BalanceTransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BalanceTransactionsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch a list of all balance transactions on your account.
         * @summary List balance transactions
         * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['BalanceTransactionsApi.listBalanceTransactions']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.BalanceTransactionsApiFp = BalanceTransactionsApiFp;
/**
 * BalanceTransactionsApi - factory interface
 * @export
 */
const BalanceTransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BalanceTransactionsApiFp)(configuration);
    return {
        /**
         * Fetch a list of all balance transactions on your account.
         * @summary List balance transactions
         * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options) {
            return localVarFp.listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BalanceTransactionsApiFactory = BalanceTransactionsApiFactory;
/**
 * BalanceTransactionsApi - object-oriented interface
 * @export
 * @class BalanceTransactionsApi
 * @extends {BaseAPI}
 */
class BalanceTransactionsApi extends base_1.BaseAPI {
    /**
     * Fetch a list of all balance transactions on your account.
     * @summary List balance transactions
     * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionsApi
     */
    listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options) {
        return (0, exports.BalanceTransactionsApiFp)(this.configuration).listBalanceTransactions(offset, limit, createdAtGte, createdAtLte, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BalanceTransactionsApi = BalanceTransactionsApi;
/**
 * CampaignsApi - axios parameter creator
 * @export
 */
const CampaignsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: (createCampaignRequest_1, ...args_1) => __awaiter(this, [createCampaignRequest_1, ...args_1], void 0, function* (createCampaignRequest, options = {}) {
            // verify required parameter 'createCampaignRequest' is not null or undefined
            (0, common_1.assertParamExists)('createCampaign', 'createCampaignRequest', createCampaignRequest);
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCampaignRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a campaign, identified by the given `id` in the URL
         * @summary Retrieve campaign
         * @param {string} id ID of the campaign that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getCampaign', 'id', id);
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of all campaigns created in your account
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update campaign
         * @param {string} id ID of the campaign that should be updated
         * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign: (id_1, updateCampaignRequest_1, ...args_1) => __awaiter(this, [id_1, updateCampaignRequest_1, ...args_1], void 0, function* (id, updateCampaignRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateCampaign', 'id', id);
            // verify required parameter 'updateCampaignRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateCampaign', 'updateCampaignRequest', updateCampaignRequest);
            const localVarPath = `/campaigns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCampaignRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CampaignsApiAxiosParamCreator = CampaignsApiAxiosParamCreator;
/**
 * CampaignsApi - functional programming interface
 * @export
 */
const CampaignsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CampaignsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(createCampaignRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCampaign(createCampaignRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CampaignsApi.createCampaign']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a campaign, identified by the given `id` in the URL
         * @summary Retrieve campaign
         * @param {string} id ID of the campaign that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCampaign(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CampaignsApi.getCampaign']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of all campaigns created in your account
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCampaigns(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CampaignsApi.listCampaigns']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Update campaign
         * @param {string} id ID of the campaign that should be updated
         * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign(id, updateCampaignRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCampaign(id, updateCampaignRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['CampaignsApi.updateCampaign']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.CampaignsApiFp = CampaignsApiFp;
/**
 * CampaignsApi - factory interface
 * @export
 */
const CampaignsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CampaignsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(createCampaignRequest, options) {
            return localVarFp.createCampaign(createCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a campaign, identified by the given `id` in the URL
         * @summary Retrieve campaign
         * @param {string} id ID of the campaign that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaign(id, options) {
            return localVarFp.getCampaign(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all campaigns created in your account
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns(options) {
            return localVarFp.listCampaigns(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update campaign
         * @param {string} id ID of the campaign that should be updated
         * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampaign(id, updateCampaignRequest, options) {
            return localVarFp.updateCampaign(id, updateCampaignRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CampaignsApiFactory = CampaignsApiFactory;
/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
class CampaignsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    createCampaign(createCampaignRequest, options) {
        return (0, exports.CampaignsApiFp)(this.configuration).createCampaign(createCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a campaign, identified by the given `id` in the URL
     * @summary Retrieve campaign
     * @param {string} id ID of the campaign that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    getCampaign(id, options) {
        return (0, exports.CampaignsApiFp)(this.configuration).getCampaign(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of all campaigns created in your account
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    listCampaigns(options) {
        return (0, exports.CampaignsApiFp)(this.configuration).listCampaigns(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update campaign
     * @param {string} id ID of the campaign that should be updated
     * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    updateCampaign(id, updateCampaignRequest, options) {
        return (0, exports.CampaignsApiFp)(this.configuration).updateCampaign(id, updateCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CampaignsApi = CampaignsApi;
/**
 * FieldsApi - axios parameter creator
 * @export
 */
const FieldsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
         * @summary List fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FieldsApiAxiosParamCreator = FieldsApiAxiosParamCreator;
/**
 * FieldsApi - functional programming interface
 * @export
 */
const FieldsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FieldsApiAxiosParamCreator)(configuration);
    return {
        /**
         * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
         * @summary List fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFields(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FieldsApi.listFields']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FieldsApiFp = FieldsApiFp;
/**
 * FieldsApi - factory interface
 * @export
 */
const FieldsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FieldsApiFp)(configuration);
    return {
        /**
         * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
         * @summary List fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(options) {
            return localVarFp.listFields(options).then((request) => request(axios, basePath));
        },
    };
};
exports.FieldsApiFactory = FieldsApiFactory;
/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
class FieldsApi extends base_1.BaseAPI {
    /**
     * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
     * @summary List fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    listFields(options) {
        return (0, exports.FieldsApiFp)(this.configuration).listFields(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FieldsApi = FieldsApi;
/**
 * ForexApi - axios parameter creator
 * @export
 */
const ForexApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve a list of exchange rates
         * @summary List exchange rates
         * @param {string} [base] Base currency code, default is USD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForex: (base_2, ...args_1) => __awaiter(this, [base_2, ...args_1], void 0, function* (base, options = {}) {
            const localVarPath = `/forex`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ForexApiAxiosParamCreator = ForexApiAxiosParamCreator;
/**
 * ForexApi - functional programming interface
 * @export
 */
const ForexApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ForexApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve a list of exchange rates
         * @summary List exchange rates
         * @param {string} [base] Base currency code, default is USD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForex(base, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listForex(base, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ForexApi.listForex']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ForexApiFp = ForexApiFp;
/**
 * ForexApi - factory interface
 * @export
 */
const ForexApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ForexApiFp)(configuration);
    return {
        /**
         * Retrieve a list of exchange rates
         * @summary List exchange rates
         * @param {string} [base] Base currency code, default is USD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForex(base, options) {
            return localVarFp.listForex(base, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ForexApiFactory = ForexApiFactory;
/**
 * ForexApi - object-oriented interface
 * @export
 * @class ForexApi
 * @extends {BaseAPI}
 */
class ForexApi extends base_1.BaseAPI {
    /**
     * Retrieve a list of exchange rates
     * @summary List exchange rates
     * @param {string} [base] Base currency code, default is USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForexApi
     */
    listForex(base, options) {
        return (0, exports.ForexApiFp)(this.configuration).listForex(base, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ForexApi = ForexApi;
/**
 * FraudReviewsApi - axios parameter creator
 * @export
 */
const FraudReviewsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
         * @summary Block fraud review
         * @param {string} id The ID of the reward that should be blocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockFraudReview: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('blockFraudReview', 'id', id);
            const localVarPath = `/fraud_reviews/{id}/block`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
         * @summary Retrieve single fraud review
         * @param {string} id The ID of the reward that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudReview: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getFraudReview', 'id', id);
            const localVarPath = `/fraud_reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
         * @summary List fraud reviews
         * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
         * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
         * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
         * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudReviews: (offset_1, limit_1, status_1, createdAtGte_1, createdAtLte_1, redeemedAtGte_1, redeemedAtLte_1, ...args_1) => __awaiter(this, [offset_1, limit_1, status_1, createdAtGte_1, createdAtLte_1, redeemedAtGte_1, redeemedAtLte_1, ...args_1], void 0, function* (offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options = {}) {
            const localVarPath = `/fraud_reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at[gte]'] = createdAtGte;
            }
            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at[lte]'] = createdAtLte;
            }
            if (redeemedAtGte !== undefined) {
                localVarQueryParameter['redeemed_at[gte]'] = redeemedAtGte;
            }
            if (redeemedAtLte !== undefined) {
                localVarQueryParameter['redeemed_at[lte]'] = redeemedAtLte;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
         * @summary Release fraud review
         * @param {string} id The ID of the reward that should be released.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFraudReview: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('releaseFraudReview', 'id', id);
            const localVarPath = `/fraud_reviews/{id}/release`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FraudReviewsApiAxiosParamCreator = FraudReviewsApiAxiosParamCreator;
/**
 * FraudReviewsApi - functional programming interface
 * @export
 */
const FraudReviewsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FraudReviewsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
         * @summary Block fraud review
         * @param {string} id The ID of the reward that should be blocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockFraudReview(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.blockFraudReview(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudReviewsApi.blockFraudReview']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
         * @summary Retrieve single fraud review
         * @param {string} id The ID of the reward that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudReview(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFraudReview(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudReviewsApi.getFraudReview']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
         * @summary List fraud reviews
         * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
         * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
         * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
         * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudReviewsApi.listFraudReviews']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
         * @summary Release fraud review
         * @param {string} id The ID of the reward that should be released.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFraudReview(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.releaseFraudReview(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudReviewsApi.releaseFraudReview']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FraudReviewsApiFp = FraudReviewsApiFp;
/**
 * FraudReviewsApi - factory interface
 * @export
 */
const FraudReviewsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FraudReviewsApiFp)(configuration);
    return {
        /**
         * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
         * @summary Block fraud review
         * @param {string} id The ID of the reward that should be blocked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockFraudReview(id, options) {
            return localVarFp.blockFraudReview(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
         * @summary Retrieve single fraud review
         * @param {string} id The ID of the reward that should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFraudReview(id, options) {
            return localVarFp.getFraudReview(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
         * @summary List fraud reviews
         * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
         * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
         * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
         * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options) {
            return localVarFp.listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
         * @summary Release fraud review
         * @param {string} id The ID of the reward that should be released.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseFraudReview(id, options) {
            return localVarFp.releaseFraudReview(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FraudReviewsApiFactory = FraudReviewsApiFactory;
/**
 * FraudReviewsApi - object-oriented interface
 * @export
 * @class FraudReviewsApi
 * @extends {BaseAPI}
 */
class FraudReviewsApi extends base_1.BaseAPI {
    /**
     * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
     * @summary Block fraud review
     * @param {string} id The ID of the reward that should be blocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    blockFraudReview(id, options) {
        return (0, exports.FraudReviewsApiFp)(this.configuration).blockFraudReview(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
     * @summary Retrieve single fraud review
     * @param {string} id The ID of the reward that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    getFraudReview(id, options) {
        return (0, exports.FraudReviewsApiFp)(this.configuration).getFraudReview(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
     * @summary List fraud reviews
     * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
     * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
     * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
     * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options) {
        return (0, exports.FraudReviewsApiFp)(this.configuration).listFraudReviews(offset, limit, status, createdAtGte, createdAtLte, redeemedAtGte, redeemedAtLte, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
     * @summary Release fraud review
     * @param {string} id The ID of the reward that should be released.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    releaseFraudReview(id, options) {
        return (0, exports.FraudReviewsApiFp)(this.configuration).releaseFraudReview(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FraudReviewsApi = FraudReviewsApi;
/**
 * @export
 */
exports.ListFraudReviewsStatusEnum = {
    Flagged: 'flagged',
    Blocked: 'blocked',
    Released: 'released'
};
/**
 * FraudRulesApi - axios parameter creator
 * @export
 */
const FraudRulesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes the rule of the type passed in the URL.
         * @summary Delete fraud rule
         * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFraudRule: (ruleType_1, ...args_1) => __awaiter(this, [ruleType_1, ...args_1], void 0, function* (ruleType, options = {}) {
            // verify required parameter 'ruleType' is not null or undefined
            (0, common_1.assertParamExists)('deleteFraudRule', 'ruleType', ruleType);
            const localVarPath = `/fraud_rules/{rule_type}`
                .replace(`{${"rule_type"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
         * @summary Configure fraud rule
         * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudRule: (ruleType_1, fraudRuleRequest_1, ...args_1) => __awaiter(this, [ruleType_1, fraudRuleRequest_1, ...args_1], void 0, function* (ruleType, fraudRuleRequest, options = {}) {
            // verify required parameter 'ruleType' is not null or undefined
            (0, common_1.assertParamExists)('fraudRule', 'ruleType', ruleType);
            const localVarPath = `/fraud_rules/{rule_type}`
                .replace(`{${"rule_type"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fraudRuleRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List active fraud rules associated with the organization tied to your API key.
         * @summary List fraud rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudRules: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/fraud_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
         * @summary Update fraud rule list
         * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
         * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFraudRuleList: (ruleType_1, updateFraudRuleListRequest_1, ...args_1) => __awaiter(this, [ruleType_1, updateFraudRuleListRequest_1, ...args_1], void 0, function* (ruleType, updateFraudRuleListRequest, options = {}) {
            // verify required parameter 'ruleType' is not null or undefined
            (0, common_1.assertParamExists)('updateFraudRuleList', 'ruleType', ruleType);
            // verify required parameter 'updateFraudRuleListRequest' is not null or undefined
            (0, common_1.assertParamExists)('updateFraudRuleList', 'updateFraudRuleListRequest', updateFraudRuleListRequest);
            const localVarPath = `/fraud_rules/{rule_type}/update_list`
                .replace(`{${"rule_type"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateFraudRuleListRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FraudRulesApiAxiosParamCreator = FraudRulesApiAxiosParamCreator;
/**
 * FraudRulesApi - functional programming interface
 * @export
 */
const FraudRulesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FraudRulesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes the rule of the type passed in the URL.
         * @summary Delete fraud rule
         * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFraudRule(ruleType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFraudRule(ruleType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudRulesApi.deleteFraudRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
         * @summary Configure fraud rule
         * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudRule(ruleType, fraudRuleRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fraudRule(ruleType, fraudRuleRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudRulesApi.fraudRule']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List active fraud rules associated with the organization tied to your API key.
         * @summary List fraud rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudRules(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFraudRules(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudRulesApi.listFraudRules']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
         * @summary Update fraud rule list
         * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
         * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFraudRuleList(ruleType, updateFraudRuleListRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateFraudRuleList(ruleType, updateFraudRuleListRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FraudRulesApi.updateFraudRuleList']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FraudRulesApiFp = FraudRulesApiFp;
/**
 * FraudRulesApi - factory interface
 * @export
 */
const FraudRulesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FraudRulesApiFp)(configuration);
    return {
        /**
         * Deletes the rule of the type passed in the URL.
         * @summary Delete fraud rule
         * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFraudRule(ruleType, options) {
            return localVarFp.deleteFraudRule(ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
         * @summary Configure fraud rule
         * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
         * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudRule(ruleType, fraudRuleRequest, options) {
            return localVarFp.fraudRule(ruleType, fraudRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List active fraud rules associated with the organization tied to your API key.
         * @summary List fraud rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFraudRules(options) {
            return localVarFp.listFraudRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
         * @summary Update fraud rule list
         * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
         * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFraudRuleList(ruleType, updateFraudRuleListRequest, options) {
            return localVarFp.updateFraudRuleList(ruleType, updateFraudRuleListRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FraudRulesApiFactory = FraudRulesApiFactory;
/**
 * FraudRulesApi - object-oriented interface
 * @export
 * @class FraudRulesApi
 * @extends {BaseAPI}
 */
class FraudRulesApi extends base_1.BaseAPI {
    /**
     * Deletes the rule of the type passed in the URL.
     * @summary Delete fraud rule
     * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    deleteFraudRule(ruleType, options) {
        return (0, exports.FraudRulesApiFp)(this.configuration).deleteFraudRule(ruleType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
     * @summary Configure fraud rule
     * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    fraudRule(ruleType, fraudRuleRequest, options) {
        return (0, exports.FraudRulesApiFp)(this.configuration).fraudRule(ruleType, fraudRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List active fraud rules associated with the organization tied to your API key.
     * @summary List fraud rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    listFraudRules(options) {
        return (0, exports.FraudRulesApiFp)(this.configuration).listFraudRules(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
     * @summary Update fraud rule list
     * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
     * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    updateFraudRuleList(ruleType, updateFraudRuleListRequest, options) {
        return (0, exports.FraudRulesApiFp)(this.configuration).updateFraudRuleList(ruleType, updateFraudRuleListRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FraudRulesApi = FraudRulesApi;
/**
 * @export
 */
exports.DeleteFraudRuleRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
};
/**
 * @export
 */
exports.FraudRuleRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    ReviewRedeemedRewardsCount: 'review_redeemed_rewards_count',
    ReviewRedeemedRewardsAmount: 'review_redeemed_rewards_amount',
    ReviewMultipleEmails: 'review_multiple_emails',
    ReviewVpn: 'review_vpn',
    ReviewTremendousFlagList: 'review_tremendous_flag_list',
    ReviewPreviouslyBlockedRecipients: 'review_previously_blocked_recipients',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
};
/**
 * @export
 */
exports.UpdateFraudRuleListRuleTypeEnum = {
    ReviewCountry: 'review_country',
    ReviewIp: 'review_ip',
    ReviewEmail: 'review_email',
    AllowIp: 'allow_ip',
    AllowEmail: 'allow_email'
};
/**
 * FundingSourcesApi - axios parameter creator
 * @export
 */
const FundingSourcesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve a funding source, identified by the given `id` in the URL
         * @summary Retrieve funding source
         * @param {string} id ID of the funding source that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingSource: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getFundingSource', 'id', id);
            const localVarPath = `/funding_sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
         * @summary List funding sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundingSources: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/funding_sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FundingSourcesApiAxiosParamCreator = FundingSourcesApiAxiosParamCreator;
/**
 * FundingSourcesApi - functional programming interface
 * @export
 */
const FundingSourcesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FundingSourcesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve a funding source, identified by the given `id` in the URL
         * @summary Retrieve funding source
         * @param {string} id ID of the funding source that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingSource(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFundingSource(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FundingSourcesApi.getFundingSource']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
         * @summary List funding sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundingSources(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFundingSources(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['FundingSourcesApi.listFundingSources']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.FundingSourcesApiFp = FundingSourcesApiFp;
/**
 * FundingSourcesApi - factory interface
 * @export
 */
const FundingSourcesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FundingSourcesApiFp)(configuration);
    return {
        /**
         * Retrieve a funding source, identified by the given `id` in the URL
         * @summary Retrieve funding source
         * @param {string} id ID of the funding source that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingSource(id, options) {
            return localVarFp.getFundingSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
         * @summary List funding sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFundingSources(options) {
            return localVarFp.listFundingSources(options).then((request) => request(axios, basePath));
        },
    };
};
exports.FundingSourcesApiFactory = FundingSourcesApiFactory;
/**
 * FundingSourcesApi - object-oriented interface
 * @export
 * @class FundingSourcesApi
 * @extends {BaseAPI}
 */
class FundingSourcesApi extends base_1.BaseAPI {
    /**
     * Retrieve a funding source, identified by the given `id` in the URL
     * @summary Retrieve funding source
     * @param {string} id ID of the funding source that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    getFundingSource(id, options) {
        return (0, exports.FundingSourcesApiFp)(this.configuration).getFundingSource(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
     * @summary List funding sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    listFundingSources(options) {
        return (0, exports.FundingSourcesApiFp)(this.configuration).listFundingSources(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FundingSourcesApi = FundingSourcesApi;
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
const InvoicesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create invoice
         * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice: (createInvoiceRequest_1, ...args_1) => __awaiter(this, [createInvoiceRequest_1, ...args_1], void 0, function* (createInvoiceRequest, options = {}) {
            // verify required parameter 'createInvoiceRequest' is not null or undefined
            (0, common_1.assertParamExists)('createInvoice', 'createInvoiceRequest', createInvoiceRequest);
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createInvoiceRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
         * @summary Delete invoice
         * @param {string} id ID of the invoice that should be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoices: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoices', 'id', id);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generates a CSV version for an invoice listing the associated rewards and orders
         * @summary Retrieve invoice as CSV
         * @param {string} id ID of the Invoice for that the CSV should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoiceCsv: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('downloadInvoiceCsv', 'id', id);
            const localVarPath = `/invoices/{id}/csv`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generates a PDF version for an invoice
         * @summary Retrieve invoice as PDF
         * @param {string} id ID of the Invoice for that the PDF should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoicePdf: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('downloadInvoicePdf', 'id', id);
            const localVarPath = `/invoices/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an invoice, identified by the given `id` in the URL  >  Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
         * @summary Retrieve invoice
         * @param {string} id ID of the invoice that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getInvoice', 'id', id);
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all invoices on your account.  >  Deleted invoices are omitted > > The response does not include any previously deleted invoices.
         * @summary List invoices
         * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices: (offset_1, limit_1, ...args_1) => __awaiter(this, [offset_1, limit_1, ...args_1], void 0, function* (offset, limit, options = {}) {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoicesApiAxiosParamCreator = InvoicesApiAxiosParamCreator;
/**
 * InvoicesApi - functional programming interface
 * @export
 */
const InvoicesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoicesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create invoice
         * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoice(createInvoiceRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.createInvoice']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
         * @summary Delete invoice
         * @param {string} id ID of the invoice that should be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoices(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoices(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.deleteInvoices']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generates a CSV version for an invoice listing the associated rewards and orders
         * @summary Retrieve invoice as CSV
         * @param {string} id ID of the Invoice for that the CSV should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoiceCsv(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadInvoiceCsv(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.downloadInvoiceCsv']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generates a PDF version for an invoice
         * @summary Retrieve invoice as PDF
         * @param {string} id ID of the Invoice for that the PDF should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoicePdf(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadInvoicePdf(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.downloadInvoicePdf']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve an invoice, identified by the given `id` in the URL  >  Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
         * @summary Retrieve invoice
         * @param {string} id ID of the invoice that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoice(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.getInvoice']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetch a list of all invoices on your account.  >  Deleted invoices are omitted > > The response does not include any previously deleted invoices.
         * @summary List invoices
         * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(offset, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listInvoices(offset, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['InvoicesApi.listInvoices']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.InvoicesApiFp = InvoicesApiFp;
/**
 * InvoicesApi - factory interface
 * @export
 */
const InvoicesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoicesApiFp)(configuration);
    return {
        /**
         * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create invoice
         * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoice(createInvoiceRequest, options) {
            return localVarFp.createInvoice(createInvoiceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
         * @summary Delete invoice
         * @param {string} id ID of the invoice that should be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoices(id, options) {
            return localVarFp.deleteInvoices(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a CSV version for an invoice listing the associated rewards and orders
         * @summary Retrieve invoice as CSV
         * @param {string} id ID of the Invoice for that the CSV should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoiceCsv(id, options) {
            return localVarFp.downloadInvoiceCsv(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a PDF version for an invoice
         * @summary Retrieve invoice as PDF
         * @param {string} id ID of the Invoice for that the PDF should be generated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoicePdf(id, options) {
            return localVarFp.downloadInvoicePdf(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an invoice, identified by the given `id` in the URL  >  Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
         * @summary Retrieve invoice
         * @param {string} id ID of the invoice that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(id, options) {
            return localVarFp.getInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all invoices on your account.  >  Deleted invoices are omitted > > The response does not include any previously deleted invoices.
         * @summary List invoices
         * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
         * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvoices(offset, limit, options) {
            return localVarFp.listInvoices(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoicesApiFactory = InvoicesApiFactory;
/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
class InvoicesApi extends base_1.BaseAPI {
    /**
     * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create invoice
     * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    createInvoice(createInvoiceRequest, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).createInvoice(createInvoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
     * @summary Delete invoice
     * @param {string} id ID of the invoice that should be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoices(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).deleteInvoices(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates a CSV version for an invoice listing the associated rewards and orders
     * @summary Retrieve invoice as CSV
     * @param {string} id ID of the Invoice for that the CSV should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    downloadInvoiceCsv(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).downloadInvoiceCsv(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates a PDF version for an invoice
     * @summary Retrieve invoice as PDF
     * @param {string} id ID of the Invoice for that the PDF should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    downloadInvoicePdf(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).downloadInvoicePdf(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an invoice, identified by the given `id` in the URL  >  Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
     * @summary Retrieve invoice
     * @param {string} id ID of the invoice that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getInvoice(id, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).getInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all invoices on your account.  >  Deleted invoices are omitted > > The response does not include any previously deleted invoices.
     * @summary List invoices
     * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    listInvoices(offset, limit, options) {
        return (0, exports.InvoicesApiFp)(this.configuration).listInvoices(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvoicesApi = InvoicesApi;
/**
 * MembersApi - axios parameter creator
 * @export
 */
const MembersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  >  Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
         * @summary Create member
         * @param {CreateMemberRequest} createMemberRequest Member details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember: (createMemberRequest_1, ...args_1) => __awaiter(this, [createMemberRequest_1, ...args_1], void 0, function* (createMemberRequest, options = {}) {
            // verify required parameter 'createMemberRequest' is not null or undefined
            (0, common_1.assertParamExists)('createMember', 'createMemberRequest', createMemberRequest);
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createMemberRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve member
         * @param {string} id ID of the member to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getMember', 'id', id);
            const localVarPath = `/members/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
         * @summary List members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.MembersApiAxiosParamCreator = MembersApiAxiosParamCreator;
/**
 * MembersApi - functional programming interface
 * @export
 */
const MembersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MembersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  >  Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
         * @summary Create member
         * @param {CreateMemberRequest} createMemberRequest Member details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(createMemberRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createMember(createMemberRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MembersApi.createMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieve member
         * @param {string} id ID of the member to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMember(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MembersApi.getMember']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
         * @summary List members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMembers(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['MembersApi.listMembers']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.MembersApiFp = MembersApiFp;
/**
 * MembersApi - factory interface
 * @export
 */
const MembersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MembersApiFp)(configuration);
    return {
        /**
         * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  >  Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
         * @summary Create member
         * @param {CreateMemberRequest} createMemberRequest Member details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMember(createMemberRequest, options) {
            return localVarFp.createMember(createMemberRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve member
         * @param {string} id ID of the member to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(id, options) {
            return localVarFp.getMember(id, options).then((request) => request(axios, basePath));
        },
        /**
         * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
         * @summary List members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMembers(options) {
            return localVarFp.listMembers(options).then((request) => request(axios, basePath));
        },
    };
};
exports.MembersApiFactory = MembersApiFactory;
/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
class MembersApi extends base_1.BaseAPI {
    /**
     * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  >  Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
     * @summary Create member
     * @param {CreateMemberRequest} createMemberRequest Member details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    createMember(createMemberRequest, options) {
        return (0, exports.MembersApiFp)(this.configuration).createMember(createMemberRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve member
     * @param {string} id ID of the member to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    getMember(id, options) {
        return (0, exports.MembersApiFp)(this.configuration).getMember(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
     * @summary List members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    listMembers(options) {
        return (0, exports.MembersApiFp)(this.configuration).listMembers(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MembersApi = MembersApi;
/**
 * OrdersApi - axios parameter creator
 * @export
 */
const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
         * @summary Approve order
         * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOrder: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('approveOrder', 'id', id);
            const localVarPath = `/order_approvals/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Every time you want to send out a reward through Tremendous you need to create an order for it.  >  Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
         * @summary Create order
         * @param {CreateOrderRequest} createOrderRequest Order to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: (createOrderRequest_1, ...args_1) => __awaiter(this, [createOrderRequest_1, ...args_1], void 0, function* (createOrderRequest, options = {}) {
            // verify required parameter 'createOrderRequest' is not null or undefined
            (0, common_1.assertParamExists)('createOrder', 'createOrderRequest', createOrderRequest);
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createOrderRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the order, identified by the given `id` in the URL
         * @summary Retrieve order
         * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getOrder', 'id', id);
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of orders
         * @summary List orders
         * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
         * @param {string} [campaignId] Only return results with a matching campaign_id.
         * @param {string} [externalId] Only return results with a matching external_id.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: (offset_1, campaignId_1, externalId_1, createdAtGte_1, createdAtLte_1, limit_1, ...args_1) => __awaiter(this, [offset_1, campaignId_1, externalId_1, createdAtGte_1, createdAtLte_1, limit_1, ...args_1], void 0, function* (offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options = {}) {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (campaignId !== undefined) {
                localVarQueryParameter['campaign_id'] = campaignId;
            }
            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }
            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at[gte]'] = createdAtGte;
            }
            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at[lte]'] = createdAtLte;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
         * @summary Reject order
         * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('rejectOrder', 'id', id);
            const localVarPath = `/order_approvals/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrdersApiAxiosParamCreator = OrdersApiAxiosParamCreator;
/**
 * OrdersApi - functional programming interface
 * @export
 */
const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OrdersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
         * @summary Approve order
         * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOrder(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.approveOrder(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrdersApi.approveOrder']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Every time you want to send out a reward through Tremendous you need to create an order for it.  >  Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
         * @summary Create order
         * @param {CreateOrderRequest} createOrderRequest Order to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrder(createOrderRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrdersApi.createOrder']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve the order, identified by the given `id` in the URL
         * @summary Retrieve order
         * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrder(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrdersApi.getOrder']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of orders
         * @summary List orders
         * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
         * @param {string} [campaignId] Only return results with a matching campaign_id.
         * @param {string} [externalId] Only return results with a matching external_id.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrdersApi.listOrders']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
         * @summary Reject order
         * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rejectOrder(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrdersApi.rejectOrder']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.OrdersApiFp = OrdersApiFp;
/**
 * OrdersApi - factory interface
 * @export
 */
const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OrdersApiFp)(configuration);
    return {
        /**
         * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
         * @summary Approve order
         * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOrder(id, options) {
            return localVarFp.approveOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Every time you want to send out a reward through Tremendous you need to create an order for it.  >  Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
         * @summary Create order
         * @param {CreateOrderRequest} createOrderRequest Order to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest, options) {
            return localVarFp.createOrder(createOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the order, identified by the given `id` in the URL
         * @summary Retrieve order
         * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(id, options) {
            return localVarFp.getOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of orders
         * @summary List orders
         * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
         * @param {string} [campaignId] Only return results with a matching campaign_id.
         * @param {string} [externalId] Only return results with a matching external_id.
         * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
         * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options) {
            return localVarFp.listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
         * @summary Reject order
         * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOrder(id, options) {
            return localVarFp.rejectOrder(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrdersApiFactory = OrdersApiFactory;
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends base_1.BaseAPI {
    /**
     * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Approve order
     * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    approveOrder(id, options) {
        return (0, exports.OrdersApiFp)(this.configuration).approveOrder(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Every time you want to send out a reward through Tremendous you need to create an order for it.  >  Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
     * @summary Create order
     * @param {CreateOrderRequest} createOrderRequest Order to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createOrder(createOrderRequest, options) {
        return (0, exports.OrdersApiFp)(this.configuration).createOrder(createOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the order, identified by the given `id` in the URL
     * @summary Retrieve order
     * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrder(id, options) {
        return (0, exports.OrdersApiFp)(this.configuration).getOrder(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of orders
     * @summary List orders
     * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
     * @param {string} [campaignId] Only return results with a matching campaign_id.
     * @param {string} [externalId] Only return results with a matching external_id.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options) {
        return (0, exports.OrdersApiFp)(this.configuration).listOrders(offset, campaignId, externalId, createdAtGte, createdAtLte, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Reject order
     * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    rejectOrder(id, options) {
        return (0, exports.OrdersApiFp)(this.configuration).rejectOrder(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrdersApi = OrdersApi;
/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
const OrganizationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
         * @summary Create API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/organizations/create_api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
         * @summary Create organization
         * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: (createOrganizationRequest_1, ...args_1) => __awaiter(this, [createOrganizationRequest_1, ...args_1], void 0, function* (createOrganizationRequest, options = {}) {
            // verify required parameter 'createOrganizationRequest' is not null or undefined
            (0, common_1.assertParamExists)('createOrganization', 'createOrganizationRequest', createOrganizationRequest);
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createOrganizationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve organization
         * @param {string} id ID of the organization to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getOrganization', 'id', id);
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The returned list only includes the organization to which the API key belongs to, that is used for the request.
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrganizationsApiAxiosParamCreator = OrganizationsApiAxiosParamCreator;
/**
 * OrganizationsApi - functional programming interface
 * @export
 */
const OrganizationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OrganizationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
         * @summary Create API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApiKey(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationsApi.createApiKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
         * @summary Create organization
         * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganization(createOrganizationRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationsApi.createOrganization']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Retrieve organization
         * @param {string} id ID of the organization to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationsApi.getOrganization']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * The returned list only includes the organization to which the API key belongs to, that is used for the request.
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listOrganizations(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['OrganizationsApi.listOrganizations']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.OrganizationsApiFp = OrganizationsApiFp;
/**
 * OrganizationsApi - factory interface
 * @export
 */
const OrganizationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OrganizationsApiFp)(configuration);
    return {
        /**
         * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
         * @summary Create API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(options) {
            return localVarFp.createApiKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
         * @summary Create organization
         * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest, options) {
            return localVarFp.createOrganization(createOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve organization
         * @param {string} id ID of the organization to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id, options) {
            return localVarFp.getOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned list only includes the organization to which the API key belongs to, that is used for the request.
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options) {
            return localVarFp.listOrganizations(options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrganizationsApiFactory = OrganizationsApiFactory;
/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
class OrganizationsApi extends base_1.BaseAPI {
    /**
     * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
     * @summary Create API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    createApiKey(options) {
        return (0, exports.OrganizationsApiFp)(this.configuration).createApiKey(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
     * @summary Create organization
     * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    createOrganization(createOrganizationRequest, options) {
        return (0, exports.OrganizationsApiFp)(this.configuration).createOrganization(createOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve organization
     * @param {string} id ID of the organization to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    getOrganization(id, options) {
        return (0, exports.OrganizationsApiFp)(this.configuration).getOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The returned list only includes the organization to which the API key belongs to, that is used for the request.
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    listOrganizations(options) {
        return (0, exports.OrganizationsApiFp)(this.configuration).listOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationsApi = OrganizationsApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
const ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve a product, identified by the given `id` in the URL
         * @summary Retrieve product
         * @param {string} id ID of the product that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getProduct', 'id', id);
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of available products
         * @summary List products
         * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
         * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: (country_1, currency_1, ...args_1) => __awaiter(this, [country_1, currency_1, ...args_1], void 0, function* (country, currency, options = {}) {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }
            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ProductsApiAxiosParamCreator = ProductsApiAxiosParamCreator;
/**
 * ProductsApi - functional programming interface
 * @export
 */
const ProductsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ProductsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieve a product, identified by the given `id` in the URL
         * @summary Retrieve product
         * @param {string} id ID of the product that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProduct(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.getProduct']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of available products
         * @summary List products
         * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
         * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(country, currency, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listProducts(country, currency, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['ProductsApi.listProducts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ProductsApiFp = ProductsApiFp;
/**
 * ProductsApi - factory interface
 * @export
 */
const ProductsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ProductsApiFp)(configuration);
    return {
        /**
         * Retrieve a product, identified by the given `id` in the URL
         * @summary Retrieve product
         * @param {string} id ID of the product that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id, options) {
            return localVarFp.getProduct(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of available products
         * @summary List products
         * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
         * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(country, currency, options) {
            return localVarFp.listProducts(country, currency, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ProductsApiFactory = ProductsApiFactory;
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     * Retrieve a product, identified by the given `id` in the URL
     * @summary Retrieve product
     * @param {string} id ID of the product that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProduct(id, options) {
        return (0, exports.ProductsApiFp)(this.configuration).getProduct(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of available products
     * @summary List products
     * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
     * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listProducts(country, currency, options) {
        return (0, exports.ProductsApiFp)(this.configuration).listProducts(country, currency, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * PublicKeysApi - axios parameter creator
 * @export
 */
const PublicKeysApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creating a public key is the way for your organization to share it with Tremendous.  >  Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create public key
         * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: (createPublicKeyRequest_1, ...args_1) => __awaiter(this, [createPublicKeyRequest_1, ...args_1], void 0, function* (createPublicKeyRequest, options = {}) {
            // verify required parameter 'createPublicKeyRequest' is not null or undefined
            (0, common_1.assertParamExists)('createPublicKey', 'createPublicKeyRequest', createPublicKeyRequest);
            const localVarPath = `/public_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPublicKeyRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
         * @summary Delete public key
         * @param {string} id ID of the public key that should be deactivated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deletePublicKey', 'id', id);
            const localVarPath = `/public_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an active public key, identified by the given `id` in the URL.
         * @summary Retrieve public key
         * @param {string} id ID of the public key that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getPublicKey', 'id', id);
            const localVarPath = `/public_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of active public keys on your account.  >  Inactive public keys are omitted > > The response does not include inactive public keys.
         * @summary List public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/public_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  >  Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select RS256 in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the Verify signature fields with your public and private keys and copy the Encoded token.
         * @summary Test public key
         * @param {string} id ID of the public key to test
         * @param {TestPublicKeyRequest} testPublicKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPublicKey: (id_1, testPublicKeyRequest_1, ...args_1) => __awaiter(this, [id_1, testPublicKeyRequest_1, ...args_1], void 0, function* (id, testPublicKeyRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('testPublicKey', 'id', id);
            // verify required parameter 'testPublicKeyRequest' is not null or undefined
            (0, common_1.assertParamExists)('testPublicKey', 'testPublicKeyRequest', testPublicKeyRequest);
            const localVarPath = `/public_keys/{id}/decode_jwt`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(testPublicKeyRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PublicKeysApiAxiosParamCreator = PublicKeysApiAxiosParamCreator;
/**
 * PublicKeysApi - functional programming interface
 * @export
 */
const PublicKeysApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PublicKeysApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creating a public key is the way for your organization to share it with Tremendous.  >  Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create public key
         * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(createPublicKeyRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPublicKey(createPublicKeyRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicKeysApi.createPublicKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
         * @summary Delete public key
         * @param {string} id ID of the public key that should be deactivated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePublicKey(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicKeysApi.deletePublicKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve an active public key, identified by the given `id` in the URL.
         * @summary Retrieve public key
         * @param {string} id ID of the public key that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPublicKey(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicKeysApi.getPublicKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Fetch a list of active public keys on your account.  >  Inactive public keys are omitted > > The response does not include inactive public keys.
         * @summary List public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPublicKeys(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicKeysApi.listPublicKeys']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  >  Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select RS256 in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the Verify signature fields with your public and private keys and copy the Encoded token.
         * @summary Test public key
         * @param {string} id ID of the public key to test
         * @param {TestPublicKeyRequest} testPublicKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPublicKey(id, testPublicKeyRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.testPublicKey(id, testPublicKeyRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['PublicKeysApi.testPublicKey']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.PublicKeysApiFp = PublicKeysApiFp;
/**
 * PublicKeysApi - factory interface
 * @export
 */
const PublicKeysApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PublicKeysApiFp)(configuration);
    return {
        /**
         * Creating a public key is the way for your organization to share it with Tremendous.  >  Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create public key
         * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(createPublicKeyRequest, options) {
            return localVarFp.createPublicKey(createPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
         * @summary Delete public key
         * @param {string} id ID of the public key that should be deactivated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(id, options) {
            return localVarFp.deletePublicKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an active public key, identified by the given `id` in the URL.
         * @summary Retrieve public key
         * @param {string} id ID of the public key that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(id, options) {
            return localVarFp.getPublicKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of active public keys on your account.  >  Inactive public keys are omitted > > The response does not include inactive public keys.
         * @summary List public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys(options) {
            return localVarFp.listPublicKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  >  Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select RS256 in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the Verify signature fields with your public and private keys and copy the Encoded token.
         * @summary Test public key
         * @param {string} id ID of the public key to test
         * @param {TestPublicKeyRequest} testPublicKeyRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPublicKey(id, testPublicKeyRequest, options) {
            return localVarFp.testPublicKey(id, testPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PublicKeysApiFactory = PublicKeysApiFactory;
/**
 * PublicKeysApi - object-oriented interface
 * @export
 * @class PublicKeysApi
 * @extends {BaseAPI}
 */
class PublicKeysApi extends base_1.BaseAPI {
    /**
     * Creating a public key is the way for your organization to share it with Tremendous.  >  Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create public key
     * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    createPublicKey(createPublicKeyRequest, options) {
        return (0, exports.PublicKeysApiFp)(this.configuration).createPublicKey(createPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
     * @summary Delete public key
     * @param {string} id ID of the public key that should be deactivated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    deletePublicKey(id, options) {
        return (0, exports.PublicKeysApiFp)(this.configuration).deletePublicKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an active public key, identified by the given `id` in the URL.
     * @summary Retrieve public key
     * @param {string} id ID of the public key that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    getPublicKey(id, options) {
        return (0, exports.PublicKeysApiFp)(this.configuration).getPublicKey(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of active public keys on your account.  >  Inactive public keys are omitted > > The response does not include inactive public keys.
     * @summary List public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    listPublicKeys(options) {
        return (0, exports.PublicKeysApiFp)(this.configuration).listPublicKeys(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  >  Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select RS256 in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the Verify signature fields with your public and private keys and copy the Encoded token.
     * @summary Test public key
     * @param {string} id ID of the public key to test
     * @param {TestPublicKeyRequest} testPublicKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    testPublicKey(id, testPublicKeyRequest, options) {
        return (0, exports.PublicKeysApiFp)(this.configuration).testPublicKey(id, testPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PublicKeysApi = PublicKeysApi;
/**
 * RewardsApi - axios parameter creator
 * @export
 */
const RewardsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generate a redemption link for the reward identified by the `id` in the URL
         * @summary Generate a reward URL
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardLink: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('generateRewardLink', 'id', id);
            const localVarPath = `/rewards/{id}/generate_link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
         * @summary Generate a reward token
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardToken: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('generateRewardToken', 'id', id);
            const localVarPath = `/rewards/{id}/generate_embed_token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve the reward, identified by the given `id` in the URL
         * @summary Retrieve single reward
         * @param {string} id ID of the reward that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getReward', 'id', id);
            const localVarPath = `/rewards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of all created rewards
         * @summary List rewards
         * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards: (offset_1, ...args_1) => __awaiter(this, [offset_1, ...args_1], void 0, function* (offset, options = {}) {
            const localVarPath = `/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resends a reward, identified by the given `id` in the URL, to its recipient.
         * @summary Resend reward
         * @param {string} id ID of the reward that should be resent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReward: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('resendReward', 'id', id);
            const localVarPath = `/rewards/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RewardsApiAxiosParamCreator = RewardsApiAxiosParamCreator;
/**
 * RewardsApi - functional programming interface
 * @export
 */
const RewardsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RewardsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Generate a redemption link for the reward identified by the `id` in the URL
         * @summary Generate a reward URL
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardLink(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateRewardLink(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RewardsApi.generateRewardLink']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
         * @summary Generate a reward token
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardToken(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateRewardToken(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RewardsApi.generateRewardToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve the reward, identified by the given `id` in the URL
         * @summary Retrieve single reward
         * @param {string} id ID of the reward that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getReward(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RewardsApi.getReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of all created rewards
         * @summary List rewards
         * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards(offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRewards(offset, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RewardsApi.listRewards']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resends a reward, identified by the given `id` in the URL, to its recipient.
         * @summary Resend reward
         * @param {string} id ID of the reward that should be resent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReward(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resendReward(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RewardsApi.resendReward']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RewardsApiFp = RewardsApiFp;
/**
 * RewardsApi - factory interface
 * @export
 */
const RewardsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RewardsApiFp)(configuration);
    return {
        /**
         * Generate a redemption link for the reward identified by the `id` in the URL
         * @summary Generate a reward URL
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardLink(id, options) {
            return localVarFp.generateRewardLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
         * @summary Generate a reward token
         * @param {string} id ID of the reward
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRewardToken(id, options) {
            return localVarFp.generateRewardToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the reward, identified by the given `id` in the URL
         * @summary Retrieve single reward
         * @param {string} id ID of the reward that should be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReward(id, options) {
            return localVarFp.getReward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all created rewards
         * @summary List rewards
         * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewards(offset, options) {
            return localVarFp.listRewards(offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a reward, identified by the given `id` in the URL, to its recipient.
         * @summary Resend reward
         * @param {string} id ID of the reward that should be resent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReward(id, options) {
            return localVarFp.resendReward(id, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RewardsApiFactory = RewardsApiFactory;
/**
 * RewardsApi - object-oriented interface
 * @export
 * @class RewardsApi
 * @extends {BaseAPI}
 */
class RewardsApi extends base_1.BaseAPI {
    /**
     * Generate a redemption link for the reward identified by the `id` in the URL
     * @summary Generate a reward URL
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    generateRewardLink(id, options) {
        return (0, exports.RewardsApiFp)(this.configuration).generateRewardLink(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
     * @summary Generate a reward token
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    generateRewardToken(id, options) {
        return (0, exports.RewardsApiFp)(this.configuration).generateRewardToken(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the reward, identified by the given `id` in the URL
     * @summary Retrieve single reward
     * @param {string} id ID of the reward that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    getReward(id, options) {
        return (0, exports.RewardsApiFp)(this.configuration).getReward(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of all created rewards
     * @summary List rewards
     * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    listRewards(offset, options) {
        return (0, exports.RewardsApiFp)(this.configuration).listRewards(offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resends a reward, identified by the given `id` in the URL, to its recipient.
     * @summary Resend reward
     * @param {string} id ID of the reward that should be resent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    resendReward(id, options) {
        return (0, exports.RewardsApiFp)(this.configuration).resendReward(id, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RewardsApi = RewardsApi;
/**
 * RolesApi - axios parameter creator
 * @export
 */
const RolesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List all available roles in the organization.
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RolesApiAxiosParamCreator = RolesApiAxiosParamCreator;
/**
 * RolesApi - functional programming interface
 * @export
 */
const RolesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.RolesApiAxiosParamCreator)(configuration);
    return {
        /**
         * List all available roles in the organization.
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRoles(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['RolesApi.listRoles']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.RolesApiFp = RolesApiFp;
/**
 * RolesApi - factory interface
 * @export
 */
const RolesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.RolesApiFp)(configuration);
    return {
        /**
         * List all available roles in the organization.
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options) {
            return localVarFp.listRoles(options).then((request) => request(axios, basePath));
        },
    };
};
exports.RolesApiFactory = RolesApiFactory;
/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
class RolesApi extends base_1.BaseAPI {
    /**
     * List all available roles in the organization.
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    listRoles(options) {
        return (0, exports.RolesApiFp)(this.configuration).listRoles(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RolesApi = RolesApi;
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
const WebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Tremendous uses webhooks as a notification system for various events that happen in your account.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create webhook
         * @param {CreateWebhookRequest} createWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: (createWebhookRequest_1, ...args_1) => __awaiter(this, [createWebhookRequest_1, ...args_1], void 0, function* (createWebhookRequest, options = {}) {
            // verify required parameter 'createWebhookRequest' is not null or undefined
            (0, common_1.assertParamExists)('createWebhook', 'createWebhookRequest', createWebhookRequest);
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWebhookRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Delete webhook
         * @param {string} id ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhook', 'id', id);
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Retrieve webhook
         * @param {string} id ID of the webhook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('getWebhook', 'id', id);
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all event types that can be sent to the configured webhook endpoint.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary List events
         * @param {string} id ID of the webhook to list the events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvents: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('listWebhookEvents', 'id', id);
            const localVarPath = `/webhooks/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Every organization can only have one webhook. This endpoint shows the details about that webhook.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Test webhook
         * @param {string} id ID of the webhook to test
         * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateWebhook: (id_1, simulateWebhookRequest_1, ...args_1) => __awaiter(this, [id_1, simulateWebhookRequest_1, ...args_1], void 0, function* (id, simulateWebhookRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('simulateWebhook', 'id', id);
            // verify required parameter 'simulateWebhookRequest' is not null or undefined
            (0, common_1.assertParamExists)('simulateWebhook', 'simulateWebhookRequest', simulateWebhookRequest);
            const localVarPath = `/webhooks/{id}/simulate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication BearerApiKey required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(simulateWebhookRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);
    return {
        /**
         * Tremendous uses webhooks as a notification system for various events that happen in your account.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create webhook
         * @param {CreateWebhookRequest} createWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.createWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Delete webhook
         * @param {string} id ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhook(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.deleteWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Retrieve webhook
         * @param {string} id ID of the webhook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWebhook(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.getWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all event types that can be sent to the configured webhook endpoint.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary List events
         * @param {string} id ID of the webhook to list the events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvents(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhookEvents(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.listWebhookEvents']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Every organization can only have one webhook. This endpoint shows the details about that webhook.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhooks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.listWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Test webhook
         * @param {string} id ID of the webhook to test
         * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateWebhook(id, simulateWebhookRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.simulateWebhook(id, simulateWebhookRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['WebhooksApi.simulateWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.WebhooksApiFp = WebhooksApiFp;
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.WebhooksApiFp)(configuration);
    return {
        /**
         * Tremendous uses webhooks as a notification system for various events that happen in your account.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
         * @summary Create webhook
         * @param {CreateWebhookRequest} createWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookRequest, options) {
            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Delete webhook
         * @param {string} id ID of the webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(id, options) {
            return localVarFp.deleteWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Retrieve webhook
         * @param {string} id ID of the webhook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(id, options) {
            return localVarFp.getWebhook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all event types that can be sent to the configured webhook endpoint.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary List events
         * @param {string} id ID of the webhook to list the events for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhookEvents(id, options) {
            return localVarFp.listWebhookEvents(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Every organization can only have one webhook. This endpoint shows the details about that webhook.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
         * @summary Test webhook
         * @param {string} id ID of the webhook to test
         * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateWebhook(id, simulateWebhookRequest, options) {
            return localVarFp.simulateWebhook(id, simulateWebhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.WebhooksApiFactory = WebhooksApiFactory;
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends base_1.BaseAPI {
    /**
     * Tremendous uses webhooks as a notification system for various events that happen in your account.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create webhook
     * @param {CreateWebhookRequest} createWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookRequest, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Delete webhook
     * @param {string} id ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(id, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Retrieve webhook
     * @param {string} id ID of the webhook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhook(id, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).getWebhook(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all event types that can be sent to the configured webhook endpoint.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List events
     * @param {string} id ID of the webhook to list the events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhookEvents(id, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).listWebhookEvents(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Every organization can only have one webhook. This endpoint shows the details about that webhook.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhooks(options) {
        return (0, exports.WebhooksApiFp)(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  >  Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Test webhook
     * @param {string} id ID of the webhook to test
     * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    simulateWebhook(id, simulateWebhookRequest, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).simulateWebhook(id, simulateWebhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.WebhooksApi = WebhooksApi;
