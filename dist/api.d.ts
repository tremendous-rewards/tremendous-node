/**
 * API Endpoints
 * Deliver monetary rewards and incentives to employees, customers, survey participants, and more through the Tremendous API. For organizational tasks, like managing your organization and it\'s members within Tremendous, please see the Tremendous Organizational API.
 *
 * The version of the OpenAPI document: 2
 * Contact: developers@tremendous.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 * Ignore flagging rules for rewards redeemed by an email or domain matching this list.
 * @export
 * @interface AllowEmail
 */
export interface AllowEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof AllowEmail
     */
    'emails': Array<string>;
}
/**
 * The list of emails and domains where a matching redemption will ignore other flagging rules and automatically go through.
 * @export
 * @interface AllowEmail1
 */
export interface AllowEmail1 {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof AllowEmail1
     */
    'emails': Array<string>;
}
/**
 * Ignore flagging rules for rewards redeemed by an IP matching this list.
 * @export
 * @interface AllowIp
 */
export interface AllowIp {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof AllowIp
     */
    'ips': Array<string>;
}
/**
 * The list of IP addresses and/or IP ranges where a matching redemption will ignore other flagging rules and automatically go through.
 * @export
 * @interface AllowIp1
 */
export interface AllowIp1 {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof AllowIp1
     */
    'ips': Array<string>;
}
/**
 * A balance transaction represents a specific movement or change in an account\'s balance.
 * @export
 * @interface BalanceTransaction
 */
export interface BalanceTransaction {
    /**
     * Date that the transaction was created
     * @type {string}
     * @memberof BalanceTransaction
     */
    'created_at'?: string;
    /**
     * Amount of the transaction in USD
     * @type {number}
     * @memberof BalanceTransaction
     */
    'amount'?: number;
    /**
     * The updated total after the transaction. Note that this running balance may be delayed and contain `null`.
     * @type {number}
     * @memberof BalanceTransaction
     */
    'balance'?: number;
    /**
     * The action that was performed
     * @type {string}
     * @memberof BalanceTransaction
     */
    'action'?: string;
    /**
     * A brief description of the transaction
     * @type {string}
     * @memberof BalanceTransaction
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface BaseOrderForCreate
 */
export interface BaseOrderForCreate {
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof BaseOrderForCreate
     */
    'external_id'?: string | null;
    /**
     *
     * @type {SingleRewardOrder1Payment}
     * @memberof BaseOrderForCreate
     */
    'payment': SingleRewardOrder1Payment;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from.
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     *
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof Campaign
     */
    'description': string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign.
     * @type {Array<string>}
     * @memberof Campaign
     */
    'products': Array<string>;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof Campaign
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof Campaign
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from.
 * @export
 * @interface CampaignBase
 */
export interface CampaignBase {
    /**
     *
     * @type {string}
     * @memberof CampaignBase
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CampaignBase
     */
    'name'?: string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof CampaignBase
     */
    'description'?: string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign.
     * @type {Array<string>}
     * @memberof CampaignBase
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof CampaignBase
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof CampaignBase
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 *
 * @export
 * @interface CreateApiKey200Response
 */
export interface CreateApiKey200Response {
    /**
     * The new API key
     * @type {string}
     * @memberof CreateApiKey200Response
     */
    'api_key'?: string;
}
/**
 *
 * @export
 * @interface CreateCampaign201Response
 */
export interface CreateCampaign201Response {
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInner}
     * @memberof CreateCampaign201Response
     */
    'campaign': ListCampaigns200ResponseCampaignsInner;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from.
 * @export
 * @interface CreateCampaignRequest
 */
export interface CreateCampaignRequest {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'name': string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'description': string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign.
     * @type {Array<string>}
     * @memberof CreateCampaignRequest
     */
    'products': Array<string>;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof CreateCampaignRequest
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof CreateCampaignRequest
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 *
 * @export
 * @interface CreateInvoice
 */
export interface CreateInvoice {
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof CreateInvoice
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof CreateInvoice
     */
    'amount': number;
    /**
     * A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.
     * @type {string}
     * @memberof CreateInvoice
     */
    'memo'?: string | null;
}
/**
 *
 * @export
 * @interface CreateInvoice200Response
 */
export interface CreateInvoice200Response {
    /**
     *
     * @type {ListInvoices200ResponseInvoicesInner}
     * @memberof CreateInvoice200Response
     */
    'invoice': ListInvoices200ResponseInvoicesInner;
}
/**
 *
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest {
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof CreateInvoiceRequest
     */
    'amount': number;
    /**
     * A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    'memo'?: string | null;
}
/**
 *
 * @export
 * @interface CreateMember
 */
export interface CreateMember {
    /**
     * Email address of the member
     * @type {string}
     * @memberof CreateMember
     */
    'email': string;
    /**
     * The role ID of the member within the organization.
     * @type {string}
     * @memberof CreateMember
     */
    'role': string;
}
/**
 *
 * @export
 * @interface CreateMember200Response
 */
export interface CreateMember200Response {
    /**
     *
     * @type {ListMembers200ResponseMembersInner}
     * @memberof CreateMember200Response
     */
    'member': ListMembers200ResponseMembersInner;
}
/**
 *
 * @export
 * @interface CreateMemberRequest
 */
export interface CreateMemberRequest {
    /**
     * Email address of the member
     * @type {string}
     * @memberof CreateMemberRequest
     */
    'email': string;
    /**
     * The role ID of the member within the organization.
     * @type {string}
     * @memberof CreateMemberRequest
     */
    'role': string;
}
/**
 *
 * @export
 * @interface CreateOrder200Response
 */
export interface CreateOrder200Response {
    /**
     *
     * @type {ListOrders200ResponseOrdersInner}
     * @memberof CreateOrder200Response
     */
    'order': ListOrders200ResponseOrdersInner;
}
/**
 * @type CreateOrderRequest
 * @export
 */
export type CreateOrderRequest = SingleRewardOrder1;
/**
 *
 * @export
 * @interface CreateOrganization
 */
export interface CreateOrganization {
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganization
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof CreateOrganization
     */
    'website': string;
    /**
     * Default value is `false`. Set to true to also generate an API key associated to the new organization.
     * @type {boolean}
     * @memberof CreateOrganization
     */
    'with_api_key'?: boolean;
    /**
     *
     * @type {CreateOrganizationRequestCopySettings}
     * @memberof CreateOrganization
     */
    'copy_settings'?: CreateOrganizationRequestCopySettings;
    /**
     * Phone number of the organization. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof CreateOrganization
     */
    'phone'?: string;
}
/**
 *
 * @export
 * @interface CreateOrganization200Response
 */
export interface CreateOrganization200Response {
    /**
     *
     * @type {CreateOrganization200ResponseOrganization}
     * @memberof CreateOrganization200Response
     */
    'organization'?: CreateOrganization200ResponseOrganization;
}
/**
 * Organizations are a way to separate different parts of your business within the same Tremendous account. Your root Tremendous account is an organization itself and can have multiple sub-organizations.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  Each organizations can have it\'s own API key.
 * @export
 * @interface CreateOrganization200ResponseOrganization
 */
export interface CreateOrganization200ResponseOrganization {
    /**
     *
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'id'?: string;
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'website': string;
    /**
     * Status of the organization. Organizations need to be approved to be able to use them to send out rewards.
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'status'?: CreateOrganization200ResponseOrganizationStatusEnum;
    /**
     * Timestamp of when the organization has been created.  *This field is only returned when creating an organization.* It is not returned anymore when retrieving or listing organizations.
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'created_at'?: string;
    /**
     * The API key for the created organization. This property is only returned when `with_api_key` is set to `true`.
     * @type {string}
     * @memberof CreateOrganization200ResponseOrganization
     */
    'api_key'?: string;
}
export declare const CreateOrganization200ResponseOrganizationStatusEnum: {
    readonly Pending: "PENDING";
    readonly Approved: "APPROVED";
    readonly Rejected: "REJECTED";
};
export type CreateOrganization200ResponseOrganizationStatusEnum = typeof CreateOrganization200ResponseOrganizationStatusEnum[keyof typeof CreateOrganization200ResponseOrganizationStatusEnum];
/**
 *
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * Name of the organization
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'website': string;
    /**
     * Default value is `false`. Set to true to also generate an API key associated to the new organization.
     * @type {boolean}
     * @memberof CreateOrganizationRequest
     */
    'with_api_key'?: boolean;
    /**
     *
     * @type {CreateOrganizationRequestCopySettings}
     * @memberof CreateOrganizationRequest
     */
    'copy_settings'?: CreateOrganizationRequestCopySettings;
    /**
     * Phone number of the organization. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'phone'?: string;
}
/**
 * A list of the settings that you wish to copy over to the new organization.
 * @export
 * @interface CreateOrganizationRequestCopySettings
 */
export interface CreateOrganizationRequestCopySettings {
    /**
     * Copy over the campaigns from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'campaigns'?: boolean;
    /**
     * Copy over the custom fields from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'custom_fields'?: boolean;
    /**
     * Copy over the order approvals settings from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'order_approvals'?: boolean;
    /**
     * Copy over the payment methods from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'payment_methods'?: boolean;
    /**
     * Copy over the security settings from the current organization to the new organization. Defaults to `true`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'security_settings'?: boolean;
    /**
     * Copy over the users and custom roles from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'users'?: boolean;
    /**
     * Copy over the custom roles from the current organization to the new organization. Custom roles are always copied if `users` is `true`. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'custom_roles'?: boolean;
    /**
     * Copy over the fraud prevention settings and rules from the current organization to the new organization. Defaults to `false`.
     * @type {boolean}
     * @memberof CreateOrganizationRequestCopySettings
     */
    'fraud_prevention'?: boolean;
}
/**
 *
 * @export
 * @interface CreatePublicKey
 */
export interface CreatePublicKey {
    /**
     * Base64 encoded (public) PEM file
     * @type {string}
     * @memberof CreatePublicKey
     */
    'public_key': string;
}
/**
 *
 * @export
 * @interface CreatePublicKey200Response
 */
export interface CreatePublicKey200Response {
    /**
     *
     * @type {PublicKeysResponsePublicKeysInner}
     * @memberof CreatePublicKey200Response
     */
    'public_key': PublicKeysResponsePublicKeysInner;
}
/**
 *
 * @export
 * @interface CreatePublicKeyRequest
 */
export interface CreatePublicKeyRequest {
    /**
     * Base64 encoded (public) PEM file
     * @type {string}
     * @memberof CreatePublicKeyRequest
     */
    'public_key': string;
}
/**
 *
 * @export
 * @interface CreateWebhook200Response
 */
export interface CreateWebhook200Response {
    /**
     *
     * @type {ListWebhooks200ResponseWebhooksInner}
     * @memberof CreateWebhook200Response
     */
    'webhook'?: ListWebhooks200ResponseWebhooksInner;
}
/**
 *
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof CreateWebhookRequest
     */
    'url': string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const CurrencyCodes: {
    readonly Usd: "USD";
    readonly Cad: "CAD";
    readonly Eur: "EUR";
    readonly Aed: "AED";
    readonly Afn: "AFN";
    readonly All: "ALL";
    readonly Amd: "AMD";
    readonly Ars: "ARS";
    readonly Aud: "AUD";
    readonly Azn: "AZN";
    readonly Bam: "BAM";
    readonly Bdt: "BDT";
    readonly Bgn: "BGN";
    readonly Bhd: "BHD";
    readonly Bif: "BIF";
    readonly Bnd: "BND";
    readonly Bob: "BOB";
    readonly Brl: "BRL";
    readonly Bwp: "BWP";
    readonly Byr: "BYR";
    readonly Bzd: "BZD";
    readonly Cdf: "CDF";
    readonly Chf: "CHF";
    readonly Clp: "CLP";
    readonly Cny: "CNY";
    readonly Cop: "COP";
    readonly Crc: "CRC";
    readonly Cve: "CVE";
    readonly Czk: "CZK";
    readonly Djf: "DJF";
    readonly Dkk: "DKK";
    readonly Dop: "DOP";
    readonly Dzd: "DZD";
    readonly Eek: "EEK";
    readonly Egp: "EGP";
    readonly Ern: "ERN";
    readonly Etb: "ETB";
    readonly Gbp: "GBP";
    readonly Gel: "GEL";
    readonly Ghs: "GHS";
    readonly Gnf: "GNF";
    readonly Gtq: "GTQ";
    readonly Hkd: "HKD";
    readonly Hnl: "HNL";
    readonly Hrk: "HRK";
    readonly Huf: "HUF";
    readonly Idr: "IDR";
    readonly Ils: "ILS";
    readonly Inr: "INR";
    readonly Iqd: "IQD";
    readonly Irr: "IRR";
    readonly Isk: "ISK";
    readonly Jmd: "JMD";
    readonly Jod: "JOD";
    readonly Jpy: "JPY";
    readonly Kes: "KES";
    readonly Khr: "KHR";
    readonly Krw: "KRW";
    readonly Kwd: "KWD";
    readonly Kzt: "KZT";
    readonly Lbp: "LBP";
    readonly Lkr: "LKR";
    readonly Ltl: "LTL";
    readonly Lvl: "LVL";
    readonly Mad: "MAD";
    readonly Mdl: "MDL";
    readonly Mga: "MGA";
    readonly Mkd: "MKD";
    readonly Mmk: "MMK";
    readonly Mop: "MOP";
    readonly Mur: "MUR";
    readonly Mxn: "MXN";
    readonly Myr: "MYR";
    readonly Mzn: "MZN";
    readonly Nad: "NAD";
    readonly Ngn: "NGN";
    readonly Nio: "NIO";
    readonly Nok: "NOK";
    readonly Npr: "NPR";
    readonly Nzd: "NZD";
    readonly Omr: "OMR";
    readonly Pab: "PAB";
    readonly Pen: "PEN";
    readonly Php: "PHP";
    readonly Pkr: "PKR";
    readonly Pln: "PLN";
    readonly Pyg: "PYG";
    readonly Qar: "QAR";
    readonly Ron: "RON";
    readonly Rsd: "RSD";
    readonly Rub: "RUB";
    readonly Rwf: "RWF";
    readonly Sar: "SAR";
    readonly Sdg: "SDG";
    readonly Sek: "SEK";
    readonly Sgd: "SGD";
    readonly Sos: "SOS";
    readonly Syp: "SYP";
    readonly Thb: "THB";
    readonly Tnd: "TND";
    readonly Top: "TOP";
    readonly Try: "TRY";
    readonly Ttd: "TTD";
    readonly Twd: "TWD";
    readonly Tzs: "TZS";
    readonly Uah: "UAH";
    readonly Ugx: "UGX";
    readonly Uyu: "UYU";
    readonly Uzs: "UZS";
    readonly Vef: "VEF";
    readonly Vnd: "VND";
    readonly Xaf: "XAF";
    readonly Xof: "XOF";
    readonly Yer: "YER";
    readonly Zar: "ZAR";
    readonly Zmk: "ZMK";
};
export type CurrencyCodes = typeof CurrencyCodes[keyof typeof CurrencyCodes];
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof CustomField
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof CustomField
     */
    'value'?: string | null;
    /**
     * Label of the custom field
     * @type {string}
     * @memberof CustomField
     */
    'label'?: string;
}
/**
 *
 * @export
 * @interface DeleteFraudRule200Response
 */
export interface DeleteFraudRule200Response {
    /**
     * A description of the result
     * @type {string}
     * @memberof DeleteFraudRule200Response
     */
    'message': string;
}
/**
 * Details on how the reward is delivered to the recipient.
 * @export
 * @interface DeliveryDetails
 */
export interface DeliveryDetails {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof DeliveryDetails
     */
    'method': DeliveryDetailsMethodEnum;
    /**
     * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled.
     * @type {string}
     * @memberof DeliveryDetails
     */
    'status': DeliveryDetailsStatusEnum;
}
export declare const DeliveryDetailsMethodEnum: {
    readonly Email: "EMAIL";
    readonly Link: "LINK";
    readonly Phone: "PHONE";
};
export type DeliveryDetailsMethodEnum = typeof DeliveryDetailsMethodEnum[keyof typeof DeliveryDetailsMethodEnum];
export declare const DeliveryDetailsStatusEnum: {
    readonly Scheduled: "SCHEDULED";
    readonly Failed: "FAILED";
    readonly Succeeded: "SUCCEEDED";
    readonly Pending: "PENDING";
};
export type DeliveryDetailsStatusEnum = typeof DeliveryDetailsStatusEnum[keyof typeof DeliveryDetailsStatusEnum];
/**
 * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table>
 * @export
 * @enum {string}
 */
export declare const DeliveryMethod: {
    readonly Email: "EMAIL";
    readonly Link: "LINK";
    readonly Phone: "PHONE";
};
export type DeliveryMethod = typeof DeliveryMethod[keyof typeof DeliveryMethod];
/**
 * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled.
 * @export
 * @enum {string}
 */
export declare const DeliveryStatus: {
    readonly Scheduled: "SCHEDULED";
    readonly Failed: "FAILED";
    readonly Succeeded: "SUCCEEDED";
    readonly Pending: "PENDING";
};
export type DeliveryStatus = typeof DeliveryStatus[keyof typeof DeliveryStatus];
/**
 *
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof ErrorModel
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 *
 * @export
 * @interface Field
 */
export interface Field {
    /**
     *
     * @type {string}
     * @memberof Field
     */
    'id'?: string;
    /**
     * Label of the field
     * @type {string}
     * @memberof Field
     */
    'label'?: string;
    /**
     * Type of the values of the field
     * @type {string}
     * @memberof Field
     */
    'data_type'?: string;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof Field
     */
    'data'?: {
        [key: string]: any;
    };
    /**
     * Is this field required (true) or optional (false)
     * @type {boolean}
     * @memberof Field
     */
    'required'?: boolean;
    /**
     * Type of objects this field gets associated with
     * @type {string}
     * @memberof Field
     */
    'scope'?: string;
}
/**
 *
 * @export
 * @interface FraudConfigAllowEmail
 */
export interface FraudConfigAllowEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof FraudConfigAllowEmail
     */
    'emails': Array<string>;
}
/**
 *
 * @export
 * @interface FraudConfigCountry
 */
export interface FraudConfigCountry {
    /**
     * When type is `whitelist`, it flags any countries that *are not* present in the list. When type is `blacklist`, it flags any countries that *are* present in the list.
     * @type {string}
     * @memberof FraudConfigCountry
     */
    'type': FraudConfigCountryTypeEnum;
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof FraudConfigCountry
     */
    'countries': Array<string>;
}
export declare const FraudConfigCountryTypeEnum: {
    readonly Whitelist: "whitelist";
    readonly Blacklist: "blacklist";
};
export type FraudConfigCountryTypeEnum = typeof FraudConfigCountryTypeEnum[keyof typeof FraudConfigCountryTypeEnum];
/**
 *
 * @export
 * @interface FraudConfigCountryUpdateList
 */
export interface FraudConfigCountryUpdateList {
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof FraudConfigCountryUpdateList
     */
    'countries': Array<string>;
}
/**
 *
 * @export
 * @interface FraudConfigIP
 */
export interface FraudConfigIP {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof FraudConfigIP
     */
    'ips': Array<string>;
}
/**
 *
 * @export
 * @interface FraudConfigRedeemedRewardsAmount
 */
export interface FraudConfigRedeemedRewardsAmount {
    /**
     * The total amount in USD of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof FraudConfigRedeemedRewardsAmount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof FraudConfigRedeemedRewardsAmount
     */
    'period': FraudConfigRedeemedRewardsAmountPeriodEnum;
}
export declare const FraudConfigRedeemedRewardsAmountPeriodEnum: {
    readonly _7: "7";
    readonly _30: "30";
    readonly _90: "90";
    readonly _120: "120";
    readonly _365: "365";
    readonly AllTime: "all_time";
};
export type FraudConfigRedeemedRewardsAmountPeriodEnum = typeof FraudConfigRedeemedRewardsAmountPeriodEnum[keyof typeof FraudConfigRedeemedRewardsAmountPeriodEnum];
/**
 *
 * @export
 * @interface FraudConfigRedeemedRewardsCount
 */
export interface FraudConfigRedeemedRewardsCount {
    /**
     * The number of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof FraudConfigRedeemedRewardsCount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof FraudConfigRedeemedRewardsCount
     */
    'period': FraudConfigRedeemedRewardsCountPeriodEnum;
}
export declare const FraudConfigRedeemedRewardsCountPeriodEnum: {
    readonly _7: "7";
    readonly _30: "30";
    readonly _90: "90";
    readonly _120: "120";
    readonly _365: "365";
    readonly AllTime: "all_time";
};
export type FraudConfigRedeemedRewardsCountPeriodEnum = typeof FraudConfigRedeemedRewardsCountPeriodEnum[keyof typeof FraudConfigRedeemedRewardsCountPeriodEnum];
/**
 *
 * @export
 * @interface FraudConfigReviewEmail
 */
export interface FraudConfigReviewEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof FraudConfigReviewEmail
     */
    'emails'?: Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof FraudConfigReviewEmail
     */
    'domains'?: Array<string>;
}
/**
 *
 * @export
 * @interface FraudGenericResponse
 */
export interface FraudGenericResponse {
    /**
     * A description of the result
     * @type {string}
     * @memberof FraudGenericResponse
     */
    'message': string;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface FraudReview
 */
export interface FraudReview {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released.
     * @type {string}
     * @memberof FraudReview
     */
    'status'?: FraudReviewStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email`
     * @type {Array<string>}
     * @memberof FraudReview
     */
    'reasons'?: Array<FraudReviewReasonsEnum>;
    /**
     * The name of the person who reviewed the reward, or `Automatic Review` if the reward was blocked automatically. Rewards can be automatically blocked if they remain in the flagged fraud queue for more than 30 days.  This field is only present if the status is not `flagged`.
     * @type {string}
     * @memberof FraudReview
     */
    'reviewed_by'?: string;
    /**
     * When the reward was blocked or released following fraud review.  This field is only present if the status is not `flagged`.
     * @type {string}
     * @memberof FraudReview
     */
    'reviewed_at'?: string;
    /**
     *
     * @type {GetFraudReview200ResponseFraudReviewRelatedRewards}
     * @memberof FraudReview
     */
    'related_rewards'?: GetFraudReview200ResponseFraudReviewRelatedRewards;
    /**
     * The device fingerprint, if known.
     * @type {string}
     * @memberof FraudReview
     */
    'device_id'?: string;
    /**
     * The product selected to claim the reward
     * @type {string}
     * @memberof FraudReview
     */
    'redemption_method'?: FraudReviewRedemptionMethodEnum;
    /**
     * Date the reward was redeemed
     * @type {string}
     * @memberof FraudReview
     */
    'redeemed_at'?: string;
    /**
     *
     * @type {GetFraudReview200ResponseFraudReviewGeo}
     * @memberof FraudReview
     */
    'geo'?: GetFraudReview200ResponseFraudReviewGeo;
    /**
     *
     * @type {OrderWithoutLinkReward}
     * @memberof FraudReview
     */
    'reward'?: OrderWithoutLinkReward;
}
export declare const FraudReviewStatusEnum: {
    readonly Flagged: "flagged";
    readonly Blocked: "blocked";
    readonly Released: "released";
};
export type FraudReviewStatusEnum = typeof FraudReviewStatusEnum[keyof typeof FraudReviewStatusEnum];
export declare const FraudReviewReasonsEnum: {
    readonly DisallowedIp: "Disallowed IP";
    readonly DisallowedEmail: "Disallowed email";
    readonly DisallowedCountry: "Disallowed country";
    readonly OverRewardDollarLimit: "Over reward dollar limit";
    readonly OverRewardCountLimit: "Over reward count limit";
    readonly VpnDetected: "VPN detected";
    readonly DeviceRelatedToMultipleEmails: "Device related to multiple emails";
    readonly DeviceOrAccountRelatedToMultipleEmails: "Device or account related to multiple emails";
    readonly IpOnATremendousFraudList: "IP on a Tremendous fraud list";
    readonly BankAccountOnATremendousFraudList: "Bank account on a Tremendous fraud list";
    readonly FingerprintOnATremendousFraudList: "Fingerprint on a Tremendous fraud list";
    readonly EmailOnATremendousFraudList: "Email on a Tremendous fraud list";
    readonly PhoneOnATremendousFraudList: "Phone on a Tremendous fraud list";
    readonly IpRelatedToABlockedReward: "IP related to a blocked reward";
    readonly BankAccountRelatedToABlockedReward: "Bank account related to a blocked reward";
    readonly FingerprintRelatedToABlockedReward: "Fingerprint related to a blocked reward";
    readonly EmailRelatedToABlockedReward: "Email related to a blocked reward";
    readonly PhoneRelatedToABlockedReward: "Phone related to a blocked reward";
    readonly AllowedIp: "Allowed IP";
    readonly AllowedEmail: "Allowed email";
};
export type FraudReviewReasonsEnum = typeof FraudReviewReasonsEnum[keyof typeof FraudReviewReasonsEnum];
export declare const FraudReviewRedemptionMethodEnum: {
    readonly Paypal: "paypal";
    readonly Bank: "bank";
    readonly MerchantCard: "merchant card";
    readonly VisaCard: "visa card";
    readonly Charity: "charity";
    readonly Venmo: "venmo";
};
export type FraudReviewRedemptionMethodEnum = typeof FraudReviewRedemptionMethodEnum[keyof typeof FraudReviewRedemptionMethodEnum];
/**
 *
 * @export
 * @interface FraudReviewGeo
 */
export interface FraudReviewGeo {
    /**
     * The recipient\'s IP.
     * @type {string}
     * @memberof FraudReviewGeo
     */
    'ip'?: string;
    /**
     * The country code (ISO-3166 alpha-2 character code) linked to the recipient\'s IP.
     * @type {string}
     * @memberof FraudReviewGeo
     */
    'country'?: string;
    /**
     * The city associated with the recipient\'s IP.
     * @type {string}
     * @memberof FraudReviewGeo
     */
    'city'?: string;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface FraudReviewListItem
 */
export interface FraudReviewListItem {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released.
     * @type {string}
     * @memberof FraudReviewListItem
     */
    'status'?: FraudReviewListItemStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email`
     * @type {Array<string>}
     * @memberof FraudReviewListItem
     */
    'reasons'?: Array<FraudReviewListItemReasonsEnum>;
    /**
     *
     * @type {OrderWithoutLinkReward}
     * @memberof FraudReviewListItem
     */
    'reward'?: OrderWithoutLinkReward;
}
export declare const FraudReviewListItemStatusEnum: {
    readonly Flagged: "flagged";
    readonly Blocked: "blocked";
    readonly Released: "released";
};
export type FraudReviewListItemStatusEnum = typeof FraudReviewListItemStatusEnum[keyof typeof FraudReviewListItemStatusEnum];
export declare const FraudReviewListItemReasonsEnum: {
    readonly DisallowedIp: "Disallowed IP";
    readonly DisallowedEmail: "Disallowed email";
    readonly DisallowedCountry: "Disallowed country";
    readonly OverRewardDollarLimit: "Over reward dollar limit";
    readonly OverRewardCountLimit: "Over reward count limit";
    readonly VpnDetected: "VPN detected";
    readonly DeviceRelatedToMultipleEmails: "Device related to multiple emails";
    readonly DeviceOrAccountRelatedToMultipleEmails: "Device or account related to multiple emails";
    readonly IpOnATremendousFraudList: "IP on a Tremendous fraud list";
    readonly BankAccountOnATremendousFraudList: "Bank account on a Tremendous fraud list";
    readonly FingerprintOnATremendousFraudList: "Fingerprint on a Tremendous fraud list";
    readonly EmailOnATremendousFraudList: "Email on a Tremendous fraud list";
    readonly PhoneOnATremendousFraudList: "Phone on a Tremendous fraud list";
    readonly IpRelatedToABlockedReward: "IP related to a blocked reward";
    readonly BankAccountRelatedToABlockedReward: "Bank account related to a blocked reward";
    readonly FingerprintRelatedToABlockedReward: "Fingerprint related to a blocked reward";
    readonly EmailRelatedToABlockedReward: "Email related to a blocked reward";
    readonly PhoneRelatedToABlockedReward: "Phone related to a blocked reward";
    readonly AllowedIp: "Allowed IP";
    readonly AllowedEmail: "Allowed email";
};
export type FraudReviewListItemReasonsEnum = typeof FraudReviewListItemReasonsEnum[keyof typeof FraudReviewListItemReasonsEnum];
/**
 *
 * @export
 * @enum {string}
 */
export declare const FraudReviewReason: {
    readonly DisallowedIp: "Disallowed IP";
    readonly DisallowedEmail: "Disallowed email";
    readonly DisallowedCountry: "Disallowed country";
    readonly OverRewardDollarLimit: "Over reward dollar limit";
    readonly OverRewardCountLimit: "Over reward count limit";
    readonly VpnDetected: "VPN detected";
    readonly DeviceRelatedToMultipleEmails: "Device related to multiple emails";
    readonly DeviceOrAccountRelatedToMultipleEmails: "Device or account related to multiple emails";
    readonly IpOnATremendousFraudList: "IP on a Tremendous fraud list";
    readonly BankAccountOnATremendousFraudList: "Bank account on a Tremendous fraud list";
    readonly FingerprintOnATremendousFraudList: "Fingerprint on a Tremendous fraud list";
    readonly EmailOnATremendousFraudList: "Email on a Tremendous fraud list";
    readonly PhoneOnATremendousFraudList: "Phone on a Tremendous fraud list";
    readonly IpRelatedToABlockedReward: "IP related to a blocked reward";
    readonly BankAccountRelatedToABlockedReward: "Bank account related to a blocked reward";
    readonly FingerprintRelatedToABlockedReward: "Fingerprint related to a blocked reward";
    readonly EmailRelatedToABlockedReward: "Email related to a blocked reward";
    readonly PhoneRelatedToABlockedReward: "Phone related to a blocked reward";
    readonly AllowedIp: "Allowed IP";
    readonly AllowedEmail: "Allowed email";
};
export type FraudReviewReason = typeof FraudReviewReason[keyof typeof FraudReviewReason];
/**
 *
 * @export
 * @enum {string}
 */
export declare const FraudReviewRedemptionMethod: {
    readonly Paypal: "paypal";
    readonly Bank: "bank";
    readonly MerchantCard: "merchant card";
    readonly VisaCard: "visa card";
    readonly Charity: "charity";
    readonly Venmo: "venmo";
};
export type FraudReviewRedemptionMethod = typeof FraudReviewRedemptionMethod[keyof typeof FraudReviewRedemptionMethod];
/**
 *
 * @export
 * @interface FraudReviewRelatedRewards
 */
export interface FraudReviewRelatedRewards {
    /**
     * The IDs of rewards that have similar attributes to the fraud reward. A maximum of 100 IDs is returned.
     * @type {Array<string>}
     * @memberof FraudReviewRelatedRewards
     */
    'ids'?: Array<string>;
    /**
     * How many related rewards were found in total.
     * @type {number}
     * @memberof FraudReviewRelatedRewards
     */
    'count'?: number;
    /**
     * How many related rewards have been blocked.
     * @type {number}
     * @memberof FraudReviewRelatedRewards
     */
    'blocked_count'?: number;
    /**
     * Total amount claimed by the related rewards (in USD).
     * @type {number}
     * @memberof FraudReviewRelatedRewards
     */
    'aggregated_value'?: number;
}
/**
 * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released.
 * @export
 * @enum {string}
 */
export declare const FraudReviewStatus: {
    readonly Flagged: "flagged";
    readonly Blocked: "blocked";
    readonly Released: "released";
};
export type FraudReviewStatus = typeof FraudReviewStatus[keyof typeof FraudReviewStatus];
/**
 *
 * @export
 * @interface FraudRule200Response
 */
export interface FraudRule200Response {
    /**
     * A description of the result
     * @type {string}
     * @memberof FraudRule200Response
     */
    'message': string;
}
/**
 *
 * @export
 * @interface FraudRule400Response
 */
export interface FraudRule400Response {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof FraudRule400Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 *
 * @export
 * @interface FraudRule422Response
 */
export interface FraudRule422Response {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof FraudRule422Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 *
 * @export
 * @interface FraudRuleRequest
 */
export interface FraudRuleRequest {
    /**
     *
     * @type {FraudRuleRequestConfig}
     * @memberof FraudRuleRequest
     */
    'config'?: FraudRuleRequestConfig;
}
/**
 * The configuration associated with the rule. The properties allowed depend on the type of rule.
 * @export
 * @interface FraudRuleRequestConfig
 */
export interface FraudRuleRequestConfig {
    /**
     * When type is `whitelist`, it flags any countries that *are not* present in the list. When type is `blacklist`, it flags any countries that *are* present in the list.
     * @type {string}
     * @memberof FraudRuleRequestConfig
     */
    'type': FraudRuleRequestConfigTypeEnum;
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'countries': Array<string>;
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'ips': Array<string>;
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'emails': Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof FraudRuleRequestConfig
     */
    'domains'?: Array<string>;
    /**
     * The total amount in USD of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof FraudRuleRequestConfig
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof FraudRuleRequestConfig
     */
    'period': FraudRuleRequestConfigPeriodEnum;
}
export declare const FraudRuleRequestConfigTypeEnum: {
    readonly Whitelist: "whitelist";
    readonly Blacklist: "blacklist";
};
export type FraudRuleRequestConfigTypeEnum = typeof FraudRuleRequestConfigTypeEnum[keyof typeof FraudRuleRequestConfigTypeEnum];
export declare const FraudRuleRequestConfigPeriodEnum: {
    readonly _7: "7";
    readonly _30: "30";
    readonly _90: "90";
    readonly _120: "120";
    readonly _365: "365";
    readonly AllTime: "all_time";
};
export type FraudRuleRequestConfigPeriodEnum = typeof FraudRuleRequestConfigPeriodEnum[keyof typeof FraudRuleRequestConfigPeriodEnum];
/**
 * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list
 * @export
 * @enum {string}
 */
export declare const FraudRuleType: {
    readonly ReviewCountry: "review_country";
    readonly ReviewIp: "review_ip";
    readonly ReviewEmail: "review_email";
    readonly ReviewRedeemedRewardsCount: "review_redeemed_rewards_count";
    readonly ReviewRedeemedRewardsAmount: "review_redeemed_rewards_amount";
    readonly ReviewMultipleEmails: "review_multiple_emails";
    readonly ReviewVpn: "review_vpn";
    readonly ReviewTremendousFlagList: "review_tremendous_flag_list";
    readonly ReviewPreviouslyBlockedRecipients: "review_previously_blocked_recipients";
    readonly AllowIp: "allow_ip";
    readonly AllowEmail: "allow_email";
};
export type FraudRuleType = typeof FraudRuleType[keyof typeof FraudRuleType];
/**
 * An active fraud rule
 * @export
 * @interface FraudRulesListItem
 */
export interface FraudRulesListItem {
    /**
     * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list
     * @type {string}
     * @memberof FraudRulesListItem
     */
    'rule_type'?: FraudRulesListItemRuleTypeEnum;
    /**
     * The configuration associated with the rule. The properties allowed depend on the type of rule. This property is only present for rules that require configuration.
     * @type {object}
     * @memberof FraudRulesListItem
     */
    'config'?: object | null;
}
export declare const FraudRulesListItemRuleTypeEnum: {
    readonly ReviewCountry: "review_country";
    readonly ReviewIp: "review_ip";
    readonly ReviewEmail: "review_email";
    readonly ReviewRedeemedRewardsCount: "review_redeemed_rewards_count";
    readonly ReviewRedeemedRewardsAmount: "review_redeemed_rewards_amount";
    readonly ReviewMultipleEmails: "review_multiple_emails";
    readonly ReviewVpn: "review_vpn";
    readonly ReviewTremendousFlagList: "review_tremendous_flag_list";
    readonly ReviewPreviouslyBlockedRecipients: "review_previously_blocked_recipients";
    readonly AllowIp: "allow_ip";
    readonly AllowEmail: "allow_email";
};
export type FraudRulesListItemRuleTypeEnum = typeof FraudRulesListItemRuleTypeEnum[keyof typeof FraudRulesListItemRuleTypeEnum];
/**
 *
 * @export
 * @interface FundingSource
 */
export interface FundingSource {
    /**
     *
     * @type {string}
     * @memberof FundingSource
     */
    'id': string;
    /**
     * You can pay for rewards using different payment methods on Tremendous:  <table>   <thead>     <tr>       <th>Payment Method</th>       <th>Description</th>       </tr>   </thead>   <tbody>     <tr>       <td><code>balance</code></td>       <td>Pre-funded balance in your Tremendous account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>bank_account</code></td>       <td>Bank account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>credit_card</code></td>       <td>Credit card to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>invoice</code></td>       <td>Send rewards to recipients and pay by invoice.</td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof FundingSource
     */
    'method': FundingSourceMethodEnum;
    /**
     * **Only available when `method` is set to `invoice`.**
     * @type {string}
     * @memberof FundingSource
     */
    'type'?: FundingSourceTypeEnum;
    /**
     *
     * @type {ListFundingSources200ResponseFundingSourcesInnerMeta}
     * @memberof FundingSource
     */
    'meta': ListFundingSources200ResponseFundingSourcesInnerMeta;
}
export declare const FundingSourceMethodEnum: {
    readonly Balance: "balance";
    readonly BankAccount: "bank_account";
    readonly CreditCard: "credit_card";
    readonly Invoice: "invoice";
};
export type FundingSourceMethodEnum = typeof FundingSourceMethodEnum[keyof typeof FundingSourceMethodEnum];
export declare const FundingSourceTypeEnum: {
    readonly Commercial: "COMMERCIAL";
    readonly ProForma: "PRO_FORMA";
    readonly PrefundingOnly: "PREFUNDING_ONLY";
};
export type FundingSourceTypeEnum = typeof FundingSourceTypeEnum[keyof typeof FundingSourceTypeEnum];
/**
 *
 * @export
 * @interface GenerateRewardLink200Response
 */
export interface GenerateRewardLink200Response {
    /**
     *
     * @type {GenerateRewardLink200ResponseReward}
     * @memberof GenerateRewardLink200Response
     */
    'reward': GenerateRewardLink200ResponseReward;
}
/**
 * The redemption link for a reward.
 * @export
 * @interface GenerateRewardLink200ResponseReward
 */
export interface GenerateRewardLink200ResponseReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof GenerateRewardLink200ResponseReward
     */
    'id'?: string;
    /**
     * Link to redeem the reward at. You need to deliver this link to the recipient.
     * @type {string}
     * @memberof GenerateRewardLink200ResponseReward
     */
    'link'?: string;
}
/**
 *
 * @export
 * @interface GenerateRewardLink403Response
 */
export interface GenerateRewardLink403Response {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof GenerateRewardLink403Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 *
 * @export
 * @interface GenerateRewardToken200Response
 */
export interface GenerateRewardToken200Response {
    /**
     *
     * @type {GenerateRewardToken200ResponseReward}
     * @memberof GenerateRewardToken200Response
     */
    'reward': GenerateRewardToken200ResponseReward;
}
/**
 * The redemption token for a reward.
 * @export
 * @interface GenerateRewardToken200ResponseReward
 */
export interface GenerateRewardToken200ResponseReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof GenerateRewardToken200ResponseReward
     */
    'id'?: string;
    /**
     * The token to redeem the reward.
     * @type {string}
     * @memberof GenerateRewardToken200ResponseReward
     */
    'token'?: string;
    /**
     * Date the token expires
     * @type {string}
     * @memberof GenerateRewardToken200ResponseReward
     */
    'expires_at'?: string;
}
/**
 *
 * @export
 * @interface GetFraudReview200Response
 */
export interface GetFraudReview200Response {
    /**
     *
     * @type {GetFraudReview200ResponseFraudReview}
     * @memberof GetFraudReview200Response
     */
    'fraud_review': GetFraudReview200ResponseFraudReview;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface GetFraudReview200ResponseFraudReview
 */
export interface GetFraudReview200ResponseFraudReview {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'status'?: GetFraudReview200ResponseFraudReviewStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email`
     * @type {Array<string>}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reasons'?: Array<GetFraudReview200ResponseFraudReviewReasonsEnum>;
    /**
     * The name of the person who reviewed the reward, or `Automatic Review` if the reward was blocked automatically. Rewards can be automatically blocked if they remain in the flagged fraud queue for more than 30 days.  This field is only present if the status is not `flagged`.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reviewed_by'?: string;
    /**
     * When the reward was blocked or released following fraud review.  This field is only present if the status is not `flagged`.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reviewed_at'?: string;
    /**
     *
     * @type {GetFraudReview200ResponseFraudReviewRelatedRewards}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'related_rewards'?: GetFraudReview200ResponseFraudReviewRelatedRewards;
    /**
     * The device fingerprint, if known.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'device_id'?: string;
    /**
     * The product selected to claim the reward
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'redemption_method'?: GetFraudReview200ResponseFraudReviewRedemptionMethodEnum;
    /**
     * Date the reward was redeemed
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'redeemed_at'?: string;
    /**
     *
     * @type {GetFraudReview200ResponseFraudReviewGeo}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'geo'?: GetFraudReview200ResponseFraudReviewGeo;
    /**
     *
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof GetFraudReview200ResponseFraudReview
     */
    'reward'?: ListRewards200ResponseRewardsInner;
}
export declare const GetFraudReview200ResponseFraudReviewStatusEnum: {
    readonly Flagged: "flagged";
    readonly Blocked: "blocked";
    readonly Released: "released";
};
export type GetFraudReview200ResponseFraudReviewStatusEnum = typeof GetFraudReview200ResponseFraudReviewStatusEnum[keyof typeof GetFraudReview200ResponseFraudReviewStatusEnum];
export declare const GetFraudReview200ResponseFraudReviewReasonsEnum: {
    readonly DisallowedIp: "Disallowed IP";
    readonly DisallowedEmail: "Disallowed email";
    readonly DisallowedCountry: "Disallowed country";
    readonly OverRewardDollarLimit: "Over reward dollar limit";
    readonly OverRewardCountLimit: "Over reward count limit";
    readonly VpnDetected: "VPN detected";
    readonly DeviceRelatedToMultipleEmails: "Device related to multiple emails";
    readonly DeviceOrAccountRelatedToMultipleEmails: "Device or account related to multiple emails";
    readonly IpOnATremendousFraudList: "IP on a Tremendous fraud list";
    readonly BankAccountOnATremendousFraudList: "Bank account on a Tremendous fraud list";
    readonly FingerprintOnATremendousFraudList: "Fingerprint on a Tremendous fraud list";
    readonly EmailOnATremendousFraudList: "Email on a Tremendous fraud list";
    readonly PhoneOnATremendousFraudList: "Phone on a Tremendous fraud list";
    readonly IpRelatedToABlockedReward: "IP related to a blocked reward";
    readonly BankAccountRelatedToABlockedReward: "Bank account related to a blocked reward";
    readonly FingerprintRelatedToABlockedReward: "Fingerprint related to a blocked reward";
    readonly EmailRelatedToABlockedReward: "Email related to a blocked reward";
    readonly PhoneRelatedToABlockedReward: "Phone related to a blocked reward";
    readonly AllowedIp: "Allowed IP";
    readonly AllowedEmail: "Allowed email";
};
export type GetFraudReview200ResponseFraudReviewReasonsEnum = typeof GetFraudReview200ResponseFraudReviewReasonsEnum[keyof typeof GetFraudReview200ResponseFraudReviewReasonsEnum];
export declare const GetFraudReview200ResponseFraudReviewRedemptionMethodEnum: {
    readonly Paypal: "paypal";
    readonly Bank: "bank";
    readonly MerchantCard: "merchant card";
    readonly VisaCard: "visa card";
    readonly Charity: "charity";
    readonly Venmo: "venmo";
};
export type GetFraudReview200ResponseFraudReviewRedemptionMethodEnum = typeof GetFraudReview200ResponseFraudReviewRedemptionMethodEnum[keyof typeof GetFraudReview200ResponseFraudReviewRedemptionMethodEnum];
/**
 * The Geo location, based on the recipient\'s IP.
 * @export
 * @interface GetFraudReview200ResponseFraudReviewGeo
 */
export interface GetFraudReview200ResponseFraudReviewGeo {
    /**
     * The recipient\'s IP.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReviewGeo
     */
    'ip'?: string;
    /**
     * The country code (ISO-3166 alpha-2 character code) linked to the recipient\'s IP.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReviewGeo
     */
    'country'?: string;
    /**
     * The city associated with the recipient\'s IP.
     * @type {string}
     * @memberof GetFraudReview200ResponseFraudReviewGeo
     */
    'city'?: string;
}
/**
 * The related rewards associated with the fraud review.
 * @export
 * @interface GetFraudReview200ResponseFraudReviewRelatedRewards
 */
export interface GetFraudReview200ResponseFraudReviewRelatedRewards {
    /**
     * The IDs of rewards that have similar attributes to the fraud reward. A maximum of 100 IDs is returned.
     * @type {Array<string>}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'ids'?: Array<string>;
    /**
     * How many related rewards were found in total.
     * @type {number}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'count'?: number;
    /**
     * How many related rewards have been blocked.
     * @type {number}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'blocked_count'?: number;
    /**
     * Total amount claimed by the related rewards (in USD).
     * @type {number}
     * @memberof GetFraudReview200ResponseFraudReviewRelatedRewards
     */
    'aggregated_value'?: number;
}
/**
 *
 * @export
 * @interface GetFundingSource200Response
 */
export interface GetFundingSource200Response {
    /**
     *
     * @type {ListFundingSources200ResponseFundingSourcesInner}
     * @memberof GetFundingSource200Response
     */
    'funding_source': ListFundingSources200ResponseFundingSourcesInner;
}
/**
 *
 * @export
 * @interface GetMember200Response
 */
export interface GetMember200Response {
    /**
     *
     * @type {GetMember200ResponseMember}
     * @memberof GetMember200Response
     */
    'member': GetMember200ResponseMember;
}
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more.
 * @export
 * @interface GetMember200ResponseMember
 */
export interface GetMember200ResponseMember {
    /**
     *
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization.
     * @type {boolean}
     * @memberof GetMember200ResponseMember
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization.
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`.
     * @type {string}
     * @memberof GetMember200ResponseMember
     */
    'status': GetMember200ResponseMemberStatusEnum;
    /**
     * List of events related to the member.
     * @type {Array<GetMember200ResponseMemberEventsInner>}
     * @memberof GetMember200ResponseMember
     */
    'events'?: Array<GetMember200ResponseMemberEventsInner>;
}
export declare const GetMember200ResponseMemberStatusEnum: {
    readonly Registered: "REGISTERED";
    readonly Invited: "INVITED";
};
export type GetMember200ResponseMemberStatusEnum = typeof GetMember200ResponseMemberStatusEnum[keyof typeof GetMember200ResponseMemberStatusEnum];
/**
 *
 * @export
 * @interface GetMember200ResponseMemberEventsInner
 */
export interface GetMember200ResponseMemberEventsInner {
    /**
     * Event type
     * @type {string}
     * @memberof GetMember200ResponseMemberEventsInner
     */
    'type'?: GetMember200ResponseMemberEventsInnerTypeEnum;
    /**
     * Timestamp when the event happened
     * @type {string}
     * @memberof GetMember200ResponseMemberEventsInner
     */
    'date_utc'?: string | null;
}
export declare const GetMember200ResponseMemberEventsInnerTypeEnum: {
    readonly Created: "created";
    readonly LastLogin: "last_login";
};
export type GetMember200ResponseMemberEventsInnerTypeEnum = typeof GetMember200ResponseMemberEventsInnerTypeEnum[keyof typeof GetMember200ResponseMemberEventsInnerTypeEnum];
/**
 *
 * @export
 * @interface GetOrganization200Response
 */
export interface GetOrganization200Response {
    /**
     *
     * @type {ListOrganizations200ResponseOrganizationsInner}
     * @memberof GetOrganization200Response
     */
    'organization'?: ListOrganizations200ResponseOrganizationsInner;
}
/**
 *
 * @export
 * @interface GetProductResponse
 */
export interface GetProductResponse {
    /**
     *
     * @type {ListProductsResponseProductsInner}
     * @memberof GetProductResponse
     */
    'product': ListProductsResponseProductsInner;
}
/**
 *
 * @export
 * @interface GetReward200Response
 */
export interface GetReward200Response {
    /**
     *
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof GetReward200Response
     */
    'reward': ListRewards200ResponseRewardsInner;
}
/**
 * Invoices are instruments to fund your Tremendous account\'s balance.  Invoices can be created by your organization programatically. Once we receive your payment, the invoice is marked as `PAID` and we add the respective funds to your account\'s balance.
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * The invoice number
     * @type {string}
     * @memberof Invoice
     */
    'id': string;
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof Invoice
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof Invoice
     */
    'amount': number;
    /**
     * Status of this invoice  <table>   <thead>     <tr>       <th>Status</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>DELETED</code></td>       <td>Invoice has been deleted by your organization</td>     </tr>     <tr>       <td><code>PAID</code></td>       <td>Invoice has been paid by your organization</td>     </tr>     <tr>       <td><code>OPEN</code></td>       <td>Invoice has been created by your organization but has not been paid, yet</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
    /**
     * List of orders related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof Invoice
     */
    'orders'?: Array<string>;
    /**
     * List of rewards related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof Invoice
     */
    'rewards'?: Array<string>;
    /**
     * Timestamp of when the invoice has been created.
     * @type {string}
     * @memberof Invoice
     */
    'created_at': string;
    /**
     * Timestamp of when the invoice has been paid.
     * @type {string}
     * @memberof Invoice
     */
    'paid_at': string | null;
}
export declare const InvoiceStatusEnum: {
    readonly Deleted: "DELETED";
    readonly Paid: "PAID";
    readonly Open: "OPEN";
    readonly MarkedAsPaid: "MARKED_AS_PAID";
};
export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];
/**
 *
 * @export
 * @interface ListBalanceTransactions200Response
 */
export interface ListBalanceTransactions200Response {
    /**
     *
     * @type {Array<ListBalanceTransactions200ResponseInvoicesInner>}
     * @memberof ListBalanceTransactions200Response
     */
    'invoices'?: Array<ListBalanceTransactions200ResponseInvoicesInner>;
}
/**
 * A balance transaction represents a specific movement or change in an account\'s balance.
 * @export
 * @interface ListBalanceTransactions200ResponseInvoicesInner
 */
export interface ListBalanceTransactions200ResponseInvoicesInner {
    /**
     * Date that the transaction was created
     * @type {string}
     * @memberof ListBalanceTransactions200ResponseInvoicesInner
     */
    'created_at'?: string;
    /**
     * Amount of the transaction in USD
     * @type {number}
     * @memberof ListBalanceTransactions200ResponseInvoicesInner
     */
    'amount'?: number;
    /**
     * The updated total after the transaction. Note that this running balance may be delayed and contain `null`.
     * @type {number}
     * @memberof ListBalanceTransactions200ResponseInvoicesInner
     */
    'balance'?: number;
    /**
     * The action that was performed
     * @type {string}
     * @memberof ListBalanceTransactions200ResponseInvoicesInner
     */
    'action'?: string;
    /**
     * A brief description of the transaction
     * @type {string}
     * @memberof ListBalanceTransactions200ResponseInvoicesInner
     */
    'description'?: string;
}
/**
 *
 * @export
 * @interface ListCampaigns200Response
 */
export interface ListCampaigns200Response {
    /**
     *
     * @type {Array<ListCampaigns200ResponseCampaignsInner>}
     * @memberof ListCampaigns200Response
     */
    'campaigns': Array<ListCampaigns200ResponseCampaignsInner>;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from.
 * @export
 * @interface ListCampaigns200ResponseCampaignsInner
 */
export interface ListCampaigns200ResponseCampaignsInner {
    /**
     *
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'name': string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'description': string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign.
     * @type {Array<string>}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'products': Array<string>;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof ListCampaigns200ResponseCampaignsInner
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * Definition of the email style
 * @export
 * @interface ListCampaigns200ResponseCampaignsInnerEmailStyle
 */
export interface ListCampaigns200ResponseCampaignsInnerEmailStyle {
    /**
     * If sending via email, this is how the email will appear to be sent from
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'sender_name'?: string | null;
    /**
     * Email subject line
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'subject_line'?: string | null;
    /**
     * URL of a publicly-accessible image (png, jpeg, jpg, gif, or svg). This image will be copied to our storage location.
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'logo_image_url'?: string | null;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'logo_image_height_px'?: number | null;
    /**
     * Logo backgrond color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'logo_background_color'?: string | null;
    /**
     * Button color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerEmailStyle
     */
    'button_color'?: string | null;
}
/**
 * Definition of the webpage style
 * @export
 * @interface ListCampaigns200ResponseCampaignsInnerWebpageStyle
 */
export interface ListCampaigns200ResponseCampaignsInnerWebpageStyle {
    /**
     * Headline for the reward page
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'headline'?: string | null;
    /**
     * Message for the reward page
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'message'?: string;
    /**
     * URL of a publicly-accessible image (png, jpeg, jpg, gif, or svg). This image will be copied to our storage location.
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'logo_image_url'?: string | null;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'logo_image_height_px'?: number | null;
    /**
     * Logo backgrond color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'logo_background_color'?: string | null;
    /**
     * Backgrond color code (hex, rgb, or rgba)
     * @type {string}
     * @memberof ListCampaigns200ResponseCampaignsInnerWebpageStyle
     */
    'background_color'?: string | null;
}
/**
 *
 * @export
 * @interface ListFields200Response
 */
export interface ListFields200Response {
    /**
     *
     * @type {Array<ListFields200ResponseFieldsInner>}
     * @memberof ListFields200Response
     */
    'fields'?: Array<ListFields200ResponseFieldsInner>;
}
/**
 *
 * @export
 * @interface ListFields200ResponseFieldsInner
 */
export interface ListFields200ResponseFieldsInner {
    /**
     *
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'id'?: string;
    /**
     * Label of the field
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'label'?: string;
    /**
     * Type of the values of the field
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'data_type'?: string;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof ListFields200ResponseFieldsInner
     */
    'data'?: {
        [key: string]: any;
    };
    /**
     * Is this field required (true) or optional (false)
     * @type {boolean}
     * @memberof ListFields200ResponseFieldsInner
     */
    'required'?: boolean;
    /**
     * Type of objects this field gets associated with
     * @type {string}
     * @memberof ListFields200ResponseFieldsInner
     */
    'scope'?: string;
}
/**
 *
 * @export
 * @interface ListForexResponse
 */
export interface ListForexResponse {
    /**
     *
     * @type {{ [key: string]: number; }}
     * @memberof ListForexResponse
     */
    'forex': {
        [key: string]: number;
    };
}
/**
 *
 * @export
 * @interface ListFraudReviews200Response
 */
export interface ListFraudReviews200Response {
    /**
     *
     * @type {Array<ListFraudReviews200ResponseFraudReviewsInner>}
     * @memberof ListFraudReviews200Response
     */
    'fraud_reviews': Array<ListFraudReviews200ResponseFraudReviewsInner>;
}
/**
 * The fraud review associated with a reward.
 * @export
 * @interface ListFraudReviews200ResponseFraudReviewsInner
 */
export interface ListFraudReviews200ResponseFraudReviewsInner {
    /**
     * The current status of the fraud review:  * `flagged` - The reward has been flagged for and waiting manual review. * `blocked` - The reward was reviewed and blocked. * `released` - The reward was reviewed and released.
     * @type {string}
     * @memberof ListFraudReviews200ResponseFraudReviewsInner
     */
    'status'?: ListFraudReviews200ResponseFraudReviewsInnerStatusEnum;
    /**
     * The array may contain multiple reasons, depending on which rule(s) flagged the reward for review. Reasons can be any of the following:  * `Disallowed IP` * `Disallowed email` * `Disallowed country` * `Over reward dollar limit` * `Over reward count limit` * `VPN detected` * `Device related to multiple emails` * `Device or account related to multiple emails` * `IP on a Tremendous fraud list` * `Bank account on a Tremendous fraud list` * `Fingerprint on a Tremendous fraud list` * `Email on a Tremendous fraud list` * `Phone on a Tremendous fraud list` * `IP related to a blocked reward` * `Bank account related to a blocked reward` * `Fingerprint related to a blocked reward` * `Email related to a blocked reward` * `Phone related to a blocked reward` * `Allowed IP` * `Allowed email`
     * @type {Array<string>}
     * @memberof ListFraudReviews200ResponseFraudReviewsInner
     */
    'reasons'?: Array<ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof ListFraudReviews200ResponseFraudReviewsInner
     */
    'reward'?: ListRewards200ResponseRewardsInner;
}
export declare const ListFraudReviews200ResponseFraudReviewsInnerStatusEnum: {
    readonly Flagged: "flagged";
    readonly Blocked: "blocked";
    readonly Released: "released";
};
export type ListFraudReviews200ResponseFraudReviewsInnerStatusEnum = typeof ListFraudReviews200ResponseFraudReviewsInnerStatusEnum[keyof typeof ListFraudReviews200ResponseFraudReviewsInnerStatusEnum];
export declare const ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum: {
    readonly DisallowedIp: "Disallowed IP";
    readonly DisallowedEmail: "Disallowed email";
    readonly DisallowedCountry: "Disallowed country";
    readonly OverRewardDollarLimit: "Over reward dollar limit";
    readonly OverRewardCountLimit: "Over reward count limit";
    readonly VpnDetected: "VPN detected";
    readonly DeviceRelatedToMultipleEmails: "Device related to multiple emails";
    readonly DeviceOrAccountRelatedToMultipleEmails: "Device or account related to multiple emails";
    readonly IpOnATremendousFraudList: "IP on a Tremendous fraud list";
    readonly BankAccountOnATremendousFraudList: "Bank account on a Tremendous fraud list";
    readonly FingerprintOnATremendousFraudList: "Fingerprint on a Tremendous fraud list";
    readonly EmailOnATremendousFraudList: "Email on a Tremendous fraud list";
    readonly PhoneOnATremendousFraudList: "Phone on a Tremendous fraud list";
    readonly IpRelatedToABlockedReward: "IP related to a blocked reward";
    readonly BankAccountRelatedToABlockedReward: "Bank account related to a blocked reward";
    readonly FingerprintRelatedToABlockedReward: "Fingerprint related to a blocked reward";
    readonly EmailRelatedToABlockedReward: "Email related to a blocked reward";
    readonly PhoneRelatedToABlockedReward: "Phone related to a blocked reward";
    readonly AllowedIp: "Allowed IP";
    readonly AllowedEmail: "Allowed email";
};
export type ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum = typeof ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum[keyof typeof ListFraudReviews200ResponseFraudReviewsInnerReasonsEnum];
/**
 *
 * @export
 * @interface ListFraudRules200Response
 */
export interface ListFraudRules200Response {
    /**
     *
     * @type {Array<ListFraudRules200ResponseFraudRulesInner>}
     * @memberof ListFraudRules200Response
     */
    'fraud_rules': Array<ListFraudRules200ResponseFraudRulesInner>;
}
/**
 * An active fraud rule
 * @export
 * @interface ListFraudRules200ResponseFraudRulesInner
 */
export interface ListFraudRules200ResponseFraudRulesInner {
    /**
     * * `review_country` - Flags when the recipient\'s IP country matches the criteria in the rule * `review_ip` - Flags when recipient\'s IP matches one in the list * `review_email` - Flags when the recipient\'s email matches one in the list * `review_redeemed_rewards_count` - Flags when the recipient redeemed more than the number of rewards specified in the config * `review_redeemed_rewards_amount` - Flags when the recipient redeemed more than the total amount specified in the config * `review_multiple_emails` - Flags when recipient\'s device or account has multiple emails associated * `review_vpn` - Flags when VPN is suspected * `review_tremendous_flag_list` - Flags rewards when redemption attributes match at least one criteria defined by the Tremendous flag list * `review_previously_blocked_recipients` - Flags rewards when the recipient has been blocked before * `allow_ip` - Releases a reward when a recipient\'s IP matches one in the list * `allow_email` - Releases a reward when the recipient\'s email matches one in the list
     * @type {string}
     * @memberof ListFraudRules200ResponseFraudRulesInner
     */
    'rule_type'?: ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum;
    /**
     * The configuration associated with the rule. The properties allowed depend on the type of rule. This property is only present for rules that require configuration.
     * @type {object}
     * @memberof ListFraudRules200ResponseFraudRulesInner
     */
    'config'?: object | null;
}
export declare const ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum: {
    readonly ReviewCountry: "review_country";
    readonly ReviewIp: "review_ip";
    readonly ReviewEmail: "review_email";
    readonly ReviewRedeemedRewardsCount: "review_redeemed_rewards_count";
    readonly ReviewRedeemedRewardsAmount: "review_redeemed_rewards_amount";
    readonly ReviewMultipleEmails: "review_multiple_emails";
    readonly ReviewVpn: "review_vpn";
    readonly ReviewTremendousFlagList: "review_tremendous_flag_list";
    readonly ReviewPreviouslyBlockedRecipients: "review_previously_blocked_recipients";
    readonly AllowIp: "allow_ip";
    readonly AllowEmail: "allow_email";
};
export type ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum = typeof ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum[keyof typeof ListFraudRules200ResponseFraudRulesInnerRuleTypeEnum];
/**
 *
 * @export
 * @interface ListFundingSources200Response
 */
export interface ListFundingSources200Response {
    /**
     *
     * @type {Array<ListFundingSources200ResponseFundingSourcesInner>}
     * @memberof ListFundingSources200Response
     */
    'funding_sources': Array<ListFundingSources200ResponseFundingSourcesInner>;
}
/**
 *
 * @export
 * @interface ListFundingSources200ResponseFundingSourcesInner
 */
export interface ListFundingSources200ResponseFundingSourcesInner {
    /**
     *
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'id': string;
    /**
     * You can pay for rewards using different payment methods on Tremendous:  <table>   <thead>     <tr>       <th>Payment Method</th>       <th>Description</th>       </tr>   </thead>   <tbody>     <tr>       <td><code>balance</code></td>       <td>Pre-funded balance in your Tremendous account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>bank_account</code></td>       <td>Bank account to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>credit_card</code></td>       <td>Credit card to draw funds from to send rewards to recipients.</td>     </tr>     <tr>       <td><code>invoice</code></td>       <td>Send rewards to recipients and pay by invoice.</td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'method': ListFundingSources200ResponseFundingSourcesInnerMethodEnum;
    /**
     * **Only available when `method` is set to `invoice`.**
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'type'?: ListFundingSources200ResponseFundingSourcesInnerTypeEnum;
    /**
     *
     * @type {ListFundingSources200ResponseFundingSourcesInnerMeta}
     * @memberof ListFundingSources200ResponseFundingSourcesInner
     */
    'meta': ListFundingSources200ResponseFundingSourcesInnerMeta;
}
export declare const ListFundingSources200ResponseFundingSourcesInnerMethodEnum: {
    readonly Balance: "balance";
    readonly BankAccount: "bank_account";
    readonly CreditCard: "credit_card";
    readonly Invoice: "invoice";
};
export type ListFundingSources200ResponseFundingSourcesInnerMethodEnum = typeof ListFundingSources200ResponseFundingSourcesInnerMethodEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerMethodEnum];
export declare const ListFundingSources200ResponseFundingSourcesInnerTypeEnum: {
    readonly Commercial: "COMMERCIAL";
    readonly ProForma: "PRO_FORMA";
    readonly PrefundingOnly: "PREFUNDING_ONLY";
};
export type ListFundingSources200ResponseFundingSourcesInnerTypeEnum = typeof ListFundingSources200ResponseFundingSourcesInnerTypeEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerTypeEnum];
/**
 *
 * @export
 * @interface ListFundingSources200ResponseFundingSourcesInnerMeta
 */
export interface ListFundingSources200ResponseFundingSourcesInnerMeta {
    /**
     * **Only available when `method` is set to `balance`.**  Available amount for this funding source (in Cents USD)
     * @type {number}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'available_cents'?: number;
    /**
     * **Only available when `method` is set to `balance`.**  Funds that are already registered on your Tremendous account but which have not yet been deposited in your account (e.g. unpaid invoices) (in Cents USD).
     * @type {number}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'pending_cents'?: number;
    /**
     * **Only available when `method` is set to `bank_account` or `credit_card`.**  Name of the holder of the bank account or credit_card
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'accountholder_name'?: string;
    /**
     * **Only available when `method` is set to `bank_account`.**  Is this a checking or savings account
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'account_type'?: ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum;
    /**
     * **Only available when `method` is set to `bank_account`.**  Name of the bank
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'bank_name'?: string | null;
    /**
     * **Only available when `method` is set to `bank_account`.**  Last 4 digits of the account number
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'account_number_mask'?: string;
    /**
     * **Only available when `method` is set to `bank_account`.**  Last 4 digits of the routing number
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'account_routing_mask'?: string;
    /**
     * **Only available when `method` is set to `bank_account`.**  Can refunds be deposited to this bank account
     * @type {boolean}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'refundable'?: boolean;
    /**
     * **Only available when `method` is set to `credit_card`.**  Network of the credit card
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'network'?: ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum;
    /**
     * **Only available when `method` is set to `credit_card`.**  Last 4 digits of the credit card number
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'last4'?: string;
    /**
     * **Only available when `method` is set to `credit_card`.**  Is this credit card expired
     * @type {boolean}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'expired'?: boolean;
    /**
     * **Only available when `method` is set to `bank_account` or `credit_card`.**  Point in time when the last order failed using this bank account or credit card as a funding source.
     * @type {string}
     * @memberof ListFundingSources200ResponseFundingSourcesInnerMeta
     */
    'last_payment_failed_at'?: string | null;
}
export declare const ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum: {
    readonly Checking: "checking";
    readonly Savings: "savings";
};
export type ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum = typeof ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerMetaAccountTypeEnum];
export declare const ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum: {
    readonly MasterCard: "MasterCard";
    readonly Amex: "Amex";
    readonly Jcb: "JCB";
    readonly DinersClub: "Diner's Club";
    readonly Visa: "visa";
    readonly Discover: "discover";
    readonly Laser: "laser";
    readonly Elo: "elo";
    readonly Maestro: "maestro";
    readonly Solo: "solo";
};
export type ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum = typeof ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum[keyof typeof ListFundingSources200ResponseFundingSourcesInnerMetaNetworkEnum];
/**
 *
 * @export
 * @interface ListInvoices200Response
 */
export interface ListInvoices200Response {
    /**
     *
     * @type {Array<ListInvoices200ResponseInvoicesInner>}
     * @memberof ListInvoices200Response
     */
    'invoices': Array<ListInvoices200ResponseInvoicesInner>;
    /**
     * The total number of invoices across all pages
     * @type {number}
     * @memberof ListInvoices200Response
     */
    'total_count': number;
}
/**
 * Invoices are instruments to fund your Tremendous account\'s balance.  Invoices can be created by your organization programatically. Once we receive your payment, the invoice is marked as `PAID` and we add the respective funds to your account\'s balance.
 * @export
 * @interface ListInvoices200ResponseInvoicesInner
 */
export interface ListInvoices200ResponseInvoicesInner {
    /**
     * The invoice number
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'id': string;
    /**
     * Reference to the purchase order number within your organization
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'po_number'?: string | null;
    /**
     * Amount of the invoice in USD
     * @type {number}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'amount': number;
    /**
     * Status of this invoice  <table>   <thead>     <tr>       <th>Status</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>DELETED</code></td>       <td>Invoice has been deleted by your organization</td>     </tr>     <tr>       <td><code>PAID</code></td>       <td>Invoice has been paid by your organization</td>     </tr>     <tr>       <td><code>OPEN</code></td>       <td>Invoice has been created by your organization but has not been paid, yet</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'status': ListInvoices200ResponseInvoicesInnerStatusEnum;
    /**
     * List of orders related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'orders'?: Array<string>;
    /**
     * List of rewards related to the invoice (it doesn\'t apply to prefunding)
     * @type {Array<string>}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'rewards'?: Array<string>;
    /**
     * Timestamp of when the invoice has been created.
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'created_at': string;
    /**
     * Timestamp of when the invoice has been paid.
     * @type {string}
     * @memberof ListInvoices200ResponseInvoicesInner
     */
    'paid_at': string | null;
}
export declare const ListInvoices200ResponseInvoicesInnerStatusEnum: {
    readonly Deleted: "DELETED";
    readonly Paid: "PAID";
    readonly Open: "OPEN";
    readonly MarkedAsPaid: "MARKED_AS_PAID";
};
export type ListInvoices200ResponseInvoicesInnerStatusEnum = typeof ListInvoices200ResponseInvoicesInnerStatusEnum[keyof typeof ListInvoices200ResponseInvoicesInnerStatusEnum];
/**
 *
 * @export
 * @interface ListMembers200Response
 */
export interface ListMembers200Response {
    /**
     *
     * @type {Array<ListMembers200ResponseMembersInner>}
     * @memberof ListMembers200Response
     */
    'members': Array<ListMembers200ResponseMembersInner>;
}
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more.
 * @export
 * @interface ListMembers200ResponseMembersInner
 */
export interface ListMembers200ResponseMembersInner {
    /**
     *
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization.
     * @type {boolean}
     * @memberof ListMembers200ResponseMembersInner
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization.
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`.
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'status': ListMembers200ResponseMembersInnerStatusEnum;
    /**
     * Timestamp when this member was created.  The `created_at` timestamp is **NOT** returned when retrieving a member (but is part of the response when listing or creating members).
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'created_at'?: string;
    /**
     * Timestamp when this member most recently logged into the dashboard of the organization associated with this API key.
     * @type {string}
     * @memberof ListMembers200ResponseMembersInner
     */
    'last_login_at'?: string | null;
}
export declare const ListMembers200ResponseMembersInnerStatusEnum: {
    readonly Registered: "REGISTERED";
    readonly Invited: "INVITED";
};
export type ListMembers200ResponseMembersInnerStatusEnum = typeof ListMembers200ResponseMembersInnerStatusEnum[keyof typeof ListMembers200ResponseMembersInnerStatusEnum];
/**
 *
 * @export
 * @interface ListOrders200Response
 */
export interface ListOrders200Response {
    /**
     *
     * @type {Array<ListOrders200ResponseOrdersInner>}
     * @memberof ListOrders200Response
     */
    'orders': Array<ListOrders200ResponseOrdersInner>;
    /**
     * The total number of orders across all pages
     * @type {number}
     * @memberof ListOrders200Response
     */
    'total_count': number;
}
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface ListOrders200ResponseOrdersInner
 */
export interface ListOrders200ResponseOrdersInner {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'status': ListOrders200ResponseOrdersInnerStatusEnum;
    /**
     *
     * @type {ListOrders200ResponseOrdersInnerPayment}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'payment'?: ListOrders200ResponseOrdersInnerPayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'invoice_id'?: string;
    /**
     *
     * @type {ListRewards200ResponseRewardsInner}
     * @memberof ListOrders200ResponseOrdersInner
     */
    'reward'?: ListRewards200ResponseRewardsInner;
}
export declare const ListOrders200ResponseOrdersInnerStatusEnum: {
    readonly Canceled: "CANCELED";
    readonly Cart: "CART";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly PendingApproval: "PENDING APPROVAL";
    readonly PendingInternalPaymentApproval: "PENDING INTERNAL PAYMENT APPROVAL";
};
export type ListOrders200ResponseOrdersInnerStatusEnum = typeof ListOrders200ResponseOrdersInnerStatusEnum[keyof typeof ListOrders200ResponseOrdersInnerStatusEnum];
/**
 * Cost breakdown of the order (cost of rewards + fees). Cost and fees are always denominated in USD, independent from the currency of the ordered rewards. Note that this property will only appear for processed orders (`status` is `EXECUTED`).
 * @export
 * @interface ListOrders200ResponseOrdersInnerPayment
 */
export interface ListOrders200ResponseOrdersInnerPayment {
    /**
     * Total price of the order before fees (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'subtotal'?: number;
    /**
     * Total price of the order including fees (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'total'?: number;
    /**
     * Fees for the order (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'fees'?: number;
    /**
     *
     * @type {ListOrders200ResponseOrdersInnerPaymentRefund}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'refund'?: ListOrders200ResponseOrdersInnerPaymentRefund;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof ListOrders200ResponseOrdersInnerPayment
     */
    'channel'?: ListOrders200ResponseOrdersInnerPaymentChannelEnum;
}
export declare const ListOrders200ResponseOrdersInnerPaymentChannelEnum: {
    readonly Ui: "UI";
    readonly Api: "API";
    readonly Embed: "EMBED";
    readonly Decipher: "DECIPHER";
    readonly Qualtrics: "QUALTRICS";
    readonly Typeform: "TYPEFORM";
    readonly SurveyMonkey: "SURVEY MONKEY";
};
export type ListOrders200ResponseOrdersInnerPaymentChannelEnum = typeof ListOrders200ResponseOrdersInnerPaymentChannelEnum[keyof typeof ListOrders200ResponseOrdersInnerPaymentChannelEnum];
/**
 * Breakdown of the order refunds (total amount in USD, independent from the currency of the ordered rewards). Note that this property will only appear for canceled orders or orders with canceled rewards.
 * @export
 * @interface ListOrders200ResponseOrdersInnerPaymentRefund
 */
export interface ListOrders200ResponseOrdersInnerPaymentRefund {
    /**
     * Total amount of the order refunds (in USD)
     * @type {number}
     * @memberof ListOrders200ResponseOrdersInnerPaymentRefund
     */
    'total': number;
}
/**
 *
 * @export
 * @interface ListOrganizations200Response
 */
export interface ListOrganizations200Response {
    /**
     *
     * @type {Array<ListOrganizations200ResponseOrganizationsInner>}
     * @memberof ListOrganizations200Response
     */
    'organizations'?: Array<ListOrganizations200ResponseOrganizationsInner>;
}
/**
 * Organizations are a way to separate different parts of your business within the same Tremendous account. Your root Tremendous account is an organization itself and can have multiple sub-organizations.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  Each organizations can have it\'s own API key.
 * @export
 * @interface ListOrganizations200ResponseOrganizationsInner
 */
export interface ListOrganizations200ResponseOrganizationsInner {
    /**
     *
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'id'?: string;
    /**
     * Name of the organization
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'website': string;
    /**
     * Status of the organization. Organizations need to be approved to be able to use them to send out rewards.
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'status'?: ListOrganizations200ResponseOrganizationsInnerStatusEnum;
    /**
     * Timestamp of when the organization has been created.  *This field is only returned when creating an organization.* It is not returned anymore when retrieving or listing organizations.
     * @type {string}
     * @memberof ListOrganizations200ResponseOrganizationsInner
     */
    'created_at'?: string;
}
export declare const ListOrganizations200ResponseOrganizationsInnerStatusEnum: {
    readonly Pending: "PENDING";
    readonly Approved: "APPROVED";
    readonly Rejected: "REJECTED";
};
export type ListOrganizations200ResponseOrganizationsInnerStatusEnum = typeof ListOrganizations200ResponseOrganizationsInnerStatusEnum[keyof typeof ListOrganizations200ResponseOrganizationsInnerStatusEnum];
/**
 *
 * @export
 * @interface ListProductsResponse
 */
export interface ListProductsResponse {
    /**
     *
     * @type {Array<ListProductsResponseProductsInner>}
     * @memberof ListProductsResponse
     */
    'products': Array<ListProductsResponseProductsInner>;
}
/**
 * A product represents one way to payout a reward to it\'s recipient. Think:  * Amazon.com gift card (ID: `OKMHM2X2OHYV`) * Donations to Save the Children (ID: `ESRNAD533W5A`) * Virtual Visa debit card (ID: `Q24BD9EZ332JT`)  each of which is one specific product on Tremendous.  > 📘 All available products > > See this [list](https://www.tremendous.com/catalog)  Products can be limited in their availability to recipients by  * geography (field `countries`) * currency (field `currencies`) * amount of the reward (field `skus`)   * e.g. adidas gift cards accept any amount between 5 and 200 USD.  See the description of each respective parameter for further details.
 * @export
 * @interface ListProductsResponseProductsInner
 */
export interface ListProductsResponseProductsInner {
    /**
     *
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'id': string;
    /**
     * Name of the product
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'name': string;
    /**
     * Detailed description of the product. Mostly used for products with a `category` of `charities`.
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'description': string;
    /**
     * The category of this product  <table>   <thead>     <tr>       <th>Category</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>ach</code></td>       <td>Bank transfer to the recipient</td>     </tr>     <tr>       <td><code>charity</code></td>       <td>Donations to a charity</td>     </tr>     <tr>       <td><code>merchant_card</code></td>       <td>A gift card for a certain merchant (e.g. Amazon)</td>     </tr>     <tr>       <td><code>paypal</code></td>       <td>Payout via PayPal</td>     </tr>     <tr>       <td><code>venmo</code></td>       <td>Payout via Venmo</td>     </tr>     <tr>       <td><code>visa_card</code></td>       <td>Payout in form of a Visa debit card</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'category': ListProductsResponseProductsInnerCategoryEnum;
    /**
     * Legal disclosures for this product. Can be in HTML format.
     * @type {string}
     * @memberof ListProductsResponseProductsInner
     */
    'disclosure': string;
    /**
     * Products may are restricted in their usage based on the amount of the reward. The `skus` array defines bands of denominations in which this product may be used for payouts.
     * @type {Array<ListProductsResponseProductsInnerSkusInner>}
     * @memberof ListProductsResponseProductsInner
     */
    'skus'?: Array<ListProductsResponseProductsInnerSkusInner>;
    /**
     * Available currencies for this product
     * @type {Array<string>}
     * @memberof ListProductsResponseProductsInner
     */
    'currency_codes': Array<ListProductsResponseProductsInnerCurrencyCodesEnum>;
    /**
     * List of countries in which this product is available to recipients.
     * @type {Array<ListProductsResponseProductsInnerCountriesInner>}
     * @memberof ListProductsResponseProductsInner
     */
    'countries': Array<ListProductsResponseProductsInnerCountriesInner>;
    /**
     * List of product images associated with this product (e.g. logos or images of the gift cards)
     * @type {Array<ListProductsResponseProductsInnerImagesInner>}
     * @memberof ListProductsResponseProductsInner
     */
    'images': Array<ListProductsResponseProductsInnerImagesInner>;
}
export declare const ListProductsResponseProductsInnerCategoryEnum: {
    readonly Ach: "ach";
    readonly Charity: "charity";
    readonly MerchantCard: "merchant_card";
    readonly Paypal: "paypal";
    readonly Venmo: "venmo";
    readonly VisaCard: "visa_card";
};
export type ListProductsResponseProductsInnerCategoryEnum = typeof ListProductsResponseProductsInnerCategoryEnum[keyof typeof ListProductsResponseProductsInnerCategoryEnum];
export declare const ListProductsResponseProductsInnerCurrencyCodesEnum: {
    readonly Usd: "USD";
    readonly Cad: "CAD";
    readonly Eur: "EUR";
    readonly Aed: "AED";
    readonly Afn: "AFN";
    readonly All: "ALL";
    readonly Amd: "AMD";
    readonly Ars: "ARS";
    readonly Aud: "AUD";
    readonly Azn: "AZN";
    readonly Bam: "BAM";
    readonly Bdt: "BDT";
    readonly Bgn: "BGN";
    readonly Bhd: "BHD";
    readonly Bif: "BIF";
    readonly Bnd: "BND";
    readonly Bob: "BOB";
    readonly Brl: "BRL";
    readonly Bwp: "BWP";
    readonly Byr: "BYR";
    readonly Bzd: "BZD";
    readonly Cdf: "CDF";
    readonly Chf: "CHF";
    readonly Clp: "CLP";
    readonly Cny: "CNY";
    readonly Cop: "COP";
    readonly Crc: "CRC";
    readonly Cve: "CVE";
    readonly Czk: "CZK";
    readonly Djf: "DJF";
    readonly Dkk: "DKK";
    readonly Dop: "DOP";
    readonly Dzd: "DZD";
    readonly Eek: "EEK";
    readonly Egp: "EGP";
    readonly Ern: "ERN";
    readonly Etb: "ETB";
    readonly Gbp: "GBP";
    readonly Gel: "GEL";
    readonly Ghs: "GHS";
    readonly Gnf: "GNF";
    readonly Gtq: "GTQ";
    readonly Hkd: "HKD";
    readonly Hnl: "HNL";
    readonly Hrk: "HRK";
    readonly Huf: "HUF";
    readonly Idr: "IDR";
    readonly Ils: "ILS";
    readonly Inr: "INR";
    readonly Iqd: "IQD";
    readonly Irr: "IRR";
    readonly Isk: "ISK";
    readonly Jmd: "JMD";
    readonly Jod: "JOD";
    readonly Jpy: "JPY";
    readonly Kes: "KES";
    readonly Khr: "KHR";
    readonly Krw: "KRW";
    readonly Kwd: "KWD";
    readonly Kzt: "KZT";
    readonly Lbp: "LBP";
    readonly Lkr: "LKR";
    readonly Ltl: "LTL";
    readonly Lvl: "LVL";
    readonly Mad: "MAD";
    readonly Mdl: "MDL";
    readonly Mga: "MGA";
    readonly Mkd: "MKD";
    readonly Mmk: "MMK";
    readonly Mop: "MOP";
    readonly Mur: "MUR";
    readonly Mxn: "MXN";
    readonly Myr: "MYR";
    readonly Mzn: "MZN";
    readonly Nad: "NAD";
    readonly Ngn: "NGN";
    readonly Nio: "NIO";
    readonly Nok: "NOK";
    readonly Npr: "NPR";
    readonly Nzd: "NZD";
    readonly Omr: "OMR";
    readonly Pab: "PAB";
    readonly Pen: "PEN";
    readonly Php: "PHP";
    readonly Pkr: "PKR";
    readonly Pln: "PLN";
    readonly Pyg: "PYG";
    readonly Qar: "QAR";
    readonly Ron: "RON";
    readonly Rsd: "RSD";
    readonly Rub: "RUB";
    readonly Rwf: "RWF";
    readonly Sar: "SAR";
    readonly Sdg: "SDG";
    readonly Sek: "SEK";
    readonly Sgd: "SGD";
    readonly Sos: "SOS";
    readonly Syp: "SYP";
    readonly Thb: "THB";
    readonly Tnd: "TND";
    readonly Top: "TOP";
    readonly Try: "TRY";
    readonly Ttd: "TTD";
    readonly Twd: "TWD";
    readonly Tzs: "TZS";
    readonly Uah: "UAH";
    readonly Ugx: "UGX";
    readonly Uyu: "UYU";
    readonly Uzs: "UZS";
    readonly Vef: "VEF";
    readonly Vnd: "VND";
    readonly Xaf: "XAF";
    readonly Xof: "XOF";
    readonly Yer: "YER";
    readonly Zar: "ZAR";
    readonly Zmk: "ZMK";
};
export type ListProductsResponseProductsInnerCurrencyCodesEnum = typeof ListProductsResponseProductsInnerCurrencyCodesEnum[keyof typeof ListProductsResponseProductsInnerCurrencyCodesEnum];
/**
 *
 * @export
 * @interface ListProductsResponseProductsInnerCountriesInner
 */
export interface ListProductsResponseProductsInnerCountriesInner {
    /**
     * ISO 3166 country code
     * @type {string}
     * @memberof ListProductsResponseProductsInnerCountriesInner
     */
    'abbr': string;
}
/**
 *
 * @export
 * @interface ListProductsResponseProductsInnerImagesInner
 */
export interface ListProductsResponseProductsInnerImagesInner {
    /**
     * URL to this image
     * @type {string}
     * @memberof ListProductsResponseProductsInnerImagesInner
     */
    'src': string;
    /**
     * Type of image
     * @type {string}
     * @memberof ListProductsResponseProductsInnerImagesInner
     */
    'type': ListProductsResponseProductsInnerImagesInnerTypeEnum;
}
export declare const ListProductsResponseProductsInnerImagesInnerTypeEnum: {
    readonly Card: "card";
    readonly Logo: "logo";
};
export type ListProductsResponseProductsInnerImagesInnerTypeEnum = typeof ListProductsResponseProductsInnerImagesInnerTypeEnum[keyof typeof ListProductsResponseProductsInnerImagesInnerTypeEnum];
/**
 *
 * @export
 * @interface ListProductsResponseProductsInnerSkusInner
 */
export interface ListProductsResponseProductsInnerSkusInner {
    /**
     * Minimal denomination that this product supports (in the product\'s currency)
     * @type {number}
     * @memberof ListProductsResponseProductsInnerSkusInner
     */
    'min': number;
    /**
     * Maximum denomination that this product supports (in the product\'s currency)
     * @type {number}
     * @memberof ListProductsResponseProductsInnerSkusInner
     */
    'max': number;
}
/**
 *
 * @export
 * @interface ListRewards200Response
 */
export interface ListRewards200Response {
    /**
     *
     * @type {Array<ListRewards200ResponseRewardsInner>}
     * @memberof ListRewards200Response
     */
    'rewards'?: Array<ListRewards200ResponseRewardsInner>;
    /**
     * The total number of rewards across all pages
     * @type {number}
     * @memberof ListRewards200Response
     */
    'total_count'?: number;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface ListRewards200ResponseRewardsInner
 */
export interface ListRewards200ResponseRewardsInner {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'created_at'?: string;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<ListRewards200ResponseRewardsInnerCustomFieldsInner>}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'custom_fields'?: Array<ListRewards200ResponseRewardsInnerCustomFieldsInner>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerDelivery}
     * @memberof ListRewards200ResponseRewardsInner
     */
    'delivery'?: ListRewards200ResponseRewardsInnerDelivery;
}
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface ListRewards200ResponseRewardsInnerCustomFieldsInner
 */
export interface ListRewards200ResponseRewardsInnerCustomFieldsInner {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerCustomFieldsInner
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerCustomFieldsInner
     */
    'value'?: string | null;
    /**
     * Label of the custom field
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerCustomFieldsInner
     */
    'label'?: string;
}
/**
 * Details on how the reward is delivered to the recipient.
 * @export
 * @interface ListRewards200ResponseRewardsInnerDelivery
 */
export interface ListRewards200ResponseRewardsInnerDelivery {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerDelivery
     */
    'method': ListRewards200ResponseRewardsInnerDeliveryMethodEnum;
    /**
     * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled.
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerDelivery
     */
    'status': ListRewards200ResponseRewardsInnerDeliveryStatusEnum;
}
export declare const ListRewards200ResponseRewardsInnerDeliveryMethodEnum: {
    readonly Email: "EMAIL";
    readonly Link: "LINK";
    readonly Phone: "PHONE";
};
export type ListRewards200ResponseRewardsInnerDeliveryMethodEnum = typeof ListRewards200ResponseRewardsInnerDeliveryMethodEnum[keyof typeof ListRewards200ResponseRewardsInnerDeliveryMethodEnum];
export declare const ListRewards200ResponseRewardsInnerDeliveryStatusEnum: {
    readonly Scheduled: "SCHEDULED";
    readonly Failed: "FAILED";
    readonly Succeeded: "SUCCEEDED";
    readonly Pending: "PENDING";
};
export type ListRewards200ResponseRewardsInnerDeliveryStatusEnum = typeof ListRewards200ResponseRewardsInnerDeliveryStatusEnum[keyof typeof ListRewards200ResponseRewardsInnerDeliveryStatusEnum];
/**
 * Details of the recipient of the reward
 * @export
 * @interface ListRewards200ResponseRewardsInnerRecipient
 */
export interface ListRewards200ResponseRewardsInnerRecipient {
    /**
     * Name of the recipient
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerRecipient
     */
    'name'?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerRecipient
     */
    'email'?: string;
    /**
     * Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerRecipient
     */
    'phone'?: string;
}
/**
 *
 * @export
 * @interface ListRewards200ResponseRewardsInnerValue
 */
export interface ListRewards200ResponseRewardsInnerValue {
    /**
     * Amount of the reward
     * @type {number}
     * @memberof ListRewards200ResponseRewardsInnerValue
     */
    'denomination': number;
    /**
     * Currency of the reward
     * @type {string}
     * @memberof ListRewards200ResponseRewardsInnerValue
     */
    'currency_code'?: ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum;
}
export declare const ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum: {
    readonly Usd: "USD";
    readonly Cad: "CAD";
    readonly Eur: "EUR";
    readonly Aed: "AED";
    readonly Afn: "AFN";
    readonly All: "ALL";
    readonly Amd: "AMD";
    readonly Ars: "ARS";
    readonly Aud: "AUD";
    readonly Azn: "AZN";
    readonly Bam: "BAM";
    readonly Bdt: "BDT";
    readonly Bgn: "BGN";
    readonly Bhd: "BHD";
    readonly Bif: "BIF";
    readonly Bnd: "BND";
    readonly Bob: "BOB";
    readonly Brl: "BRL";
    readonly Bwp: "BWP";
    readonly Byr: "BYR";
    readonly Bzd: "BZD";
    readonly Cdf: "CDF";
    readonly Chf: "CHF";
    readonly Clp: "CLP";
    readonly Cny: "CNY";
    readonly Cop: "COP";
    readonly Crc: "CRC";
    readonly Cve: "CVE";
    readonly Czk: "CZK";
    readonly Djf: "DJF";
    readonly Dkk: "DKK";
    readonly Dop: "DOP";
    readonly Dzd: "DZD";
    readonly Eek: "EEK";
    readonly Egp: "EGP";
    readonly Ern: "ERN";
    readonly Etb: "ETB";
    readonly Gbp: "GBP";
    readonly Gel: "GEL";
    readonly Ghs: "GHS";
    readonly Gnf: "GNF";
    readonly Gtq: "GTQ";
    readonly Hkd: "HKD";
    readonly Hnl: "HNL";
    readonly Hrk: "HRK";
    readonly Huf: "HUF";
    readonly Idr: "IDR";
    readonly Ils: "ILS";
    readonly Inr: "INR";
    readonly Iqd: "IQD";
    readonly Irr: "IRR";
    readonly Isk: "ISK";
    readonly Jmd: "JMD";
    readonly Jod: "JOD";
    readonly Jpy: "JPY";
    readonly Kes: "KES";
    readonly Khr: "KHR";
    readonly Krw: "KRW";
    readonly Kwd: "KWD";
    readonly Kzt: "KZT";
    readonly Lbp: "LBP";
    readonly Lkr: "LKR";
    readonly Ltl: "LTL";
    readonly Lvl: "LVL";
    readonly Mad: "MAD";
    readonly Mdl: "MDL";
    readonly Mga: "MGA";
    readonly Mkd: "MKD";
    readonly Mmk: "MMK";
    readonly Mop: "MOP";
    readonly Mur: "MUR";
    readonly Mxn: "MXN";
    readonly Myr: "MYR";
    readonly Mzn: "MZN";
    readonly Nad: "NAD";
    readonly Ngn: "NGN";
    readonly Nio: "NIO";
    readonly Nok: "NOK";
    readonly Npr: "NPR";
    readonly Nzd: "NZD";
    readonly Omr: "OMR";
    readonly Pab: "PAB";
    readonly Pen: "PEN";
    readonly Php: "PHP";
    readonly Pkr: "PKR";
    readonly Pln: "PLN";
    readonly Pyg: "PYG";
    readonly Qar: "QAR";
    readonly Ron: "RON";
    readonly Rsd: "RSD";
    readonly Rub: "RUB";
    readonly Rwf: "RWF";
    readonly Sar: "SAR";
    readonly Sdg: "SDG";
    readonly Sek: "SEK";
    readonly Sgd: "SGD";
    readonly Sos: "SOS";
    readonly Syp: "SYP";
    readonly Thb: "THB";
    readonly Tnd: "TND";
    readonly Top: "TOP";
    readonly Try: "TRY";
    readonly Ttd: "TTD";
    readonly Twd: "TWD";
    readonly Tzs: "TZS";
    readonly Uah: "UAH";
    readonly Ugx: "UGX";
    readonly Uyu: "UYU";
    readonly Uzs: "UZS";
    readonly Vef: "VEF";
    readonly Vnd: "VND";
    readonly Xaf: "XAF";
    readonly Xof: "XOF";
    readonly Yer: "YER";
    readonly Zar: "ZAR";
    readonly Zmk: "ZMK";
};
export type ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum = typeof ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum[keyof typeof ListRewards200ResponseRewardsInnerValueCurrencyCodeEnum];
/**
 *
 * @export
 * @interface ListRewards401Response
 */
export interface ListRewards401Response {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof ListRewards401Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 *
 * @export
 * @interface ListRewards401ResponseErrors
 */
export interface ListRewards401ResponseErrors {
    /**
     * Error message
     * @type {string}
     * @memberof ListRewards401ResponseErrors
     */
    'message'?: string;
    /**
     * Mirrors the request parameters structure, filled only with the (nested) properties that caused an error.
     * @type {object}
     * @memberof ListRewards401ResponseErrors
     */
    'payload'?: object;
}
/**
 *
 * @export
 * @interface ListRewards429Response
 */
export interface ListRewards429Response {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof ListRewards429Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 *
 * @export
 * @interface ListRoles200Response
 */
export interface ListRoles200Response {
    /**
     *
     * @type {Array<ListRoles200ResponseRolesInner>}
     * @memberof ListRoles200Response
     */
    'roles': Array<ListRoles200ResponseRolesInner>;
}
/**
 * Each organization member is assigned a role that defines the permissions they have within the organization.
 * @export
 * @interface ListRoles200ResponseRolesInner
 */
export interface ListRoles200ResponseRolesInner {
    /**
     *
     * @type {string}
     * @memberof ListRoles200ResponseRolesInner
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof ListRoles200ResponseRolesInner
     */
    'title': string;
    /**
     *
     * @type {string}
     * @memberof ListRoles200ResponseRolesInner
     */
    'description': string;
}
/**
 *
 * @export
 * @interface ListWebhookEvents200Response
 */
export interface ListWebhookEvents200Response {
    /**
     *
     * @type {Array<string>}
     * @memberof ListWebhookEvents200Response
     */
    'events'?: Array<string>;
}
/**
 *
 * @export
 * @interface ListWebhooks200Response
 */
export interface ListWebhooks200Response {
    /**
     *
     * @type {Array<ListWebhooks200ResponseWebhooksInner>}
     * @memberof ListWebhooks200Response
     */
    'webhooks'?: Array<ListWebhooks200ResponseWebhooksInner>;
}
/**
 *
 * @export
 * @interface ListWebhooks200ResponseWebhooksInner
 */
export interface ListWebhooks200ResponseWebhooksInner {
    /**
     *
     * @type {string}
     * @memberof ListWebhooks200ResponseWebhooksInner
     */
    'id'?: string;
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof ListWebhooks200ResponseWebhooksInner
     */
    'url': string | null;
    /**
     * Private key for the webhook
     * @type {string}
     * @memberof ListWebhooks200ResponseWebhooksInner
     */
    'private_key'?: string;
}
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more.
 * @export
 * @interface Member
 */
export interface Member {
    /**
     *
     * @type {string}
     * @memberof Member
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof Member
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof Member
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization.
     * @type {boolean}
     * @memberof Member
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization.
     * @type {string}
     * @memberof Member
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`.
     * @type {string}
     * @memberof Member
     */
    'status': MemberStatusEnum;
    /**
     * Timestamp when this member was created.  The `created_at` timestamp is **NOT** returned when retrieving a member (but is part of the response when listing or creating members).
     * @type {string}
     * @memberof Member
     */
    'created_at'?: string;
    /**
     * Timestamp when this member most recently logged into the dashboard of the organization associated with this API key.
     * @type {string}
     * @memberof Member
     */
    'last_login_at'?: string | null;
}
export declare const MemberStatusEnum: {
    readonly Registered: "REGISTERED";
    readonly Invited: "INVITED";
};
export type MemberStatusEnum = typeof MemberStatusEnum[keyof typeof MemberStatusEnum];
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more.
 * @export
 * @interface MemberBase
 */
export interface MemberBase {
    /**
     *
     * @type {string}
     * @memberof MemberBase
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof MemberBase
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof MemberBase
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization.
     * @type {boolean}
     * @memberof MemberBase
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization.
     * @type {string}
     * @memberof MemberBase
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`.
     * @type {string}
     * @memberof MemberBase
     */
    'status': MemberBaseStatusEnum;
}
export declare const MemberBaseStatusEnum: {
    readonly Registered: "REGISTERED";
    readonly Invited: "INVITED";
};
export type MemberBaseStatusEnum = typeof MemberBaseStatusEnum[keyof typeof MemberBaseStatusEnum];
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more.
 * @export
 * @interface MemberWithEvents
 */
export interface MemberWithEvents {
    /**
     *
     * @type {string}
     * @memberof MemberWithEvents
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof MemberWithEvents
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof MemberWithEvents
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization.
     * @type {boolean}
     * @memberof MemberWithEvents
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization.
     * @type {string}
     * @memberof MemberWithEvents
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`.
     * @type {string}
     * @memberof MemberWithEvents
     */
    'status': MemberWithEventsStatusEnum;
    /**
     * List of events related to the member.
     * @type {Array<GetMember200ResponseMemberEventsInner>}
     * @memberof MemberWithEvents
     */
    'events'?: Array<GetMember200ResponseMemberEventsInner>;
}
export declare const MemberWithEventsStatusEnum: {
    readonly Registered: "REGISTERED";
    readonly Invited: "INVITED";
};
export type MemberWithEventsStatusEnum = typeof MemberWithEventsStatusEnum[keyof typeof MemberWithEventsStatusEnum];
/**
 * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly.  These actions include adding funding sources to the organization, creating Campaigns, and more.
 * @export
 * @interface MemberWithoutEvents
 */
export interface MemberWithoutEvents {
    /**
     *
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'id': string;
    /**
     * Email address of the member
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'email': string;
    /**
     * Full name of the member
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'name': string | null;
    /**
     * Is this member currently active in the organization. If `false`, the member will not be able to access the organization.
     * @type {boolean}
     * @memberof MemberWithoutEvents
     */
    'active'?: boolean;
    /**
     * The role ID associated with the member within the organization.
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'role'?: string | null;
    /**
     * Current status of the member\'s account.  When creating a member it starts out in the status `INVITED`. As soon as that member open the invitation link and registers an account, the status switches to `REGISTERED`.
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'status': MemberWithoutEventsStatusEnum;
    /**
     * Timestamp when this member was created.  The `created_at` timestamp is **NOT** returned when retrieving a member (but is part of the response when listing or creating members).
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'created_at'?: string;
    /**
     * Timestamp when this member most recently logged into the dashboard of the organization associated with this API key.
     * @type {string}
     * @memberof MemberWithoutEvents
     */
    'last_login_at'?: string | null;
}
export declare const MemberWithoutEventsStatusEnum: {
    readonly Registered: "REGISTERED";
    readonly Invited: "INVITED";
};
export type MemberWithoutEventsStatusEnum = typeof MemberWithoutEventsStatusEnum[keyof typeof MemberWithoutEventsStatusEnum];
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof Order
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof Order
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof Order
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof Order
     */
    'status': OrderStatusEnum;
    /**
     *
     * @type {OrderBasePayment}
     * @memberof Order
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof Order
     */
    'invoice_id'?: string;
    /**
     *
     * @type {OrderWithoutLinkReward}
     * @memberof Order
     */
    'reward'?: OrderWithoutLinkReward;
}
export declare const OrderStatusEnum: {
    readonly Canceled: "CANCELED";
    readonly Cart: "CART";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly PendingApproval: "PENDING APPROVAL";
    readonly PendingInternalPaymentApproval: "PENDING INTERNAL PAYMENT APPROVAL";
};
export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface OrderBase
 */
export interface OrderBase {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof OrderBase
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof OrderBase
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof OrderBase
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof OrderBase
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof OrderBase
     */
    'status': OrderBaseStatusEnum;
    /**
     *
     * @type {OrderBasePayment}
     * @memberof OrderBase
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof OrderBase
     */
    'invoice_id'?: string;
}
export declare const OrderBaseStatusEnum: {
    readonly Canceled: "CANCELED";
    readonly Cart: "CART";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly PendingApproval: "PENDING APPROVAL";
    readonly PendingInternalPaymentApproval: "PENDING INTERNAL PAYMENT APPROVAL";
};
export type OrderBaseStatusEnum = typeof OrderBaseStatusEnum[keyof typeof OrderBaseStatusEnum];
/**
 * Cost breakdown of the order (cost of rewards + fees). Cost and fees are always denominated in USD, independent from the currency of the ordered rewards. Note that this property will only appear for processed orders (`status` is `EXECUTED`).
 * @export
 * @interface OrderBasePayment
 */
export interface OrderBasePayment {
    /**
     * Total price of the order before fees (in USD)
     * @type {number}
     * @memberof OrderBasePayment
     */
    'subtotal'?: number;
    /**
     * Total price of the order including fees (in USD)
     * @type {number}
     * @memberof OrderBasePayment
     */
    'total'?: number;
    /**
     * Fees for the order (in USD)
     * @type {number}
     * @memberof OrderBasePayment
     */
    'fees'?: number;
    /**
     *
     * @type {PaymentDetailsRefund}
     * @memberof OrderBasePayment
     */
    'refund'?: PaymentDetailsRefund;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof OrderBasePayment
     */
    'channel'?: OrderBasePaymentChannelEnum;
}
export declare const OrderBasePaymentChannelEnum: {
    readonly Ui: "UI";
    readonly Api: "API";
    readonly Embed: "EMBED";
    readonly Decipher: "DECIPHER";
    readonly Qualtrics: "QUALTRICS";
    readonly Typeform: "TYPEFORM";
    readonly SurveyMonkey: "SURVEY MONKEY";
};
export type OrderBasePaymentChannelEnum = typeof OrderBasePaymentChannelEnum[keyof typeof OrderBasePaymentChannelEnum];
/**
 * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
 * @export
 * @enum {string}
 */
export declare const OrderStatus: {
    readonly Canceled: "CANCELED";
    readonly Cart: "CART";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly PendingApproval: "PENDING APPROVAL";
    readonly PendingInternalPaymentApproval: "PENDING INTERNAL PAYMENT APPROVAL";
};
export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface OrderWithoutLink
 */
export interface OrderWithoutLink {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'status': OrderWithoutLinkStatusEnum;
    /**
     *
     * @type {OrderBasePayment}
     * @memberof OrderWithoutLink
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof OrderWithoutLink
     */
    'invoice_id'?: string;
    /**
     *
     * @type {OrderWithoutLinkReward}
     * @memberof OrderWithoutLink
     */
    'reward'?: OrderWithoutLinkReward;
}
export declare const OrderWithoutLinkStatusEnum: {
    readonly Canceled: "CANCELED";
    readonly Cart: "CART";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly PendingApproval: "PENDING APPROVAL";
    readonly PendingInternalPaymentApproval: "PENDING INTERNAL PAYMENT APPROVAL";
};
export type OrderWithoutLinkStatusEnum = typeof OrderWithoutLinkStatusEnum[keyof typeof OrderWithoutLinkStatusEnum];
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface OrderWithoutLinkReward
 */
export interface OrderWithoutLinkReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof OrderWithoutLinkReward
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof OrderWithoutLinkReward
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof OrderWithoutLinkReward
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof OrderWithoutLinkReward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof OrderWithoutLinkReward
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof OrderWithoutLinkReward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof OrderWithoutLinkReward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof OrderWithoutLinkReward
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof OrderWithoutLinkReward
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     *
     * @type {RewardWithoutLinkDelivery}
     * @memberof OrderWithoutLinkReward
     */
    'delivery'?: RewardWithoutLinkDelivery;
}
/**
 * Organizations are a way to separate different parts of your business within the same Tremendous account. Your root Tremendous account is an organization itself and can have multiple sub-organizations.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  Each organizations can have it\'s own API key.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     *
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * Name of the organization
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * URL of the website of that organization
     * @type {string}
     * @memberof Organization
     */
    'website': string;
    /**
     * Status of the organization. Organizations need to be approved to be able to use them to send out rewards.
     * @type {string}
     * @memberof Organization
     */
    'status'?: OrganizationStatusEnum;
    /**
     * Timestamp of when the organization has been created.  *This field is only returned when creating an organization.* It is not returned anymore when retrieving or listing organizations.
     * @type {string}
     * @memberof Organization
     */
    'created_at'?: string;
}
export declare const OrganizationStatusEnum: {
    readonly Pending: "PENDING";
    readonly Approved: "APPROVED";
    readonly Rejected: "REJECTED";
};
export type OrganizationStatusEnum = typeof OrganizationStatusEnum[keyof typeof OrganizationStatusEnum];
/**
 *
 * @export
 * @interface PaymentDetails
 */
export interface PaymentDetails {
    /**
     * Total price of the order before fees (in USD)
     * @type {number}
     * @memberof PaymentDetails
     */
    'subtotal'?: number;
    /**
     * Total price of the order including fees (in USD)
     * @type {number}
     * @memberof PaymentDetails
     */
    'total'?: number;
    /**
     * Fees for the order (in USD)
     * @type {number}
     * @memberof PaymentDetails
     */
    'fees'?: number;
    /**
     *
     * @type {PaymentDetailsRefund}
     * @memberof PaymentDetails
     */
    'refund'?: PaymentDetailsRefund;
    /**
     * Name of the channel in which the order was created
     * @type {string}
     * @memberof PaymentDetails
     */
    'channel'?: PaymentDetailsChannelEnum;
}
export declare const PaymentDetailsChannelEnum: {
    readonly Ui: "UI";
    readonly Api: "API";
    readonly Embed: "EMBED";
    readonly Decipher: "DECIPHER";
    readonly Qualtrics: "QUALTRICS";
    readonly Typeform: "TYPEFORM";
    readonly SurveyMonkey: "SURVEY MONKEY";
};
export type PaymentDetailsChannelEnum = typeof PaymentDetailsChannelEnum[keyof typeof PaymentDetailsChannelEnum];
/**
 * Breakdown of the order refunds (total amount in USD, independent from the currency of the ordered rewards). Note that this property will only appear for canceled orders or orders with canceled rewards.
 * @export
 * @interface PaymentDetailsRefund
 */
export interface PaymentDetailsRefund {
    /**
     * Total amount of the order refunds (in USD)
     * @type {number}
     * @memberof PaymentDetailsRefund
     */
    'total': number;
}
/**
 * A product represents one way to payout a reward to it\'s recipient. Think:  * Amazon.com gift card (ID: `OKMHM2X2OHYV`) * Donations to Save the Children (ID: `ESRNAD533W5A`) * Virtual Visa debit card (ID: `Q24BD9EZ332JT`)  each of which is one specific product on Tremendous.  > 📘 All available products > > See this [list](https://www.tremendous.com/catalog)  Products can be limited in their availability to recipients by  * geography (field `countries`) * currency (field `currencies`) * amount of the reward (field `skus`)   * e.g. adidas gift cards accept any amount between 5 and 200 USD.  See the description of each respective parameter for further details.
 * @export
 * @interface Product
 */
export interface Product {
    /**
     *
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * Name of the product
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * Detailed description of the product. Mostly used for products with a `category` of `charities`.
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * The category of this product  <table>   <thead>     <tr>       <th>Category</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>ach</code></td>       <td>Bank transfer to the recipient</td>     </tr>     <tr>       <td><code>charity</code></td>       <td>Donations to a charity</td>     </tr>     <tr>       <td><code>merchant_card</code></td>       <td>A gift card for a certain merchant (e.g. Amazon)</td>     </tr>     <tr>       <td><code>paypal</code></td>       <td>Payout via PayPal</td>     </tr>     <tr>       <td><code>venmo</code></td>       <td>Payout via Venmo</td>     </tr>     <tr>       <td><code>visa_card</code></td>       <td>Payout in form of a Visa debit card</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof Product
     */
    'category': ProductCategoryEnum;
    /**
     * Legal disclosures for this product. Can be in HTML format.
     * @type {string}
     * @memberof Product
     */
    'disclosure': string;
    /**
     * Products may are restricted in their usage based on the amount of the reward. The `skus` array defines bands of denominations in which this product may be used for payouts.
     * @type {Array<ListProductsResponseProductsInnerSkusInner>}
     * @memberof Product
     */
    'skus'?: Array<ListProductsResponseProductsInnerSkusInner>;
    /**
     * Available currencies for this product
     * @type {Array<string>}
     * @memberof Product
     */
    'currency_codes': Array<ProductCurrencyCodesEnum>;
    /**
     * List of countries in which this product is available to recipients.
     * @type {Array<ListProductsResponseProductsInnerCountriesInner>}
     * @memberof Product
     */
    'countries': Array<ListProductsResponseProductsInnerCountriesInner>;
    /**
     * List of product images associated with this product (e.g. logos or images of the gift cards)
     * @type {Array<ListProductsResponseProductsInnerImagesInner>}
     * @memberof Product
     */
    'images': Array<ListProductsResponseProductsInnerImagesInner>;
}
export declare const ProductCategoryEnum: {
    readonly Ach: "ach";
    readonly Charity: "charity";
    readonly MerchantCard: "merchant_card";
    readonly Paypal: "paypal";
    readonly Venmo: "venmo";
    readonly VisaCard: "visa_card";
};
export type ProductCategoryEnum = typeof ProductCategoryEnum[keyof typeof ProductCategoryEnum];
export declare const ProductCurrencyCodesEnum: {
    readonly Usd: "USD";
    readonly Cad: "CAD";
    readonly Eur: "EUR";
    readonly Aed: "AED";
    readonly Afn: "AFN";
    readonly All: "ALL";
    readonly Amd: "AMD";
    readonly Ars: "ARS";
    readonly Aud: "AUD";
    readonly Azn: "AZN";
    readonly Bam: "BAM";
    readonly Bdt: "BDT";
    readonly Bgn: "BGN";
    readonly Bhd: "BHD";
    readonly Bif: "BIF";
    readonly Bnd: "BND";
    readonly Bob: "BOB";
    readonly Brl: "BRL";
    readonly Bwp: "BWP";
    readonly Byr: "BYR";
    readonly Bzd: "BZD";
    readonly Cdf: "CDF";
    readonly Chf: "CHF";
    readonly Clp: "CLP";
    readonly Cny: "CNY";
    readonly Cop: "COP";
    readonly Crc: "CRC";
    readonly Cve: "CVE";
    readonly Czk: "CZK";
    readonly Djf: "DJF";
    readonly Dkk: "DKK";
    readonly Dop: "DOP";
    readonly Dzd: "DZD";
    readonly Eek: "EEK";
    readonly Egp: "EGP";
    readonly Ern: "ERN";
    readonly Etb: "ETB";
    readonly Gbp: "GBP";
    readonly Gel: "GEL";
    readonly Ghs: "GHS";
    readonly Gnf: "GNF";
    readonly Gtq: "GTQ";
    readonly Hkd: "HKD";
    readonly Hnl: "HNL";
    readonly Hrk: "HRK";
    readonly Huf: "HUF";
    readonly Idr: "IDR";
    readonly Ils: "ILS";
    readonly Inr: "INR";
    readonly Iqd: "IQD";
    readonly Irr: "IRR";
    readonly Isk: "ISK";
    readonly Jmd: "JMD";
    readonly Jod: "JOD";
    readonly Jpy: "JPY";
    readonly Kes: "KES";
    readonly Khr: "KHR";
    readonly Krw: "KRW";
    readonly Kwd: "KWD";
    readonly Kzt: "KZT";
    readonly Lbp: "LBP";
    readonly Lkr: "LKR";
    readonly Ltl: "LTL";
    readonly Lvl: "LVL";
    readonly Mad: "MAD";
    readonly Mdl: "MDL";
    readonly Mga: "MGA";
    readonly Mkd: "MKD";
    readonly Mmk: "MMK";
    readonly Mop: "MOP";
    readonly Mur: "MUR";
    readonly Mxn: "MXN";
    readonly Myr: "MYR";
    readonly Mzn: "MZN";
    readonly Nad: "NAD";
    readonly Ngn: "NGN";
    readonly Nio: "NIO";
    readonly Nok: "NOK";
    readonly Npr: "NPR";
    readonly Nzd: "NZD";
    readonly Omr: "OMR";
    readonly Pab: "PAB";
    readonly Pen: "PEN";
    readonly Php: "PHP";
    readonly Pkr: "PKR";
    readonly Pln: "PLN";
    readonly Pyg: "PYG";
    readonly Qar: "QAR";
    readonly Ron: "RON";
    readonly Rsd: "RSD";
    readonly Rub: "RUB";
    readonly Rwf: "RWF";
    readonly Sar: "SAR";
    readonly Sdg: "SDG";
    readonly Sek: "SEK";
    readonly Sgd: "SGD";
    readonly Sos: "SOS";
    readonly Syp: "SYP";
    readonly Thb: "THB";
    readonly Tnd: "TND";
    readonly Top: "TOP";
    readonly Try: "TRY";
    readonly Ttd: "TTD";
    readonly Twd: "TWD";
    readonly Tzs: "TZS";
    readonly Uah: "UAH";
    readonly Ugx: "UGX";
    readonly Uyu: "UYU";
    readonly Uzs: "UZS";
    readonly Vef: "VEF";
    readonly Vnd: "VND";
    readonly Xaf: "XAF";
    readonly Xof: "XOF";
    readonly Yer: "YER";
    readonly Zar: "ZAR";
    readonly Zmk: "ZMK";
};
export type ProductCurrencyCodesEnum = typeof ProductCurrencyCodesEnum[keyof typeof ProductCurrencyCodesEnum];
/**
 * To authenticate your requests using asymmetric key pairs (e.g., for signing embed requests), you need to share your public key with us. The public key resource allows you to manage your active public keys and track their last usage.
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     *
     * @type {string}
     * @memberof PublicKey
     */
    'id'?: string;
    /**
     * Your public key, PEM encoded
     * @type {string}
     * @memberof PublicKey
     */
    'pem'?: string;
    /**
     * The last time your public key was used to sign a request
     * @type {string}
     * @memberof PublicKey
     */
    'last_used_at'?: string | null;
}
/**
 *
 * @export
 * @interface PublicKeysResponse
 */
export interface PublicKeysResponse {
    /**
     *
     * @type {Array<PublicKeysResponsePublicKeysInner>}
     * @memberof PublicKeysResponse
     */
    'public_keys': Array<PublicKeysResponsePublicKeysInner>;
}
/**
 * To authenticate your requests using asymmetric key pairs (e.g., for signing embed requests), you need to share your public key with us. The public key resource allows you to manage your active public keys and track their last usage.
 * @export
 * @interface PublicKeysResponsePublicKeysInner
 */
export interface PublicKeysResponsePublicKeysInner {
    /**
     *
     * @type {string}
     * @memberof PublicKeysResponsePublicKeysInner
     */
    'id'?: string;
    /**
     * Your public key, PEM encoded
     * @type {string}
     * @memberof PublicKeysResponsePublicKeysInner
     */
    'pem'?: string;
    /**
     * The last time your public key was used to sign a request
     * @type {string}
     * @memberof PublicKeysResponsePublicKeysInner
     */
    'last_used_at'?: string | null;
}
/**
 * Details of the recipient of the reward
 * @export
 * @interface Recipient
 */
export interface Recipient {
    /**
     * Name of the recipient
     * @type {string}
     * @memberof Recipient
     */
    'name'?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof Recipient
     */
    'email'?: string;
    /**
     * Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).
     * @type {string}
     * @memberof Recipient
     */
    'phone'?: string;
}
/**
 *
 * @export
 * @interface RefundDetails
 */
export interface RefundDetails {
    /**
     * Total amount of the order refunds (in USD)
     * @type {number}
     * @memberof RefundDetails
     */
    'total': number;
}
/**
 *
 * @export
 * @interface ResendReward422Response
 */
export interface ResendReward422Response {
    /**
     *
     * @type {ListRewards401ResponseErrors}
     * @memberof ResendReward422Response
     */
    'errors': ListRewards401ResponseErrors;
}
/**
 * Flag rewards redeemed in these countries.
 * @export
 * @interface ReviewCountry
 */
export interface ReviewCountry {
    /**
     * When type is `whitelist`, it flags any countries that *are not* present in the list. When type is `blacklist`, it flags any countries that *are* present in the list.
     * @type {string}
     * @memberof ReviewCountry
     */
    'type': ReviewCountryTypeEnum;
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof ReviewCountry
     */
    'countries': Array<string>;
}
export declare const ReviewCountryTypeEnum: {
    readonly Whitelist: "whitelist";
    readonly Blacklist: "blacklist";
};
export type ReviewCountryTypeEnum = typeof ReviewCountryTypeEnum[keyof typeof ReviewCountryTypeEnum];
/**
 * List of countries where a matching redemption will trigger a review.
 * @export
 * @interface ReviewCountry1
 */
export interface ReviewCountry1 {
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof ReviewCountry1
     */
    'countries': Array<string>;
}
/**
 * Flag rewards with an email or domain matching this list.
 * @export
 * @interface ReviewEmail
 */
export interface ReviewEmail {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof ReviewEmail
     */
    'emails'?: Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof ReviewEmail
     */
    'domains'?: Array<string>;
}
/**
 * The list of emails and/or domains where a matching redemption will trigger a review. At least one email or domain is required.
 * @export
 * @interface ReviewEmail1
 */
export interface ReviewEmail1 {
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof ReviewEmail1
     */
    'emails'?: Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof ReviewEmail1
     */
    'domains'?: Array<string>;
}
/**
 * Flag rewards redeemed by an IP matching this list.
 * @export
 * @interface ReviewIp
 */
export interface ReviewIp {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof ReviewIp
     */
    'ips': Array<string>;
}
/**
 * List of IP addresses and/or IP ranges where a matching redemption will trigger a review.
 * @export
 * @interface ReviewIp1
 */
export interface ReviewIp1 {
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof ReviewIp1
     */
    'ips': Array<string>;
}
/**
 * If a recipient, device, or IP redeems more than this dollar value of rewards, flag for review.
 * @export
 * @interface ReviewRedeemedRewardsAmount
 */
export interface ReviewRedeemedRewardsAmount {
    /**
     * The total amount in USD of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof ReviewRedeemedRewardsAmount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof ReviewRedeemedRewardsAmount
     */
    'period': ReviewRedeemedRewardsAmountPeriodEnum;
}
export declare const ReviewRedeemedRewardsAmountPeriodEnum: {
    readonly _7: "7";
    readonly _30: "30";
    readonly _90: "90";
    readonly _120: "120";
    readonly _365: "365";
    readonly AllTime: "all_time";
};
export type ReviewRedeemedRewardsAmountPeriodEnum = typeof ReviewRedeemedRewardsAmountPeriodEnum[keyof typeof ReviewRedeemedRewardsAmountPeriodEnum];
/**
 * If a recipient, device, or IP redeems more than this number of rewards, flag for review.
 * @export
 * @interface ReviewRedeemedRewardsCount
 */
export interface ReviewRedeemedRewardsCount {
    /**
     * The number of redeemed rewards to use as a threshold.
     * @type {number}
     * @memberof ReviewRedeemedRewardsCount
     */
    'amount': number;
    /**
     * The period, in days, to consider for the count. Use `all_time` to consider any redeemed rewards.
     * @type {string}
     * @memberof ReviewRedeemedRewardsCount
     */
    'period': ReviewRedeemedRewardsCountPeriodEnum;
}
export declare const ReviewRedeemedRewardsCountPeriodEnum: {
    readonly _7: "7";
    readonly _30: "30";
    readonly _90: "90";
    readonly _120: "120";
    readonly _365: "365";
    readonly AllTime: "all_time";
};
export type ReviewRedeemedRewardsCountPeriodEnum = typeof ReviewRedeemedRewardsCountPeriodEnum[keyof typeof ReviewRedeemedRewardsCountPeriodEnum];
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof Reward
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof Reward
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof Reward
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof Reward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof Reward
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof Reward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof Reward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof Reward
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof Reward
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     *
     * @type {RewardWithoutLinkDelivery}
     * @memberof Reward
     */
    'delivery'?: RewardWithoutLinkDelivery;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface RewardBase
 */
export interface RewardBase {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardBase
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof RewardBase
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof RewardBase
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof RewardBase
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof RewardBase
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof RewardBase
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof RewardBase
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof RewardBase
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof RewardBase
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
}
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface RewardBaseCustomFieldsInner
 */
export interface RewardBaseCustomFieldsInner {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof RewardBaseCustomFieldsInner
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof RewardBaseCustomFieldsInner
     */
    'value'?: string | null;
    /**
     * Label of the custom field
     * @type {string}
     * @memberof RewardBaseCustomFieldsInner
     */
    'label'?: string;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface RewardForOrderCreate
 */
export interface RewardForOrderCreate {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof RewardForOrderCreate
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof RewardForOrderCreate
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof RewardForOrderCreate
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof RewardForOrderCreate
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * Set this to translate the redemption experience for this reward. Pass a 2-letter [ISO-639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the desired language. Defaults to `en`.
     * @type {string}
     * @memberof RewardForOrderCreate
     */
    'language'?: string;
    /**
     *
     * @type {SingleRewardOrder1RewardDelivery}
     * @memberof RewardForOrderCreate
     */
    'delivery'?: SingleRewardOrder1RewardDelivery;
}
/**
 * The redemption link for a reward.
 * @export
 * @interface RewardLink
 */
export interface RewardLink {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardLink
     */
    'id'?: string;
    /**
     * Link to redeem the reward at. You need to deliver this link to the recipient.
     * @type {string}
     * @memberof RewardLink
     */
    'link'?: string;
}
/**
 * The redemption token for a reward.
 * @export
 * @interface RewardToken
 */
export interface RewardToken {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardToken
     */
    'id'?: string;
    /**
     * The token to redeem the reward.
     * @type {string}
     * @memberof RewardToken
     */
    'token'?: string;
    /**
     * Date the token expires
     * @type {string}
     * @memberof RewardToken
     */
    'expires_at'?: string;
}
/**
 *
 * @export
 * @interface RewardValue
 */
export interface RewardValue {
    /**
     * Amount of the reward
     * @type {number}
     * @memberof RewardValue
     */
    'denomination': number;
    /**
     * Currency of the reward
     * @type {string}
     * @memberof RewardValue
     */
    'currency_code'?: RewardValueCurrencyCodeEnum;
}
export declare const RewardValueCurrencyCodeEnum: {
    readonly Usd: "USD";
    readonly Cad: "CAD";
    readonly Eur: "EUR";
    readonly Aed: "AED";
    readonly Afn: "AFN";
    readonly All: "ALL";
    readonly Amd: "AMD";
    readonly Ars: "ARS";
    readonly Aud: "AUD";
    readonly Azn: "AZN";
    readonly Bam: "BAM";
    readonly Bdt: "BDT";
    readonly Bgn: "BGN";
    readonly Bhd: "BHD";
    readonly Bif: "BIF";
    readonly Bnd: "BND";
    readonly Bob: "BOB";
    readonly Brl: "BRL";
    readonly Bwp: "BWP";
    readonly Byr: "BYR";
    readonly Bzd: "BZD";
    readonly Cdf: "CDF";
    readonly Chf: "CHF";
    readonly Clp: "CLP";
    readonly Cny: "CNY";
    readonly Cop: "COP";
    readonly Crc: "CRC";
    readonly Cve: "CVE";
    readonly Czk: "CZK";
    readonly Djf: "DJF";
    readonly Dkk: "DKK";
    readonly Dop: "DOP";
    readonly Dzd: "DZD";
    readonly Eek: "EEK";
    readonly Egp: "EGP";
    readonly Ern: "ERN";
    readonly Etb: "ETB";
    readonly Gbp: "GBP";
    readonly Gel: "GEL";
    readonly Ghs: "GHS";
    readonly Gnf: "GNF";
    readonly Gtq: "GTQ";
    readonly Hkd: "HKD";
    readonly Hnl: "HNL";
    readonly Hrk: "HRK";
    readonly Huf: "HUF";
    readonly Idr: "IDR";
    readonly Ils: "ILS";
    readonly Inr: "INR";
    readonly Iqd: "IQD";
    readonly Irr: "IRR";
    readonly Isk: "ISK";
    readonly Jmd: "JMD";
    readonly Jod: "JOD";
    readonly Jpy: "JPY";
    readonly Kes: "KES";
    readonly Khr: "KHR";
    readonly Krw: "KRW";
    readonly Kwd: "KWD";
    readonly Kzt: "KZT";
    readonly Lbp: "LBP";
    readonly Lkr: "LKR";
    readonly Ltl: "LTL";
    readonly Lvl: "LVL";
    readonly Mad: "MAD";
    readonly Mdl: "MDL";
    readonly Mga: "MGA";
    readonly Mkd: "MKD";
    readonly Mmk: "MMK";
    readonly Mop: "MOP";
    readonly Mur: "MUR";
    readonly Mxn: "MXN";
    readonly Myr: "MYR";
    readonly Mzn: "MZN";
    readonly Nad: "NAD";
    readonly Ngn: "NGN";
    readonly Nio: "NIO";
    readonly Nok: "NOK";
    readonly Npr: "NPR";
    readonly Nzd: "NZD";
    readonly Omr: "OMR";
    readonly Pab: "PAB";
    readonly Pen: "PEN";
    readonly Php: "PHP";
    readonly Pkr: "PKR";
    readonly Pln: "PLN";
    readonly Pyg: "PYG";
    readonly Qar: "QAR";
    readonly Ron: "RON";
    readonly Rsd: "RSD";
    readonly Rub: "RUB";
    readonly Rwf: "RWF";
    readonly Sar: "SAR";
    readonly Sdg: "SDG";
    readonly Sek: "SEK";
    readonly Sgd: "SGD";
    readonly Sos: "SOS";
    readonly Syp: "SYP";
    readonly Thb: "THB";
    readonly Tnd: "TND";
    readonly Top: "TOP";
    readonly Try: "TRY";
    readonly Ttd: "TTD";
    readonly Twd: "TWD";
    readonly Tzs: "TZS";
    readonly Uah: "UAH";
    readonly Ugx: "UGX";
    readonly Uyu: "UYU";
    readonly Uzs: "UZS";
    readonly Vef: "VEF";
    readonly Vnd: "VND";
    readonly Xaf: "XAF";
    readonly Xof: "XOF";
    readonly Yer: "YER";
    readonly Zar: "ZAR";
    readonly Zmk: "ZMK";
};
export type RewardValueCurrencyCodeEnum = typeof RewardValueCurrencyCodeEnum[keyof typeof RewardValueCurrencyCodeEnum];
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface RewardWithoutLink
 */
export interface RewardWithoutLink {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof RewardWithoutLink
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof RewardWithoutLink
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof RewardWithoutLink
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof RewardWithoutLink
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof RewardWithoutLink
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     *
     * @type {RewardWithoutLinkDelivery}
     * @memberof RewardWithoutLink
     */
    'delivery'?: RewardWithoutLinkDelivery;
}
/**
 * Details on how the reward is delivered to the recipient.
 * @export
 * @interface RewardWithoutLinkDelivery
 */
export interface RewardWithoutLinkDelivery {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof RewardWithoutLinkDelivery
     */
    'method': RewardWithoutLinkDeliveryMethodEnum;
    /**
     * Current status of the delivery of the reward:  * `SCHEDULED` - Reward is scheduled for delivery and will be delivered soon. * `FAILED` - Delivery of reward failed (e.g. email bounced). * `SUCCEEDED` - Reward was successfully delivered (email or text message delivered or reward link opened). * `PENDING` - Delivery is pending but not yet scheduled.
     * @type {string}
     * @memberof RewardWithoutLinkDelivery
     */
    'status': RewardWithoutLinkDeliveryStatusEnum;
}
export declare const RewardWithoutLinkDeliveryMethodEnum: {
    readonly Email: "EMAIL";
    readonly Link: "LINK";
    readonly Phone: "PHONE";
};
export type RewardWithoutLinkDeliveryMethodEnum = typeof RewardWithoutLinkDeliveryMethodEnum[keyof typeof RewardWithoutLinkDeliveryMethodEnum];
export declare const RewardWithoutLinkDeliveryStatusEnum: {
    readonly Scheduled: "SCHEDULED";
    readonly Failed: "FAILED";
    readonly Succeeded: "SUCCEEDED";
    readonly Pending: "PENDING";
};
export type RewardWithoutLinkDeliveryStatusEnum = typeof RewardWithoutLinkDeliveryStatusEnum[keyof typeof RewardWithoutLinkDeliveryStatusEnum];
/**
 * Each organization member is assigned a role that defines the permissions they have within the organization.
 * @export
 * @interface Role
 */
export interface Role {
    /**
     *
     * @type {string}
     * @memberof Role
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    'title': string;
    /**
     *
     * @type {string}
     * @memberof Role
     */
    'description': string;
}
/**
 *
 * @export
 * @interface SimulateWebhookRequest
 */
export interface SimulateWebhookRequest {
    /**
     * The event to test. See the [List events endpoint reference](/reference/get_webhooks-id-events) for all available events.
     * @type {string}
     * @memberof SimulateWebhookRequest
     */
    'event': string;
}
/**
 * An order that contains a single reward. The reward is sent to a single recipient.
 * @export
 * @interface SingleRewardOrder
 */
export interface SingleRewardOrder {
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof SingleRewardOrder
     */
    'external_id'?: string | null;
    /**
     *
     * @type {SingleRewardOrder1Payment}
     * @memberof SingleRewardOrder
     */
    'payment'?: SingleRewardOrder1Payment;
    /**
     *
     * @type {SingleRewardOrderReward}
     * @memberof SingleRewardOrder
     */
    'reward': SingleRewardOrderReward;
}
/**
 * An order that contains a single reward. The reward is sent to a single recipient.
 * @export
 * @interface SingleRewardOrder1
 */
export interface SingleRewardOrder1 {
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof SingleRewardOrder1
     */
    'external_id'?: string | null;
    /**
     *
     * @type {SingleRewardOrder1Payment}
     * @memberof SingleRewardOrder1
     */
    'payment'?: SingleRewardOrder1Payment;
    /**
     *
     * @type {SingleRewardOrder1Reward}
     * @memberof SingleRewardOrder1
     */
    'reward': SingleRewardOrder1Reward;
}
/**
 *
 * @export
 * @interface SingleRewardOrder1Payment
 */
export interface SingleRewardOrder1Payment {
    /**
     * Tremendous ID of the funding source that will be used to pay for the order. Use `balance` to use your Tremendous\'s balance.
     * @type {string}
     * @memberof SingleRewardOrder1Payment
     */
    'funding_source_id': string;
}
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface SingleRewardOrder1Reward
 */
export interface SingleRewardOrder1Reward {
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof SingleRewardOrder1Reward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof SingleRewardOrder1Reward
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof SingleRewardOrder1Reward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof SingleRewardOrder1Reward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof SingleRewardOrder1Reward
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<SingleRewardOrder1RewardCustomFieldsInner>}
     * @memberof SingleRewardOrder1Reward
     */
    'custom_fields'?: Array<SingleRewardOrder1RewardCustomFieldsInner>;
    /**
     * Set this to translate the redemption experience for this reward. Pass a 2-letter [ISO-639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the desired language. Defaults to `en`.
     * @type {string}
     * @memberof SingleRewardOrder1Reward
     */
    'language'?: string;
    /**
     *
     * @type {SingleRewardOrder1RewardDelivery}
     * @memberof SingleRewardOrder1Reward
     */
    'delivery'?: SingleRewardOrder1RewardDelivery;
}
/**
 * Reward custom data for searching, tracking or copy (see [Adding custom fields to orders](https://developers.tremendous.com/reference/using-custom-fields-to-add-custom-data-to-rewards).)
 * @export
 * @interface SingleRewardOrder1RewardCustomFieldsInner
 */
export interface SingleRewardOrder1RewardCustomFieldsInner {
    /**
     * Tremendous ID of the custom field
     * @type {string}
     * @memberof SingleRewardOrder1RewardCustomFieldsInner
     */
    'id'?: string;
    /**
     * Value of the custom field
     * @type {string}
     * @memberof SingleRewardOrder1RewardCustomFieldsInner
     */
    'value'?: string | null;
}
/**
 * Details on how the reward is delivered to the recipient.
 * @export
 * @interface SingleRewardOrder1RewardDelivery
 */
export interface SingleRewardOrder1RewardDelivery {
    /**
     * How to deliver the reward to the recipient.  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table>
     * @type {string}
     * @memberof SingleRewardOrder1RewardDelivery
     */
    'method'?: SingleRewardOrder1RewardDeliveryMethodEnum;
}
export declare const SingleRewardOrder1RewardDeliveryMethodEnum: {
    readonly Email: "EMAIL";
    readonly Link: "LINK";
    readonly Phone: "PHONE";
};
export type SingleRewardOrder1RewardDeliveryMethodEnum = typeof SingleRewardOrder1RewardDeliveryMethodEnum[keyof typeof SingleRewardOrder1RewardDeliveryMethodEnum];
/**
 * A single reward, sent to a recipient. A reward is always part of an order.  Either `products` or `campaign_id` must be specified.
 * @export
 * @interface SingleRewardOrderReward
 */
export interface SingleRewardOrderReward {
    /**
     * Tremendous ID of the reward
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'id'?: string;
    /**
     * Tremendous ID of the order this reward is part of.
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'order_id'?: string;
    /**
     * Date the reward was created
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'created_at'?: string;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'campaign_id'?: string | null;
    /**
     * List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.  Providing a `products` array will override the products made available by the campaign specified using the `campaign_id` property unless the `products` array is empty. It will _not_ override other campaign attributes, like the message and customization of the look and feel.
     * @type {Array<string>}
     * @memberof SingleRewardOrderReward
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerValue}
     * @memberof SingleRewardOrderReward
     */
    'value'?: ListRewards200ResponseRewardsInnerValue;
    /**
     *
     * @type {ListRewards200ResponseRewardsInnerRecipient}
     * @memberof SingleRewardOrderReward
     */
    'recipient'?: ListRewards200ResponseRewardsInnerRecipient;
    /**
     * Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'deliver_at'?: string;
    /**
     *
     * @type {Array<RewardBaseCustomFieldsInner>}
     * @memberof SingleRewardOrderReward
     */
    'custom_fields'?: Array<RewardBaseCustomFieldsInner>;
    /**
     * Set this to translate the redemption experience for this reward. Pass a 2-letter [ISO-639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the desired language. Defaults to `en`.
     * @type {string}
     * @memberof SingleRewardOrderReward
     */
    'language'?: string;
    /**
     *
     * @type {SingleRewardOrder1RewardDelivery}
     * @memberof SingleRewardOrderReward
     */
    'delivery'?: SingleRewardOrder1RewardDelivery;
}
/**
 *
 * @export
 * @interface SingleRewardOrderWithoutLink
 */
export interface SingleRewardOrderWithoutLink {
    /**
     *
     * @type {SingleRewardOrderWithoutLinkOrder}
     * @memberof SingleRewardOrderWithoutLink
     */
    'order': SingleRewardOrderWithoutLinkOrder;
}
/**
 * An order wraps around the fulfilment of one or more rewards.
 * @export
 * @interface SingleRewardOrderWithoutLinkOrder
 */
export interface SingleRewardOrderWithoutLinkOrder {
    /**
     * Tremendous ID of the order
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'id': string;
    /**
     * Reference for this order, supplied by the customer.  When set, `external_id` makes order idempotent. All requests that use the same `external_id` after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a `201` response code. These responses **fail** to create any further orders.  It also allows for retrieving by `external_id` instead of `id` only.
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'external_id'?: string | null;
    /**
     * ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'campaign_id'?: string | null;
    /**
     * Date the order has been created
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'created_at': string;
    /**
     * Execution status of a given order  <table>   <thead>     <tr>       <th>         Status       </th>       <th>         Description       </th>     </tr>   </thead>   <tbody>     <tr>       <td>         <code>           CANCELED         </code>       </td>       <td>         The order and all of its rewards were canceled.       </td>     </tr>     <tr>       <td>         <code>           CART         </code>       </td>       <td>         The order has been created, but hasn\'t yet been processed.       </td>     </tr>     <tr>       <td>         <code>           EXECUTED         </code>       </td>       <td>         The order has been executed. Payment has been handled and rewards are being delivered (if applicable).       </td>     </tr>     <tr>       <td>         <code>           FAILED         </code>       </td>       <td>         The order could not be processed due to an error. E.g. due to insufficient funds in the account.       </td>     </tr>     <tr>       <td>         <code>           PENDING APPROVAL         </code>       </td>       <td>         The order has been created but needs approval to be executed.       </td>     </tr>     <tr>       <td>         <code>           PENDING INTERNAL PAYMENT APPROVAL         </code>       </td>       <td>         The order has been created but it is under review and requires approval from our team.       </td>     </tr>    </tbody> </table>
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'status': SingleRewardOrderWithoutLinkOrderStatusEnum;
    /**
     *
     * @type {OrderBasePayment}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'payment'?: OrderBasePayment;
    /**
     * The ID for the invoice associated with this order
     * @type {string}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'invoice_id'?: string;
    /**
     *
     * @type {OrderWithoutLinkReward}
     * @memberof SingleRewardOrderWithoutLinkOrder
     */
    'reward'?: OrderWithoutLinkReward;
}
export declare const SingleRewardOrderWithoutLinkOrderStatusEnum: {
    readonly Canceled: "CANCELED";
    readonly Cart: "CART";
    readonly Executed: "EXECUTED";
    readonly Failed: "FAILED";
    readonly PendingApproval: "PENDING APPROVAL";
    readonly PendingInternalPaymentApproval: "PENDING INTERNAL PAYMENT APPROVAL";
};
export type SingleRewardOrderWithoutLinkOrderStatusEnum = typeof SingleRewardOrderWithoutLinkOrderStatusEnum[keyof typeof SingleRewardOrderWithoutLinkOrderStatusEnum];
/**
 *
 * @export
 * @interface TestPublicKey
 */
export interface TestPublicKey {
    /**
     * A JWT token encoded with RS256, signed using the RSA private key corresponding to your public key.
     * @type {string}
     * @memberof TestPublicKey
     */
    'jwt': string;
}
/**
 *
 * @export
 * @interface TestPublicKeyRequest
 */
export interface TestPublicKeyRequest {
    /**
     * A JWT token encoded with RS256, signed using the RSA private key corresponding to your public key.
     * @type {string}
     * @memberof TestPublicKeyRequest
     */
    'jwt': string;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from.
 * @export
 * @interface UpdateCampaign
 */
export interface UpdateCampaign {
    /**
     *
     * @type {string}
     * @memberof UpdateCampaign
     */
    'id'?: string;
    /**
     * Name of the campaign
     * @type {string}
     * @memberof UpdateCampaign
     */
    'name'?: string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof UpdateCampaign
     */
    'description'?: string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign.
     * @type {Array<string>}
     * @memberof UpdateCampaign
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof UpdateCampaign
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof UpdateCampaign
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 * With a campaign you can define the look & feel of how rewards are sent out. It also lets you set the available products (different gift cards, charity, etc.) recipients can choose from.
 * @export
 * @interface UpdateCampaignRequest
 */
export interface UpdateCampaignRequest {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof UpdateCampaignRequest
     */
    'name'?: string;
    /**
     * Description of the campaign
     * @type {string}
     * @memberof UpdateCampaignRequest
     */
    'description'?: string | null;
    /**
     * List of IDs of products (different gift cards, charity, etc.) that are available in this campaign.
     * @type {Array<string>}
     * @memberof UpdateCampaignRequest
     */
    'products'?: Array<string>;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerWebpageStyle}
     * @memberof UpdateCampaignRequest
     */
    'webpage_style'?: ListCampaigns200ResponseCampaignsInnerWebpageStyle;
    /**
     *
     * @type {ListCampaigns200ResponseCampaignsInnerEmailStyle}
     * @memberof UpdateCampaignRequest
     */
    'email_style'?: ListCampaigns200ResponseCampaignsInnerEmailStyle;
}
/**
 *
 * @export
 * @interface UpdateFraudRuleList200Response
 */
export interface UpdateFraudRuleList200Response {
    /**
     * A description of the result
     * @type {string}
     * @memberof UpdateFraudRuleList200Response
     */
    'message': string;
}
/**
 *
 * @export
 * @interface UpdateFraudRuleListRequest
 */
export interface UpdateFraudRuleListRequest {
    /**
     * * `add` - append the list to the same key of the current configuration * `remove` - remove the entries in the list from the same key of the current configuration
     * @type {string}
     * @memberof UpdateFraudRuleListRequest
     */
    'operation': UpdateFraudRuleListRequestOperationEnum;
    /**
     *
     * @type {UpdateFraudRuleListRequestConfig}
     * @memberof UpdateFraudRuleListRequest
     */
    'config': UpdateFraudRuleListRequestConfig;
}
export declare const UpdateFraudRuleListRequestOperationEnum: {
    readonly Add: "add";
    readonly Remove: "remove";
};
export type UpdateFraudRuleListRequestOperationEnum = typeof UpdateFraudRuleListRequestOperationEnum[keyof typeof UpdateFraudRuleListRequestOperationEnum];
/**
 * The configuration associated with the rule. The properties allowed depend on the type of rule.
 * @export
 * @interface UpdateFraudRuleListRequestConfig
 */
export interface UpdateFraudRuleListRequestConfig {
    /**
     * An array of country codes (ISO-3166 alpha-2 character code)
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'countries': Array<string>;
    /**
     * The list of IP addresses to flag or allow. Accepts both IPv4 and IPv6 addresses using CIDR notation.
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'ips': Array<string>;
    /**
     * The list of emails.
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'emails': Array<string>;
    /**
     * The list of domains. Any subdomains will also be matched against each entry in the list.
     * @type {Array<string>}
     * @memberof UpdateFraudRuleListRequestConfig
     */
    'domains'?: Array<string>;
}
/**
 *
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     *
     * @type {string}
     * @memberof Webhook
     */
    'id'?: string;
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof Webhook
     */
    'url': string | null;
    /**
     * Private key for the webhook
     * @type {string}
     * @memberof Webhook
     */
    'private_key'?: string;
}
/**
 *
 * @export
 * @interface WebhookPost
 */
export interface WebhookPost {
    /**
     * URL the webhook will make requests to
     * @type {string}
     * @memberof WebhookPost
     */
    'url': string;
}
/**
 * BalanceTransactionsApi - axios parameter creator
 * @export
 */
export declare const BalanceTransactionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Fetch a list of all balance transactions on your account.
     * @summary List balance transactions
     * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBalanceTransactions: (offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * BalanceTransactionsApi - functional programming interface
 * @export
 */
export declare const BalanceTransactionsApiFp: (configuration?: Configuration) => {
    /**
     * Fetch a list of all balance transactions on your account.
     * @summary List balance transactions
     * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBalanceTransactions(offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBalanceTransactions200Response>>;
};
/**
 * BalanceTransactionsApi - factory interface
 * @export
 */
export declare const BalanceTransactionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetch a list of all balance transactions on your account.
     * @summary List balance transactions
     * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBalanceTransactions(offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: any): AxiosPromise<ListBalanceTransactions200Response>;
};
/**
 * BalanceTransactionsApi - object-oriented interface
 * @export
 * @class BalanceTransactionsApi
 * @extends {BaseAPI}
 */
export declare class BalanceTransactionsApi extends BaseAPI {
    /**
     * Fetch a list of all balance transactions on your account.
     * @summary List balance transactions
     * @param {number} [offset] Offsets the returned list by the given number of transactions. The returned transactions are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of transactions listed. The default value is 10.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionsApi
     */
    listBalanceTransactions(offset?: number, limit?: number, createdAtGte?: string, createdAtLte?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListBalanceTransactions200Response, any>>;
}
/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export declare const CampaignsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCampaign: (createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a campaign, identified by the given `id` in the URL
     * @summary Retrieve campaign
     * @param {string} id ID of the campaign that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCampaign: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of all campaigns created in your account
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCampaigns: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Update campaign
     * @param {string} id ID of the campaign that should be updated
     * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCampaign: (id: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * CampaignsApi - functional programming interface
 * @export
 */
export declare const CampaignsApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>>;
    /**
     * Retrieve a campaign, identified by the given `id` in the URL
     * @summary Retrieve campaign
     * @param {string} id ID of the campaign that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCampaign(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>>;
    /**
     * Retrieve a list of all campaigns created in your account
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCampaigns(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCampaigns200Response>>;
    /**
     *
     * @summary Update campaign
     * @param {string} id ID of the campaign that should be updated
     * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCampaign(id: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>>;
};
/**
 * CampaignsApi - factory interface
 * @export
 */
export declare const CampaignsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCampaign(createCampaignRequest: CreateCampaignRequest, options?: any): AxiosPromise<CreateCampaign201Response>;
    /**
     * Retrieve a campaign, identified by the given `id` in the URL
     * @summary Retrieve campaign
     * @param {string} id ID of the campaign that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCampaign(id: string, options?: any): AxiosPromise<CreateCampaign201Response>;
    /**
     * Retrieve a list of all campaigns created in your account
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCampaigns(options?: any): AxiosPromise<ListCampaigns200Response>;
    /**
     *
     * @summary Update campaign
     * @param {string} id ID of the campaign that should be updated
     * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCampaign(id: string, updateCampaignRequest: UpdateCampaignRequest, options?: any): AxiosPromise<CreateCampaign201Response>;
};
/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export declare class CampaignsApi extends BaseAPI {
    /**
     *
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateCampaign201Response, any>>;
    /**
     * Retrieve a campaign, identified by the given `id` in the URL
     * @summary Retrieve campaign
     * @param {string} id ID of the campaign that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    getCampaign(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateCampaign201Response, any>>;
    /**
     * Retrieve a list of all campaigns created in your account
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    listCampaigns(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListCampaigns200Response, any>>;
    /**
     *
     * @summary Update campaign
     * @param {string} id ID of the campaign that should be updated
     * @param {UpdateCampaignRequest} updateCampaignRequest Campaign details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    updateCampaign(id: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateCampaign201Response, any>>;
}
/**
 * FieldsApi - axios parameter creator
 * @export
 */
export declare const FieldsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
     * @summary List fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFields: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FieldsApi - functional programming interface
 * @export
 */
export declare const FieldsApiFp: (configuration?: Configuration) => {
    /**
     * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
     * @summary List fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFields(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFields200Response>>;
};
/**
 * FieldsApi - factory interface
 * @export
 */
export declare const FieldsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
     * @summary List fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFields(options?: any): AxiosPromise<ListFields200Response>;
};
/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export declare class FieldsApi extends BaseAPI {
    /**
     * For reporting and analytics purposes, custom fields can be associated with rewards generated through the API. Custom fields must be first added by members of your admin team through the Tremendous Dashboard.
     * @summary List fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    listFields(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListFields200Response, any>>;
}
/**
 * ForexApi - axios parameter creator
 * @export
 */
export declare const ForexApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve a list of exchange rates
     * @summary List exchange rates
     * @param {string} [base] Base currency code, default is USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listForex: (base?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ForexApi - functional programming interface
 * @export
 */
export declare const ForexApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve a list of exchange rates
     * @summary List exchange rates
     * @param {string} [base] Base currency code, default is USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listForex(base?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListForexResponse>>;
};
/**
 * ForexApi - factory interface
 * @export
 */
export declare const ForexApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve a list of exchange rates
     * @summary List exchange rates
     * @param {string} [base] Base currency code, default is USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listForex(base?: string, options?: any): AxiosPromise<ListForexResponse>;
};
/**
 * ForexApi - object-oriented interface
 * @export
 * @class ForexApi
 * @extends {BaseAPI}
 */
export declare class ForexApi extends BaseAPI {
    /**
     * Retrieve a list of exchange rates
     * @summary List exchange rates
     * @param {string} [base] Base currency code, default is USD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForexApi
     */
    listForex(base?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListForexResponse, any>>;
}
/**
 * FraudReviewsApi - axios parameter creator
 * @export
 */
export declare const FraudReviewsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
     * @summary Block fraud review
     * @param {string} id The ID of the reward that should be blocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockFraudReview: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
     * @summary Retrieve single fraud review
     * @param {string} id The ID of the reward that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFraudReview: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
     * @summary List fraud reviews
     * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
     * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
     * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
     * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFraudReviews: (offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
     * @summary Release fraud review
     * @param {string} id The ID of the reward that should be released.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releaseFraudReview: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FraudReviewsApi - functional programming interface
 * @export
 */
export declare const FraudReviewsApiFp: (configuration?: Configuration) => {
    /**
     * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
     * @summary Block fraud review
     * @param {string} id The ID of the reward that should be blocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFraudReview200Response>>;
    /**
     * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
     * @summary Retrieve single fraud review
     * @param {string} id The ID of the reward that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFraudReview200Response>>;
    /**
     * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
     * @summary List fraud reviews
     * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
     * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
     * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
     * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFraudReviews(offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFraudReviews200Response>>;
    /**
     * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
     * @summary Release fraud review
     * @param {string} id The ID of the reward that should be released.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releaseFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFraudReview200Response>>;
};
/**
 * FraudReviewsApi - factory interface
 * @export
 */
export declare const FraudReviewsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
     * @summary Block fraud review
     * @param {string} id The ID of the reward that should be blocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockFraudReview(id: string, options?: any): AxiosPromise<GetFraudReview200Response>;
    /**
     * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
     * @summary Retrieve single fraud review
     * @param {string} id The ID of the reward that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFraudReview(id: string, options?: any): AxiosPromise<GetFraudReview200Response>;
    /**
     * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
     * @summary List fraud reviews
     * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
     * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
     * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
     * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFraudReviews(offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: any): AxiosPromise<ListFraudReviews200Response>;
    /**
     * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
     * @summary Release fraud review
     * @param {string} id The ID of the reward that should be released.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    releaseFraudReview(id: string, options?: any): AxiosPromise<GetFraudReview200Response>;
};
/**
 * FraudReviewsApi - object-oriented interface
 * @export
 * @class FraudReviewsApi
 * @extends {BaseAPI}
 */
export declare class FraudReviewsApi extends BaseAPI {
    /**
     * Completes the fraud review identified by the given `id` in the URL, and blocks the reward. The reward is canceled and the amount refunded.
     * @summary Block fraud review
     * @param {string} id The ID of the reward that should be blocked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    blockFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetFraudReview200Response, any>>;
    /**
     * Retrieve the details of a fraud review, identified by the given `id` in the URL. Returns additional details regarding the fraud review beyond what\'s provided in the List fraud reviews endpoint, including reward details, recipient geolocation, etc.
     * @summary Retrieve single fraud review
     * @param {string} id The ID of the reward that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    getFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetFraudReview200Response, any>>;
    /**
     * Retrieve a paginated list of all fraud reviews. List can be filtered by status, created or redeemed at dates.
     * @summary List fraud reviews
     * @param {number} [offset] Offsets the returned list by the given number of records. The returned fraud reviews are ordered (and offsetted) by their redemption date (DESC).
     * @param {number} [limit] Limits the number of fraud reviews listed. The default value is 10.
     * @param {ListFraudReviewsStatusEnum} [status] Filters fraud reviews by status. Can be &#x60;flagged&#x60;, &#x60;blocked&#x60; or &#x60;released&#x60;.
     * @param {string} [createdAtGte] Return results where the created_at field is &gt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [createdAtLte] Return results where the created_at field is &lt;&#x3D; to the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtGte] Return results where the redeemed_at field is &gt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {string} [redeemedAtLte] Return results where the redeemed_at field is &lt;&#x3D; the supplied value. Expects an ISO 8601 datetime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    listFraudReviews(offset?: number, limit?: number, status?: ListFraudReviewsStatusEnum, createdAtGte?: string, createdAtLte?: string, redeemedAtGte?: string, redeemedAtLte?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListFraudReviews200Response, any>>;
    /**
     * Completes the fraud review identified by the given `id` in the URL, and releases the associated reward to the recipient.
     * @summary Release fraud review
     * @param {string} id The ID of the reward that should be released.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudReviewsApi
     */
    releaseFraudReview(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetFraudReview200Response, any>>;
}
/**
 * @export
 */
export declare const ListFraudReviewsStatusEnum: {
    readonly Flagged: "flagged";
    readonly Blocked: "blocked";
    readonly Released: "released";
};
export type ListFraudReviewsStatusEnum = typeof ListFraudReviewsStatusEnum[keyof typeof ListFraudReviewsStatusEnum];
/**
 * FraudRulesApi - axios parameter creator
 * @export
 */
export declare const FraudRulesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes the rule of the type passed in the URL.
     * @summary Delete fraud rule
     * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFraudRule: (ruleType: DeleteFraudRuleRuleTypeEnum, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
     * @summary Configure fraud rule
     * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fraudRule: (ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List active fraud rules associated with the organization tied to your API key.
     * @summary List fraud rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFraudRules: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
     * @summary Update fraud rule list
     * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
     * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFraudRuleList: (ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FraudRulesApi - functional programming interface
 * @export
 */
export declare const FraudRulesApiFp: (configuration?: Configuration) => {
    /**
     * Deletes the rule of the type passed in the URL.
     * @summary Delete fraud rule
     * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFraudRule(ruleType: DeleteFraudRuleRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFraudRule200Response>>;
    /**
     * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
     * @summary Configure fraud rule
     * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fraudRule(ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudRule200Response>>;
    /**
     * List active fraud rules associated with the organization tied to your API key.
     * @summary List fraud rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFraudRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFraudRules200Response>>;
    /**
     * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
     * @summary Update fraud rule list
     * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
     * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFraudRuleList(ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateFraudRuleList200Response>>;
};
/**
 * FraudRulesApi - factory interface
 * @export
 */
export declare const FraudRulesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes the rule of the type passed in the URL.
     * @summary Delete fraud rule
     * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFraudRule(ruleType: DeleteFraudRuleRuleTypeEnum, options?: any): AxiosPromise<DeleteFraudRule200Response>;
    /**
     * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
     * @summary Configure fraud rule
     * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fraudRule(ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: any): AxiosPromise<FraudRule200Response>;
    /**
     * List active fraud rules associated with the organization tied to your API key.
     * @summary List fraud rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFraudRules(options?: any): AxiosPromise<ListFraudRules200Response>;
    /**
     * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
     * @summary Update fraud rule list
     * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
     * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFraudRuleList(ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: any): AxiosPromise<UpdateFraudRuleList200Response>;
};
/**
 * FraudRulesApi - object-oriented interface
 * @export
 * @class FraudRulesApi
 * @extends {BaseAPI}
 */
export declare class FraudRulesApi extends BaseAPI {
    /**
     * Deletes the rule of the type passed in the URL.
     * @summary Delete fraud rule
     * @param {DeleteFraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    deleteFraudRule(ruleType: DeleteFraudRuleRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<DeleteFraudRule200Response, any>>;
    /**
     * Configure a fraud rule of the type passed in the URL. If a rule of the same type already exists, it will be overwritten.
     * @summary Configure fraud rule
     * @param {FraudRuleRuleTypeEnum} ruleType The rule type to create or update.
     * @param {FraudRuleRequest} [fraudRuleRequest] Rules &#x60;review_multiple_emails&#x60;, &#x60;review_vpn&#x60;, &#x60;review_tremendous_flaglist&#x60;, and &#x60;review_previously_blocked_recipients&#x60; require no body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    fraudRule(ruleType: FraudRuleRuleTypeEnum, fraudRuleRequest?: FraudRuleRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<FraudRule200Response, any>>;
    /**
     * List active fraud rules associated with the organization tied to your API key.
     * @summary List fraud rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    listFraudRules(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListFraudRules200Response, any>>;
    /**
     * Use this endpoint to modify a list associated with an already-configured rule. Add and remove operations supported.  For example, to append new IPs to the `review_ip` rule, a valid JSON body would be: ```json   {     \"operation\": \"add\",     \"config\": {       \"ips\": [\"123.123.123.123\"]     }   } ```
     * @summary Update fraud rule list
     * @param {UpdateFraudRuleListRuleTypeEnum} ruleType The rule type to create or update.
     * @param {UpdateFraudRuleListRequest} updateFraudRuleListRequest The lists to add or remove from the current configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudRulesApi
     */
    updateFraudRuleList(ruleType: UpdateFraudRuleListRuleTypeEnum, updateFraudRuleListRequest: UpdateFraudRuleListRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<UpdateFraudRuleList200Response, any>>;
}
/**
 * @export
 */
export declare const DeleteFraudRuleRuleTypeEnum: {
    readonly ReviewCountry: "review_country";
    readonly ReviewIp: "review_ip";
    readonly ReviewEmail: "review_email";
    readonly ReviewRedeemedRewardsCount: "review_redeemed_rewards_count";
    readonly ReviewRedeemedRewardsAmount: "review_redeemed_rewards_amount";
    readonly ReviewMultipleEmails: "review_multiple_emails";
    readonly ReviewVpn: "review_vpn";
    readonly ReviewTremendousFlagList: "review_tremendous_flag_list";
    readonly ReviewPreviouslyBlockedRecipients: "review_previously_blocked_recipients";
    readonly AllowIp: "allow_ip";
    readonly AllowEmail: "allow_email";
};
export type DeleteFraudRuleRuleTypeEnum = typeof DeleteFraudRuleRuleTypeEnum[keyof typeof DeleteFraudRuleRuleTypeEnum];
/**
 * @export
 */
export declare const FraudRuleRuleTypeEnum: {
    readonly ReviewCountry: "review_country";
    readonly ReviewIp: "review_ip";
    readonly ReviewEmail: "review_email";
    readonly ReviewRedeemedRewardsCount: "review_redeemed_rewards_count";
    readonly ReviewRedeemedRewardsAmount: "review_redeemed_rewards_amount";
    readonly ReviewMultipleEmails: "review_multiple_emails";
    readonly ReviewVpn: "review_vpn";
    readonly ReviewTremendousFlagList: "review_tremendous_flag_list";
    readonly ReviewPreviouslyBlockedRecipients: "review_previously_blocked_recipients";
    readonly AllowIp: "allow_ip";
    readonly AllowEmail: "allow_email";
};
export type FraudRuleRuleTypeEnum = typeof FraudRuleRuleTypeEnum[keyof typeof FraudRuleRuleTypeEnum];
/**
 * @export
 */
export declare const UpdateFraudRuleListRuleTypeEnum: {
    readonly ReviewCountry: "review_country";
    readonly ReviewIp: "review_ip";
    readonly ReviewEmail: "review_email";
    readonly AllowIp: "allow_ip";
    readonly AllowEmail: "allow_email";
};
export type UpdateFraudRuleListRuleTypeEnum = typeof UpdateFraudRuleListRuleTypeEnum[keyof typeof UpdateFraudRuleListRuleTypeEnum];
/**
 * FundingSourcesApi - axios parameter creator
 * @export
 */
export declare const FundingSourcesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve a funding source, identified by the given `id` in the URL
     * @summary Retrieve funding source
     * @param {string} id ID of the funding source that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFundingSource: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
     * @summary List funding sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFundingSources: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FundingSourcesApi - functional programming interface
 * @export
 */
export declare const FundingSourcesApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve a funding source, identified by the given `id` in the URL
     * @summary Retrieve funding source
     * @param {string} id ID of the funding source that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFundingSource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFundingSource200Response>>;
    /**
     * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
     * @summary List funding sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFundingSources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFundingSources200Response>>;
};
/**
 * FundingSourcesApi - factory interface
 * @export
 */
export declare const FundingSourcesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve a funding source, identified by the given `id` in the URL
     * @summary Retrieve funding source
     * @param {string} id ID of the funding source that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFundingSource(id: string, options?: any): AxiosPromise<GetFundingSource200Response>;
    /**
     * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
     * @summary List funding sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFundingSources(options?: any): AxiosPromise<ListFundingSources200Response>;
};
/**
 * FundingSourcesApi - object-oriented interface
 * @export
 * @class FundingSourcesApi
 * @extends {BaseAPI}
 */
export declare class FundingSourcesApi extends BaseAPI {
    /**
     * Retrieve a funding source, identified by the given `id` in the URL
     * @summary Retrieve funding source
     * @param {string} id ID of the funding source that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    getFundingSource(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetFundingSource200Response, any>>;
    /**
     * Retrieve a list of all funding sources available for ordering through the API in your organization\'s account.
     * @summary List funding sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    listFundingSources(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListFundingSources200Response, any>>;
}
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export declare const InvoicesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create invoice
     * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice: (createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
     * @summary Delete invoice
     * @param {string} id ID of the invoice that should be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoices: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generates a CSV version for an invoice listing the associated rewards and orders
     * @summary Retrieve invoice as CSV
     * @param {string} id ID of the Invoice for that the CSV should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoiceCsv: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generates a PDF version for an invoice
     * @summary Retrieve invoice as PDF
     * @param {string} id ID of the Invoice for that the PDF should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoicePdf: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
     * @summary Retrieve invoice
     * @param {string} id ID of the invoice that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoice: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices.
     * @summary List invoices
     * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvoices: (offset?: number, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InvoicesApi - functional programming interface
 * @export
 */
export declare const InvoicesApiFp: (configuration?: Configuration) => {
    /**
     * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create invoice
     * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoice200Response>>;
    /**
     * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
     * @summary Delete invoice
     * @param {string} id ID of the invoice that should be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoices(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoice200Response>>;
    /**
     * Generates a CSV version for an invoice listing the associated rewards and orders
     * @summary Retrieve invoice as CSV
     * @param {string} id ID of the Invoice for that the CSV should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoiceCsv(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Generates a PDF version for an invoice
     * @summary Retrieve invoice as PDF
     * @param {string} id ID of the Invoice for that the PDF should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoicePdf(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>>;
    /**
     * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
     * @summary Retrieve invoice
     * @param {string} id ID of the invoice that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoice(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoice200Response>>;
    /**
     * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices.
     * @summary List invoices
     * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvoices(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListInvoices200Response>>;
};
/**
 * InvoicesApi - factory interface
 * @export
 */
export declare const InvoicesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create invoice
     * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: any): AxiosPromise<CreateInvoice200Response>;
    /**
     * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
     * @summary Delete invoice
     * @param {string} id ID of the invoice that should be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoices(id: string, options?: any): AxiosPromise<CreateInvoice200Response>;
    /**
     * Generates a CSV version for an invoice listing the associated rewards and orders
     * @summary Retrieve invoice as CSV
     * @param {string} id ID of the Invoice for that the CSV should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoiceCsv(id: string, options?: any): AxiosPromise<string>;
    /**
     * Generates a PDF version for an invoice
     * @summary Retrieve invoice as PDF
     * @param {string} id ID of the Invoice for that the PDF should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoicePdf(id: string, options?: any): AxiosPromise<File>;
    /**
     * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
     * @summary Retrieve invoice
     * @param {string} id ID of the invoice that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoice(id: string, options?: any): AxiosPromise<CreateInvoice200Response>;
    /**
     * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices.
     * @summary List invoices
     * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInvoices(offset?: number, limit?: number, options?: any): AxiosPromise<ListInvoices200Response>;
};
/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export declare class InvoicesApi extends BaseAPI {
    /**
     * Creating an invoice is the way for your organization to fund your account\'s balance.  1. Create an invoice 2. Pay the invoice 3. Funds get added to your account\'s balance  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">po_number</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference to the purchase order number within your organization</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">amount</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the invoice in USD</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">memo</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>A note to be included in the invoice. This is for your internal use and will not be visible to the recipient.</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create invoice
     * @param {CreateInvoiceRequest} createInvoiceRequest Invoice details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    createInvoice(createInvoiceRequest: CreateInvoiceRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateInvoice200Response, any>>;
    /**
     * Removes an invoice. This has no further consequences but is a rather cosmetic operation.
     * @summary Delete invoice
     * @param {string} id ID of the invoice that should be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    deleteInvoices(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateInvoice200Response, any>>;
    /**
     * Generates a CSV version for an invoice listing the associated rewards and orders
     * @summary Retrieve invoice as CSV
     * @param {string} id ID of the Invoice for that the CSV should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    downloadInvoiceCsv(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
    /**
     * Generates a PDF version for an invoice
     * @summary Retrieve invoice as PDF
     * @param {string} id ID of the Invoice for that the PDF should be generated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    downloadInvoicePdf(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<File, any>>;
    /**
     * Retrieve an invoice, identified by the given `id` in the URL  > 📘 Deleted Invoices > > This endpoint can be used to retrieve details on deleted invoices > that the list of invoices omits.
     * @summary Retrieve invoice
     * @param {string} id ID of the invoice that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    getInvoice(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateInvoice200Response, any>>;
    /**
     * Fetch a list of all invoices on your account.  > 🚧 Deleted invoices are omitted > > The response does not include any previously deleted invoices.
     * @summary List invoices
     * @param {number} [offset] Offsets the returned list by the given number of invoices. The returned invoices are ordered (and offsetted) by their creation date (DESC).
     * @param {number} [limit] Limits the number of invoices listed. The maximum and default value is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    listInvoices(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListInvoices200Response, any>>;
}
/**
 * MembersApi - axios parameter creator
 * @export
 */
export declare const MembersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
     * @summary Create member
     * @param {CreateMemberRequest} createMemberRequest Member details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember: (createMemberRequest: CreateMemberRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve member
     * @param {string} id ID of the member to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMember: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
     * @summary List members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMembers: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MembersApi - functional programming interface
 * @export
 */
export declare const MembersApiFp: (configuration?: Configuration) => {
    /**
     * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
     * @summary Create member
     * @param {CreateMemberRequest} createMemberRequest Member details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember(createMemberRequest: CreateMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMember200Response>>;
    /**
     *
     * @summary Retrieve member
     * @param {string} id ID of the member to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMember(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMember200Response>>;
    /**
     * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
     * @summary List members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMembers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMembers200Response>>;
};
/**
 * MembersApi - factory interface
 * @export
 */
export declare const MembersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
     * @summary Create member
     * @param {CreateMemberRequest} createMemberRequest Member details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember(createMemberRequest: CreateMemberRequest, options?: any): AxiosPromise<CreateMember200Response>;
    /**
     *
     * @summary Retrieve member
     * @param {string} id ID of the member to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMember(id: string, options?: any): AxiosPromise<GetMember200Response>;
    /**
     * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
     * @summary List members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMembers(options?: any): AxiosPromise<ListMembers200Response>;
};
/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export declare class MembersApi extends BaseAPI {
    /**
     * Each organization has one or more users that can access and manage that organization. These users are called members.  Members can take actions via the Tremendous web dashboard directly. These actions include adding funding sources to the organization, creating Campaigns, and more.  ### Permissions  Members can have a role that determine their permissions within the organization. Check the Roles API for the available roles.  To create members of a sub-organizations [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the create member request.  ### Inviting new members  After creating a member, an automatic invite is sent to the email address. If the user is not registered yet, that person will then need to sign up for a Tremendous account.  > ❗️ Automatic invitations are not available in the sandbox > > You must manually use the returned `invite_url` field in the payload instead.
     * @summary Create member
     * @param {CreateMemberRequest} createMemberRequest Member details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    createMember(createMemberRequest: CreateMemberRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateMember200Response, any>>;
    /**
     *
     * @summary Retrieve member
     * @param {string} id ID of the member to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    getMember(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetMember200Response, any>>;
    /**
     * To list members of a sub-organization [create an API key for that organization](/reference/post_organizations-id-create-api-key) first, then use the new API key in the list members request.
     * @summary List members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    listMembers(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListMembers200Response, any>>;
}
/**
 * OrdersApi - axios parameter creator
 * @export
 */
export declare const OrdersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Approve order
     * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveOrder: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
     * @summary Create order
     * @param {CreateOrderRequest} createOrderRequest Order to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder: (createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the order, identified by the given `id` in the URL
     * @summary Retrieve order
     * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of orders
     * @summary List orders
     * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
     * @param {string} [campaignId] Only return results with a matching campaign_id.
     * @param {string} [externalId] Only return results with a matching external_id.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders: (offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Reject order
     * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectOrder: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
export declare const OrdersApiFp: (configuration?: Configuration) => {
    /**
     * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Approve order
     * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>>;
    /**
     * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
     * @summary Create order
     * @param {CreateOrderRequest} createOrderRequest Order to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>>;
    /**
     * Retrieve the order, identified by the given `id` in the URL
     * @summary Retrieve order
     * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>>;
    /**
     * Retrieve a list of orders
     * @summary List orders
     * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
     * @param {string} [campaignId] Only return results with a matching campaign_id.
     * @param {string} [externalId] Only return results with a matching external_id.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders(offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrders200Response>>;
    /**
     * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Reject order
     * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder200Response>>;
};
/**
 * OrdersApi - factory interface
 * @export
 */
export declare const OrdersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Approve order
     * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveOrder(id: string, options?: any): AxiosPromise<CreateOrder200Response>;
    /**
     * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
     * @summary Create order
     * @param {CreateOrderRequest} createOrderRequest Order to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder(createOrderRequest: CreateOrderRequest, options?: any): AxiosPromise<CreateOrder200Response>;
    /**
     * Retrieve the order, identified by the given `id` in the URL
     * @summary Retrieve order
     * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(id: string, options?: any): AxiosPromise<CreateOrder200Response>;
    /**
     * Retrieve a list of orders
     * @summary List orders
     * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
     * @param {string} [campaignId] Only return results with a matching campaign_id.
     * @param {string} [externalId] Only return results with a matching external_id.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrders(offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: any): AxiosPromise<ListOrders200Response>;
    /**
     * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Reject order
     * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectOrder(id: string, options?: any): AxiosPromise<CreateOrder200Response>;
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export declare class OrdersApi extends BaseAPI {
    /**
     * Approves an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Approve order
     * @param {string} id ID of the order that should be approved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    approveOrder(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateOrder200Response, any>>;
    /**
     * Every time you want to send out a reward through Tremendous you need to create an order for it.  > 📘 Getting started with your first order > > Our step-by-step guide walks you through everything you need > to send your first gift card through the Tremendous API: > > <strong><a style=\"display: block; margin-top: 20px;\" href=\"/docs/sending-rewards-intro\">Check it out!</a></strong>  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">external_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Reference for this order, supplied by the customer.</p>  <p>When set, <code>external_id</code> makes order idempotent. All requests that use the same <code>external_id</code> after the initial order creation, will result in a response that returns the data of the initially created order. The response will have a <code>201</code> response code. These responses <strong>fail</strong> to create any further orders.</p>  <p>It also allows for retrieving by <code>external_id</code> instead of <code>id</code> only.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">payment</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">funding_source_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the funding source that will be used to pay for the order. Use <code>balance</code> to use your Tremendous&#39;s balance.</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">reward</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>A single reward, sent to a recipient. A reward is always part of an order.</p>  <p>Either <code>products</code> or <code>campaign_id</code> must be specified.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the reward</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">order_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the order this reward is part of.</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">created_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date-time</span></td><td><p>Date the reward was created</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">campaign_id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>ID of the campaign in your account, that defines the available products (different gift cards, charity, etc.) that the recipient can choose from.</p> </td></tr> <tr class=\"property-conditional-hint-request-only\"><td><div class=\"property-name\">   <code class=\"property-name\">products</code> </div> </td><td><span class=\"property-type\">array</span> <span class=\"property-format\">string</span></td><td><p>List of IDs of product (different gift cards, charity, etc.) that will be available to the recipient to choose from.</p>  <p>Providing a <code>products</code> array will override the products made available by the campaign specified using the <code>campaign_id</code> property unless the <code>products</code> array is empty. It will <em>not</em> override other campaign attributes, like the message and customization of the look and feel.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">object</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">denomination</code> </div> </td><td><span class=\"property-type\">number</span> <span class=\"property-format\">double</span></td><td><p>Amount of the reward</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">currency_code</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Currency of the reward</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">recipient</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details of the recipient of the reward</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">name</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Name of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">email</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Email address of the recipient</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">phone</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Phone number of the recipient. For non-US phone numbers, specify the country code (prefixed with +).</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">deliver_at</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">date</span></td><td><p>Timestamp of reward delivery within the next year. Note that if date-time is provided, the time values will be ignored.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">custom_fields</code> </div> </td><td><span class=\"property-type\">array</span></td><td></td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show array item type</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">id</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Tremendous ID of the custom field</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">value</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Value of the custom field</p> </td></tr> <tr class=\"property-conditional-hint-response-only\"><td><div class=\"property-name\">   <code class=\"property-name\">label</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Label of the custom field</p> </td></tr>   </tbody> </table>  </tr>  <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">language</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Set this to translate the redemption experience for this reward. Pass a 2-letter <a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\">ISO-639-1 code</a> for the desired language. Defaults to <code>en</code>.</p> </td></tr> <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">delivery</code> </div> </td><td><span class=\"property-type\">object</span></td><td><p>Details on how the reward is delivered to the recipient.</p> </td></tr>  <tr>     <td colspan=\"3\">       <details>         <summary>Show object properties</summary>         <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">method</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>How to deliver the reward to the recipient.</p>  <table>   <thead>     <tr>       <th>Delivery Method</th>       <th>Description</th>     </tr>   </thead>   <tbody>     <tr>       <td><code>EMAIL</code></td>       <td>Deliver the reward to the recipient by email</td>     </tr>     <tr>       <td><code>LINK</code></td>       <td>         <p>Deliver the reward to the recipient via a link.</p>         <p>The link can be retrieved on a successfully ordered reward via the <code>/rewards</code> or <code>/rewards/{id}</code> endpoint. That link must then be  delivered to the recipient out-of-band.</p>       </td>     </tr>     <tr>       <td><code>PHONE</code></td>       <td>Deliver the reward to the recipient by SMS</td>     </tr>   </tbody> </table> </td></tr>   </tbody> </table>  </tr>    </tbody> </table>  </tr>    </tbody> </table>  </div>   ### Funding sources  There are different ways to pay for gift cards and rewards on Tremendous. Every payment mechanism is called a \"funding source\".  You can retrieve a list of all available funding sources by using the [Funding sources API endpoint](https://tremendous.readme.io/reference/core-funding-source-index).  The Tremendous API sandbox environment comes with a single funding source that allows you to spend up to $5,000 in *fake money* to test the API. [Learn more about the sandbox environment](https://tremendous.readme.io/reference/sandbox).  The HTTP status code `200` on the response will be used to indicate success.  After processing successfully the reward gets queued to be delivered to it\'s recipient (for delivery method `EMAIL` and `PHONE`). Delivery will happen asynchronously, after the response has been sent.  ### Idempotence  Requests issued with the same external_id are idempotent.  Submitting an order with an already existing `external_id`, will result in a `201` response code. In this case the response will return a representation of the already existing order in the response body.
     * @summary Create order
     * @param {CreateOrderRequest} createOrderRequest Order to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    createOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateOrder200Response, any>>;
    /**
     * Retrieve the order, identified by the given `id` in the URL
     * @summary Retrieve order
     * @param {string} id ID of the order that should be retrieved. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrder(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateOrder200Response, any>>;
    /**
     * Retrieve a list of orders
     * @summary List orders
     * @param {number} [offset] Offsets the returned list by the given number of orders. The returned orders are ordered (and offsetted) by their creation date (DESC).
     * @param {string} [campaignId] Only return results with a matching campaign_id.
     * @param {string} [externalId] Only return results with a matching external_id.
     * @param {string} [createdAtGte] Only return results where the created_at field is greater than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {string} [createdAtLte] Only return results where the created_at field is less than or equal to the supplied value. The string needs to be an ISO 8601 datetime.
     * @param {number} [limit] Limits the number of orders listed. The maximum value is 100 and the default is 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    listOrders(offset?: number, campaignId?: string, externalId?: string, createdAtGte?: string, createdAtLte?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListOrders200Response, any>>;
    /**
     * Rejects an order that is pending review, identified by the given `id` in the URL.  Approvals is a feature that requires orders to be approved by an organization admin before they are sent out. To enable approvals for your organization, please enable \'Allow approvals via API\' via the organization\'\'s \'Order Approvals\' settings from the Tremendous dashboard.
     * @summary Reject order
     * @param {string} id ID of the order that should be rejected. In case the order has an &#x60;external_id&#x60; reference supplied by the customer on creation, it\&#39;s possible to use it instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    rejectOrder(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateOrder200Response, any>>;
}
/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export declare const OrganizationsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
     * @summary Create API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
     * @summary Create organization
     * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization: (createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Retrieve organization
     * @param {string} id ID of the organization to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * The returned list only includes the organization to which the API key belongs to, that is used for the request.
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizations: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export declare const OrganizationsApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
     * @summary Create API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKey200Response>>;
    /**
     * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
     * @summary Create organization
     * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrganization200Response>>;
    /**
     *
     * @summary Retrieve organization
     * @param {string} id ID of the organization to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganization200Response>>;
    /**
     * The returned list only includes the organization to which the API key belongs to, that is used for the request.
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizations200Response>>;
};
/**
 * OrganizationsApi - factory interface
 * @export
 */
export declare const OrganizationsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
     * @summary Create API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(options?: any): AxiosPromise<CreateApiKey200Response>;
    /**
     * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
     * @summary Create organization
     * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): AxiosPromise<CreateOrganization200Response>;
    /**
     *
     * @summary Retrieve organization
     * @param {string} id ID of the organization to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(id: string, options?: any): AxiosPromise<GetOrganization200Response>;
    /**
     * The returned list only includes the organization to which the API key belongs to, that is used for the request.
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizations(options?: any): AxiosPromise<ListOrganizations200Response>;
};
/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export declare class OrganizationsApi extends BaseAPI {
    /**
     * Creates a new API key. The API key used to make the request will remain active.  Created API keys are generated randomly and returned in the response. **You cannot retrieve them again.**
     * @summary Create API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    createApiKey(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateApiKey200Response, any>>;
    /**
     * Organizations are a way to separate different parts of your business within the same Tremendous account.  You can assign users in your Tremendous team as members to any organization. Users can be members of multiple organizations at once.  API keys belong to a single organization. The API key used in a request determines on behalf of which organization the request is carried out.  **Important note:** When creating an organization, you are required to either pass `with_api_key` or `copy_settings[user]` in the request body as `true`. This ensures that your new Organization can either be accessed via the API or the Dashboard.
     * @summary Create organization
     * @param {CreateOrganizationRequest} createOrganizationRequest Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateOrganization200Response, any>>;
    /**
     *
     * @summary Retrieve organization
     * @param {string} id ID of the organization to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    getOrganization(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetOrganization200Response, any>>;
    /**
     * The returned list only includes the organization to which the API key belongs to, that is used for the request.
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    listOrganizations(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListOrganizations200Response, any>>;
}
/**
 * ProductsApi - axios parameter creator
 * @export
 */
export declare const ProductsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Retrieve a product, identified by the given `id` in the URL
     * @summary Retrieve product
     * @param {string} id ID of the product that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProduct: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of available products
     * @summary List products
     * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
     * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProducts: (country?: string, currency?: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
export declare const ProductsApiFp: (configuration?: Configuration) => {
    /**
     * Retrieve a product, identified by the given `id` in the URL
     * @summary Retrieve product
     * @param {string} id ID of the product that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProduct(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductResponse>>;
    /**
     * Retrieve a list of available products
     * @summary List products
     * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
     * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProducts(country?: string, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProductsResponse>>;
};
/**
 * ProductsApi - factory interface
 * @export
 */
export declare const ProductsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Retrieve a product, identified by the given `id` in the URL
     * @summary Retrieve product
     * @param {string} id ID of the product that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProduct(id: string, options?: any): AxiosPromise<GetProductResponse>;
    /**
     * Retrieve a list of available products
     * @summary List products
     * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
     * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProducts(country?: string, currency?: string, options?: any): AxiosPromise<ListProductsResponse>;
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export declare class ProductsApi extends BaseAPI {
    /**
     * Retrieve a product, identified by the given `id` in the URL
     * @summary Retrieve product
     * @param {string} id ID of the product that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProduct(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetProductResponse, any>>;
    /**
     * Retrieve a list of available products
     * @summary List products
     * @param {string} [country] Comma-separated list of [Alpha-2 country codes](https://www.iban.com/country-codes), used to only retrieve products available in the provided countries
     * @param {string} [currency] Comma-separated list of [currency codes](https://www.iban.com/currency-codes), used to only retrieve products available in the provided currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    listProducts(country?: string, currency?: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListProductsResponse, any>>;
}
/**
 * PublicKeysApi - axios parameter creator
 * @export
 */
export declare const PublicKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creating a public key is the way for your organization to share it with Tremendous.  > 🔒 Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create public key
     * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublicKey: (createPublicKeyRequest: CreatePublicKeyRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
     * @summary Delete public key
     * @param {string} id ID of the public key that should be deactivated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicKey: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve an active public key, identified by the given `id` in the URL.
     * @summary Retrieve public key
     * @param {string} id ID of the public key that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch a list of active public keys on your account.  > 🚧 Inactive public keys are omitted > > The response does not include inactive public keys.
     * @summary List public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicKeys: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  > 💡 Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select “RS256” in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the “Verify signature” fields with your public and private keys and copy the “Encoded” token.
     * @summary Test public key
     * @param {string} id ID of the public key to test
     * @param {TestPublicKeyRequest} testPublicKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testPublicKey: (id: string, testPublicKeyRequest: TestPublicKeyRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PublicKeysApi - functional programming interface
 * @export
 */
export declare const PublicKeysApiFp: (configuration?: Configuration) => {
    /**
     * Creating a public key is the way for your organization to share it with Tremendous.  > 🔒 Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create public key
     * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublicKey(createPublicKeyRequest: CreatePublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>>;
    /**
     * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
     * @summary Delete public key
     * @param {string} id ID of the public key that should be deactivated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicKey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieve an active public key, identified by the given `id` in the URL.
     * @summary Retrieve public key
     * @param {string} id ID of the public key that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublicKey200Response>>;
    /**
     * Fetch a list of active public keys on your account.  > 🚧 Inactive public keys are omitted > > The response does not include inactive public keys.
     * @summary List public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKeysResponse>>;
    /**
     * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  > 💡 Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select “RS256” in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the “Verify signature” fields with your public and private keys and copy the “Encoded” token.
     * @summary Test public key
     * @param {string} id ID of the public key to test
     * @param {TestPublicKeyRequest} testPublicKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testPublicKey(id: string, testPublicKeyRequest: TestPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * PublicKeysApi - factory interface
 * @export
 */
export declare const PublicKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creating a public key is the way for your organization to share it with Tremendous.  > 🔒 Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create public key
     * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublicKey(createPublicKeyRequest: CreatePublicKeyRequest, options?: any): AxiosPromise<CreatePublicKey200Response>;
    /**
     * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
     * @summary Delete public key
     * @param {string} id ID of the public key that should be deactivated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicKey(id: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieve an active public key, identified by the given `id` in the URL.
     * @summary Retrieve public key
     * @param {string} id ID of the public key that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKey(id: string, options?: any): AxiosPromise<CreatePublicKey200Response>;
    /**
     * Fetch a list of active public keys on your account.  > 🚧 Inactive public keys are omitted > > The response does not include inactive public keys.
     * @summary List public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicKeys(options?: any): AxiosPromise<PublicKeysResponse>;
    /**
     * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  > 💡 Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select “RS256” in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the “Verify signature” fields with your public and private keys and copy the “Encoded” token.
     * @summary Test public key
     * @param {string} id ID of the public key to test
     * @param {TestPublicKeyRequest} testPublicKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testPublicKey(id: string, testPublicKeyRequest: TestPublicKeyRequest, options?: any): AxiosPromise<void>;
};
/**
 * PublicKeysApi - object-oriented interface
 * @export
 * @class PublicKeysApi
 * @extends {BaseAPI}
 */
export declare class PublicKeysApi extends BaseAPI {
    /**
     * Creating a public key is the way for your organization to share it with Tremendous.  > 🔒 Generating asymmetric keys >  > **We recommend using [OpenSSL](https://www.openssl.org/).** >  > 1. Generate a private key and a public key in PEM: > `openssl genrsa -out tremendous_key.pem 4096` >  > 2. Extract the public key in PEM format: > `openssl rsa -in tremendous_key.pem -outform PEM -pubout -out tremendous_key.pem.pub` >  > 3. And, before making your request, encode it as a `base64` string: > `base64 -i tremendous_key.pem.pub`  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">public_key</code> </div> </td><td><span class=\"property-type\">string</span></td><td><p>Base64 encoded (public) PEM file</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create public key
     * @param {CreatePublicKeyRequest} createPublicKeyRequest Public key details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    createPublicKey(createPublicKeyRequest: CreatePublicKeyRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreatePublicKey200Response, any>>;
    /**
     * Deactivates a public key. Any further attempt to verify a request signature with this key will fail.
     * @summary Delete public key
     * @param {string} id ID of the public key that should be deactivated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    deletePublicKey(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Retrieve an active public key, identified by the given `id` in the URL.
     * @summary Retrieve public key
     * @param {string} id ID of the public key that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    getPublicKey(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreatePublicKey200Response, any>>;
    /**
     * Fetch a list of active public keys on your account.  > 🚧 Inactive public keys are omitted > > The response does not include inactive public keys.
     * @summary List public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    listPublicKeys(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<PublicKeysResponse, any>>;
    /**
     * Making a request to this endpoint with a JWT signed with your private key will return a 200 response if the public key is active and the signature  is valid.  > 💡 Testing your integration >  > **You can use [JWT.io](https://jwt.io/) to generate a signed token:** >  > > 1. Select “RS256” in their algorithm dropdown; > 3. Define a JSON payload such as `{ \"foo\": \"bar\" }`; > 4. Fill the “Verify signature” fields with your public and private keys and copy the “Encoded” token.
     * @summary Test public key
     * @param {string} id ID of the public key to test
     * @param {TestPublicKeyRequest} testPublicKeyRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    testPublicKey(id: string, testPublicKeyRequest: TestPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * RewardsApi - axios parameter creator
 * @export
 */
export declare const RewardsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Generate a redemption link for the reward identified by the `id` in the URL
     * @summary Generate a reward URL
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateRewardLink: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
     * @summary Generate a reward token
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateRewardToken: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve the reward, identified by the given `id` in the URL
     * @summary Retrieve single reward
     * @param {string} id ID of the reward that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReward: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a list of all created rewards
     * @summary List rewards
     * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRewards: (offset?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Resends a reward, identified by the given `id` in the URL, to its recipient.
     * @summary Resend reward
     * @param {string} id ID of the reward that should be resent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendReward: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RewardsApi - functional programming interface
 * @export
 */
export declare const RewardsApiFp: (configuration?: Configuration) => {
    /**
     * Generate a redemption link for the reward identified by the `id` in the URL
     * @summary Generate a reward URL
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateRewardLink(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateRewardLink200Response>>;
    /**
     * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
     * @summary Generate a reward token
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateRewardToken(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateRewardToken200Response>>;
    /**
     * Retrieve the reward, identified by the given `id` in the URL
     * @summary Retrieve single reward
     * @param {string} id ID of the reward that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReward200Response>>;
    /**
     * Retrieve a list of all created rewards
     * @summary List rewards
     * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRewards(offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRewards200Response>>;
    /**
     * Resends a reward, identified by the given `id` in the URL, to its recipient.
     * @summary Resend reward
     * @param {string} id ID of the reward that should be resent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendReward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
};
/**
 * RewardsApi - factory interface
 * @export
 */
export declare const RewardsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Generate a redemption link for the reward identified by the `id` in the URL
     * @summary Generate a reward URL
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateRewardLink(id: string, options?: any): AxiosPromise<GenerateRewardLink200Response>;
    /**
     * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
     * @summary Generate a reward token
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateRewardToken(id: string, options?: any): AxiosPromise<GenerateRewardToken200Response>;
    /**
     * Retrieve the reward, identified by the given `id` in the URL
     * @summary Retrieve single reward
     * @param {string} id ID of the reward that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReward(id: string, options?: any): AxiosPromise<GetReward200Response>;
    /**
     * Retrieve a list of all created rewards
     * @summary List rewards
     * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRewards(offset?: number, options?: any): AxiosPromise<ListRewards200Response>;
    /**
     * Resends a reward, identified by the given `id` in the URL, to its recipient.
     * @summary Resend reward
     * @param {string} id ID of the reward that should be resent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendReward(id: string, options?: any): AxiosPromise<object>;
};
/**
 * RewardsApi - object-oriented interface
 * @export
 * @class RewardsApi
 * @extends {BaseAPI}
 */
export declare class RewardsApi extends BaseAPI {
    /**
     * Generate a redemption link for the reward identified by the `id` in the URL
     * @summary Generate a reward URL
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    generateRewardLink(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GenerateRewardLink200Response, any>>;
    /**
     * Generate a temporary reward token identified by the `id` in the URL. These tokens are needed to render a reward when using [Tremendous Embed](https://github.com/tremendous-rewards/embed/blob/master/docs/documentation.md). The token is valid for 24 hours.
     * @summary Generate a reward token
     * @param {string} id ID of the reward
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    generateRewardToken(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GenerateRewardToken200Response, any>>;
    /**
     * Retrieve the reward, identified by the given `id` in the URL
     * @summary Retrieve single reward
     * @param {string} id ID of the reward that should be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    getReward(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<GetReward200Response, any>>;
    /**
     * Retrieve a list of all created rewards
     * @summary List rewards
     * @param {number} [offset] Offsets the returned list by the given number of rewards. The returned rewards are ordered (and offsetted) by their creation date (DESC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    listRewards(offset?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListRewards200Response, any>>;
    /**
     * Resends a reward, identified by the given `id` in the URL, to its recipient.
     * @summary Resend reward
     * @param {string} id ID of the reward that should be resent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    resendReward(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<object, any>>;
}
/**
 * RolesApi - axios parameter creator
 * @export
 */
export declare const RolesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * List all available roles in the organization.
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * RolesApi - functional programming interface
 * @export
 */
export declare const RolesApiFp: (configuration?: Configuration) => {
    /**
     * List all available roles in the organization.
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRoles200Response>>;
};
/**
 * RolesApi - factory interface
 * @export
 */
export declare const RolesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * List all available roles in the organization.
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(options?: any): AxiosPromise<ListRoles200Response>;
};
/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export declare class RolesApi extends BaseAPI {
    /**
     * List all available roles in the organization.
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    listRoles(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListRoles200Response, any>>;
}
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export declare const WebhooksApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create webhook
     * @param {CreateWebhookRequest} createWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: (createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Delete webhook
     * @param {string} id ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Retrieve webhook
     * @param {string} id ID of the webhook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List events
     * @param {string} id ID of the webhook to list the events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks: (options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Test webhook
     * @param {string} id ID of the webhook to test
     * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    simulateWebhook: (id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WebhooksApi - functional programming interface
 * @export
 */
export declare const WebhooksApiFp: (configuration?: Configuration) => {
    /**
     * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create webhook
     * @param {CreateWebhookRequest} createWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Delete webhook
     * @param {string} id ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Retrieve webhook
     * @param {string} id ID of the webhook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWebhook200Response>>;
    /**
     * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List events
     * @param {string} id ID of the webhook to list the events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhookEvents200Response>>;
    /**
     * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhooks200Response>>;
    /**
     * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Test webhook
     * @param {string} id ID of the webhook to test
     * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    simulateWebhook(id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
};
/**
 * WebhooksApi - factory interface
 * @export
 */
export declare const WebhooksApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create webhook
     * @param {CreateWebhookRequest} createWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(createWebhookRequest: CreateWebhookRequest, options?: any): AxiosPromise<CreateWebhook200Response>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Delete webhook
     * @param {string} id ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(id: string, options?: any): AxiosPromise<void>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Retrieve webhook
     * @param {string} id ID of the webhook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(id: string, options?: any): AxiosPromise<CreateWebhook200Response>;
    /**
     * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List events
     * @param {string} id ID of the webhook to list the events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhookEvents(id: string, options?: any): AxiosPromise<ListWebhookEvents200Response>;
    /**
     * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(options?: any): AxiosPromise<ListWebhooks200Response>;
    /**
     * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Test webhook
     * @param {string} id ID of the webhook to test
     * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    simulateWebhook(id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: any): AxiosPromise<string>;
};
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export declare class WebhooksApi extends BaseAPI {
    /**
     * Tremendous uses webhooks as a notification system for various events that happen in your account.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)  Every organization can define a single webhook endpoint where we send requests to, whenever an event happens.  This endpoint allows you to setup that endpoint. The URL of the endpoint can be changed by making a request to this endpoint again with the new URL.  ## Request body  <div class=\"object-schema-request-schema\">   <table>   <thead>     <tr>       <th>Property</th>       <th>Type</th>       <th>Description</th>     </tr>   </thead>   <tbody class=\"object-schema-table-body\">     <tr class=\"\"><td><div class=\"property-name\">   <code class=\"property-name\">url</code> </div> </td><td><span class=\"property-type\">string</span> <span class=\"property-format\">uri</span></td><td><p>URL the webhook will make requests to</p> </td></tr>   </tbody> </table>  </div>
     * @summary Create webhook
     * @param {CreateWebhookRequest} createWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateWebhook200Response, any>>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Delete webhook
     * @param {string} id ID of the webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Retrieve webhook
     * @param {string} id ID of the webhook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhook(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<CreateWebhook200Response, any>>;
    /**
     * Lists all event types that can be sent to the configured webhook endpoint.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List events
     * @param {string} id ID of the webhook to list the events for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhookEvents(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListWebhookEvents200Response, any>>;
    /**
     * Every organization can only have one webhook. This endpoint shows the details about that webhook.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listWebhooks(options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListWebhooks200Response, any>>;
    /**
     * Making a request to this endpoint will cause our system to trigger a webhook for the specified event. This can be very useful when testing the setup that processes webhooks on your end.  > 📘 Learn more about Webhooks > > Our guide explains everything you need to know about the Tremendous webhooks: > [Read it here](/docs/webhooks-1)
     * @summary Test webhook
     * @param {string} id ID of the webhook to test
     * @param {SimulateWebhookRequest} simulateWebhookRequest Webhook details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    simulateWebhook(id: string, simulateWebhookRequest: SimulateWebhookRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
}
